

Ici, je veux utiliser org mode.

Par contre, mon second cerveau utilise une partie d'org-mode et org-roam.
J'active donc les parties de org-mode qd il faut, et org-roam seulement si ya mon braindump


* Config + code final

** Variables de chemins et autres utile dans tous les cas
*** Lieu de mon dossier org-directory (tout se base sur lui)

#+begin_src emacs-lisp
  (setq org-directory (expand-file-name "org/" braindump-directory))
#+end_src

*** Lieu du org-roam-directory

#+begin_src emacs-lisp
(setq org-roam-directory org-directory)
#+end_src

*** Lieu de mon dossier de bibliographie

#+begin_src emacs-lisp

  (setq bibliography-directory (expand-file-name "dossierCitation/" config-directory))
  ;; (setq my-bibliography-list (list (expand-file-name "dossierCitation/biblio.bib" bibliography-directory)
  ;; "/path/to/another/"
  ;; "/path/to/another/"
  ;; ))

  (setq bibliography-file-list (list
                                (concat bibliography-directory "biblio.bib")
                                ;; "test"
                                ))


  ;; o√π sont mes fichiers
  (setq bibliography-library-paths (list
                                (concat bibliography-directory "fichiers/")
                                ;; "test"
                                ))

#+end_src

** La biblioth√®que d'automatisations des choses (√† placer t√¥t) 


√Ä mettre √† un endroit (org-roam-db-sync 'force) pour termux automatiquement ? non

#+begin_src emacs-lisp
  (use-package vulpea
    :if braindump-exists
    :straight (vulpea
               :type git
               :host github
               :repo "d12frosted/vulpea")
    ;; hook into org-roam-db-autosync-mode you wish to enable
    ;; persistence of meta values (see respective section in README to
    ;; find out what meta means)
    :hook ((org-roam-db-autosync-mode . vulpea-db-autosync-enable))
    :config
    (defun org-roam-vulpea-bdd ()
      (interactive)
      "Mets √† jour la bdd pour l'utilisation de velpua"
      (org-roam-db-sync 'force)
      )
    )
  (require 'vulpea);;sinon ne charge pas tout je comprends pas pk

  (advice-add 'org-transclusion-add :before #'org-id-update-id-locations)


#+end_src


** Org-mode

*** Choses toujours pr√©sentes (pour l'√©dition n'importe o√π notamment)
**** Optimisation de bases
***** Les TODO en done quand tous les sous arbres sont done


Bug, car provoque les logs de state dans le titre au d√©but. Devrait √™tre r√©gl√© avec ce thread :‚ÄØ
https://mail.gnu.org/archive/html/emacs-orgmode/2022-07/msg00065.html

#+begin_src emacs-lisp :tangle no

  (defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all subentries are done, to TODO otherwise."
    (let (org-log-done org-log-states)   ; turn off logging
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)


#+end_src

Pour les checkbox
    #+begin_src emacs-lisp
      
            (defun my/org-checkbox-todo ()
              "Switch header TODO state to DONE when all checkboxes are ticked, to TODO otherwise"
              (let ((todo-state (org-get-todo-state)) beg end)
                (unless (not todo-state)
                  (save-excursion
                (org-back-to-heading t)
                (setq beg (point))
                (end-of-line)
                (setq end (point))
                (goto-char beg)
                (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                               end t)
                    (if (match-end 1)
                    (if (equal (match-string 1) "100%")
                        (unless (string-equal todo-state "DONE")
                          (org-todo 'done))
                      (unless (string-equal todo-state "TODO")
                        (org-todo 'todo)))
                      (if (and (> (match-end 2) (match-beginning 2))
                           (equal (match-string 2) (match-string 3)))
                      (unless (string-equal todo-state "DONE")
                        (org-todo 'done))
                    (unless (string-equal todo-state "TODO")
                      (org-todo 'todo)))))))))

      (add-hook 'org-checkbox-statistics-hook 'my/org-checkbox-todo)

    #+end_src

***** Better templates / <el shortcutt

Now, you can type "<el or <sh" then "tab", and let's go for org-babel !


#+begin_src emacs-lisp
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
  (add-to-list 'org-structure-template-alist '("cd" . "src C"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
  (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
  (add-to-list 'org-structure-template-alist '("json" . "src json"))
  
#+end_src

***** TODO Pour ins√©rer du sons + Jouer un son quand Done

#+begin_src emacs-lisp :tangle no

  ;; pour ins√©rer un son
  (use-package emms)
  (emms-all)
  (emms-default-players)
  ;; (setq emms-source-file-default-directory "~/Notes/Roam/sounds")
  (use-package org-emms)

  ;; pour le done
  (defun my-org-after-todo-state-change ()
    (when (string-equal org-state "DONE")
      (org-clock-out-if-current)
      (emms-add-file "~/.emacs.d/sound/done.mp3")
      (emms-start)
      ;; (emms-play-file "/home/msi/.emacs.d/sound/done.mp3")
      )
    )

  (add-hook 'org-after-todo-state-change-hook 'my-org-after-todo-state-change)


#+end_src
***** Pour avoir une barre de navigation sur le c√¥t√©

#+begin_src emacs-lisp

    (use-package org-sidebar)
      
#+end_src
***** Pour ins√©rer un nouveau titre comme le pr√©c√©dent visible 

Si je fait avec C-u, alors org-insert-heading !

#+begin_src emacs-lisp :tangle no

  ;;chargement d'une biblioth√®que
  ;; (add-to-list 'org-modules 'org-fold)

  (defun org-meta-return (&optional arg)
    "Insert a new heading or wrap a region in a table.
    Calls `org-insert-heading', `org-insert-item' or
    `org-table-wrap-region', depending on context.  When called with
    an argument, unconditionally call `org-insert-heading'."
    (interactive "P")
    ;; (org-fold-check-before-invisible-edit 'insert)
    (or (run-hook-with-args-until-success 'org-metareturn-hook)
        (call-interactively (cond (arg #'org-insert-heading)
                                  (current-prefix-arg #'org-insert-heading)
                                  ((org-at-table-p) #'org-table-wrap-region)
                                  ((org-in-item-p) #'org-insert-item)
                                  (t #'org-insert-heading-after-current)))))

#+end_src

***** Ne pas √©diter qd le heading est pli√©

#+begin_src emacs-lisp
(setq-default org-catch-invisible-edits nil)
#+end_src

***** Pas plier des heading vide

#+begin_src emacs-lisp
  (setq org-cycle-separator-lines -1)
#+end_src

***** Avoir des liste avec l'alphabet

#+begin_src emacs-lisp
  (setq org-list-allow-alphabetical t)
#+end_src

***** Laisser une ligne vide entre les titres org-mode

#+begin_src emacs-lisp
  (setq org-blank-before-new-entry
 '((heading . t)
   (plain-list-item . auto)))
#+end_src

***** Cacher les properties drawer

#+begin_src emacs-lisp :tangle no
  (defun org-cycle-hide-drawers (state)
      "Re-hide all drawers after a visibility state change."
      (interactive)
      (when (and (derived-mode-p 'org-mode)
                 (not (memq state '(overview folded contents))))
        (save-excursion
          (let* ((globalp (memq state '(contents all)))
                 (beg (if globalp
                        (point-min)
                        (point)))
                 (end (if globalp
                        (point-max)
                        (if (eq state 'children)
                          (save-excursion
                            (outline-next-heading)
                            (point))
                          (org-end-of-subtree t)))))
            (goto-char beg)
            (while (re-search-forward org-drawer-regexp end t)
              (save-excursion
                (beginning-of-line 1)
                (when (looking-at org-drawer-regexp)
                  (let* ((start (1- (match-beginning 0)))
                         (limit
                           (save-excursion
                             (outline-next-heading)
                               (point)))
                         (msg (format
                                (concat
                                  "org-cycle-hide-drawers:  "
                                  "`:END:`"
                                  " line missing at position %s")
                                (1+ start))))
                    (if (re-search-forward "^[ \t]*:END:" limit t)
                      (outline-flag-region start (point-at-eol) t)
                      (user-error msg))))))))))
#+end_src

**** Esth√©tique d'org-mode
***** Petite bulles des titres

#+begin_src emacs-lisp 

    ;; (use-package org-bullets
    ;; :after org
    ;; :hook(org-mode . org-bullets-mode)
    ;; :config

    ;; (setq org-bullets-bullet-list '("‚óâ" "‚ú∏" "‚òØ" "‚úø" "‚úú" "‚óÜ" "‚ñ∂"))
    ;; (setq org-bullets-bullet-list '("‚óâ" "‚óã" "‚ú∏" "‚úú" "‚óÜ" "‚ñ∂"))
    ;; )

  (use-package org-superstar
      :after org
      :hook (org-mode . org-superstar-mode)
      :config
      (setq org-superstar-headline-bullets-list '("‚óâ" "‚óã" "‚ú∏" "‚úú" "‚óÜ" "‚ñ∂"))
        ;; (set-face-attribute 'org-superstar-header-bullet nil :inherit 'fixed-pitched :height 200)
      
      ;; :custom
      ;; set the leading bullet to be a space. For alignment purposes I use an em-quad space (U+2001)
      ;; (org-superstar-headline-bullets-list '("‚ÄÅ"))
      ;; (org-superstar-todo-bullet-alist '(("DONE" . ?‚úî)
                                         ;; ("TODO" . ?‚åñ)
                                         ;; ("NEXT" . ?ÔÄ¶)
                                         ;; ("ISSUE" . ?ÔÄ¶)
                                         ;; ("BRANCH" . ?ÔÄ†)
                                         ;; ("FORK" . ?ÔÄÇ)
                                         ;; ("MR" . ?ÔÄâ)
                                         ;; ("MERGED" . ?ÔÄ£)
                                         ;; ("GITHUB" . ?A)
                                         ;; ("WRITING" . ?‚úç)
                                         ;; ("WRITE" . ?‚úç)
                                         ;; ))
      ;; (org-superstar-special-todo-items t)
      ;; (org-superstar-leading-bullet "")

      )







#+end_src

***** Org emphasis (surlign√©, soulign√© etc)
****** Couleurs
#+begin_src emacs-lisp 

  (setq org-emphasis-alist
	'(("*" bold)
	  ("/" italic)
	  ("_" underline)
	  ("=" (:foreground "yellow")) ;;on ne peut pas surligner lors de l'export
	  ("~" org-code verbatim)
	  ("+" (:strike-through t))))

  (defface my-org-emphasis-bold
    '((default :inherit bold)
      (((class color) (min-colors 88) (background light))
       :foreground "#a60000")
      (((class color) (min-colors 88) (background dark))
       :foreground "#ff8059"))
    "My bold emphasis for Org.")

  (defface my-org-emphasis-italic
    '((default :inherit italic)
      (((class color) (min-colors 88) (background light))
       :foreground "#005e00")
      (((class color) (min-colors 88) (background dark))
       :foreground "#44bc44"))
    "My italic emphasis for Org.")

  (defface my-org-emphasis-underline
    '((default :inherit underline)
      (((class color) (min-colors 88) (background light))
       :foreground "#813e00")
      (((class color) (min-colors 88) (background dark))
       :foreground "#d0bc00"))
    "My underline emphasis for Org.")

  (defface my-org-emphasis-strike-through
    '((((class color) (min-colors 88) (background light))
       :strike-through "#972500" :foreground "#505050")
      (((class color) (min-colors 88) (background dark))
       :strike-through "#ef8b50" :foreground "#a8a8a8"))
    "My strike-through emphasis for Org.")


#+end_src

****** Pour voir directement les liens, faire dispara√Ætre l'emphasis

#+begin_src emacs-lisp 

  (setq org-hide-emphasis-markers t)
  (straight-use-package '(org-appear :type git :host github :repo "awth13/org-appear"))
  (add-hook 'org-mode-hook 'org-appear-mode)

  ;;affiche les liens entier avec t
  ;; (setq org-appear-autolinks t)

#+end_src

***** Org font (police et taille des titres et checkbox)

Tout se trouve dans .dotfiles/.fonts

#+begin_src emacs-lisp

  ;;Pour obtenir des polices proportionnelles
  ;; (variable-pitch-mode 1)

  ;; Make sure org-indent face is available

  (require 'org-indent)

  (set-face-attribute 'org-document-title nil :font "Fira Mono" :weight 'bold :height 1.5)
  (dolist (face '((org-level-1 . 1.3)
                  (org-level-2 . 1.25)
                  (org-level-3 . 1.20)
                  (org-level-4 . 1.15)
                  (org-level-5 . 1.10)
                  (org-level-6 . 1.05)
                  (org-level-7 . 1.0)
                  (org-level-8 . 1.0)))
    ;; (set-face-attribute (car face) nil :font "JetBrains Mono" :weight 'medium :height (cdr face))
    (set-face-attribute (car face) nil :font "Fira Mono" :weight 'medium :height (cdr face))
    )


  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
  (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

  ;;couleur des checkbox
  (defface org-checkbox-todo-text
    '((t (:inherit org-todo)))
    "Face for the text part of an unchecked org-mode checkbox.")

  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?: \\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-checkbox-todo-text prepend))
   'append)

  (defface org-checkbox-done-text
    '((t (:inherit org-done)))
    "Face for the text part of a checked org-mode checkbox.")

  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-checkbox-done-text prepend))
   'append)

#+end_src
***** Nouveau symbole √† fin de titres

#+begin_src emacs-lisp

  (setq org-ellipsis "‚¨é")

  ;; (setq org-ellipsis " ÔÑá")

#+end_src

***** Voir directement les images + leur ajuster leur taille

#+begin_src emacs-lisp
    (setq org-startup-with-inline-images t)
    (setq org-image-actual-width '(800)) ;; dans une liste. voir la doc string. comme cela, je peux me servir de #+ATTR_ORG: :width 1000 ce qui est cool. un nombre simple √©crase tout, une liste est le fallback
  ;;  (setq org-image-actual-width (* (display-pixel-width) 0.8))
  (setq shr-max-image-proportion 0.9) ;; proportion de l'image prise au max. pas s√ªr que cela marche
#+end_src

***** Voir les pr√©visualisations de latex 

#+BEGIN_SRC emacs-lisp   
      (use-package org-fragtog
    :hook (org-mode . org-fragtog-mode)
    :config
    ;;taille du latex
    (plist-put org-format-latex-options :scale 1.5))
#+END_SRC

***** Indente automatiquement en fonction des titres (attention, que visuel)

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
  (diminish org-indent-mode)
#+end_src


***** Jolie icones, ne marche pas chez moi (si mais fait buguer les ic√¥nes de dired)

#+begin_src emacs-lisp :tangle no

  (defun org-icons+todoicons ()
	   "Beautify org mode keywords."
	   (interactive)
	   (setq prettify-symbols-alist '(
					  ("TODO" . "ÔÇñ")
					  ("PEUT-√äTRE" . "Ôäå")
					  ("EN-COURS" . "Ôâí")
					  ("ANNUL√â" . "ÔÅú")
					  ("DONE" . "ÔÅù")
					  ("[#A]" . "Ôàû")
					  ("[#B]" . "ÔÄ§")
					  ("[#C]" . "ÔÉ¥")
					  ("-" . "‚û§")
					  ("[ ]" . "ÔÇñ")
					  ("[X]" . "ÔÅÜ")
					  ("[-]" . "Ôâí")
					  ("#+begin_src" . ?ÔÅ£)
					  ("#+BEGIN_SRC" . ?ÔÅ£)
					  ("#+end_src" . ?ÔÅ¢)
					  ("#+END_SRC" . ?ÔÅ¢)
					  (":PROPERTIES:" . "Ôáû")
					  (":END:" . "‚Äï")
					  ("#+STARTUP:" . "ÔÇÖ")
					  ("#+TITLE: " . "")
					  ("#+RESULTS:" . "ÔÄØ")
					  ("#+NAME:" . "ÔÄ´")
					  (":ROAM_ALIASES:" . "ÔÄ¨")
					  ("#+FILETAGS:" . "ÔÄ¨")
					  ("#+HTML_HEAD:" . "Ôáº")
					  ("#+SUBTITLE:" . "Ôáú")
					  ("#+AUTHOR:" . "ÔÉÄ")
					  (":Effort:" . "ÔÄó")
					  ("SCHEDULED:" . "ÔÅ≥")
					  ("DEADLINE:" . "ÔÄù")
					  ))
	   (prettify-symbols-mode)
	   (magic-icon-fix)
	   )

  (defun magic-icon-fix ()
      (interactive)
	(let ((fontset (face-attribute 'default :fontset)))
	      (set-fontset-font fontset '(?\xf000 . ?\xf2ff) "FontAwesome" nil 'append)))



#+end_src

***** TODO Pour mettres les jolis tags :

#+begin_src emacs-lisp :tangle no

(use-package org-pretty-tags
  :config
   (setq org-pretty-tags-surrogate-strings
	 (quote
	  (("@office" . "‚úç")
	   ("PROJEKT" . "üí°")
	   ("SERVICE" . "‚úç")
	   ("Blog" . "‚úç")
	   ("music" . "‚ô¨")
	   )))
   (org-pretty-tags-global-mode))

#+end_src

**** Pour coder dans org (org-babel)
***** Les langages charg√© par org-babel

Do not load all to booste the startup time 

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     ;; (ditaa      . t)
     (C          . t)
     ;; (dot        . t)
     (emacs-lisp . t)
     ;; (scheme     . t)
     ;; (gnuplot    . t)
     ;; (haskell    . t)
     (latex      . t)
     ;; (js         . t)
     ;; (ledger     . t)
     ;; (matlab     . t)
     ;; (ocaml      . t)
     ;; (octave     . t)
     ;; (plantuml   . t)
     (python     . t)
     ;; (R          . t)
     ;; (ruby       . t)
     ;; (screen     . nil)
     ;; (scheme     . t)
     (shell      . t)
     (sql        . t)
     (sqlite     . t)
     (java     . t)
     (js . t) ;;javascripts
     )
   )

(setq org-babel-python-command "python3")

#+end_src
***** Annulation de la demande de confirmation lors de la demande d'√©valuation du code
#+begin_src emacs-lisp 
  (setq org-confirm-babel-evaluate nil)
#+end_src
***** Indente le code selon le language
Dans les blocs de code, on veut la mise en √©vidence de syntaxe, et l'on
utilise la touche TAB pour indenter (et non pour ins√©rer une tabulation)

#+begin_src emacs-lisp 
  (setq org-src-tab-acts-natively t)
#+end_src

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

***** Permet de g√©rer l'erreur des parenth√®se quand il y a un "<"

#+begin_src emacs-lisp
  
  (defun org-mode-<>-syntax-fix (start end)
    "Change syntax of characters ?< and ?> to symbol within source code blocks."
    (let ((case-fold-search t))
      (when (eq major-mode 'org-mode)
        (save-excursion
          (goto-char start)
          (while (re-search-forward "<\\|>" end t)
            (when (save-excursion
                    (and
                     (re-search-backward "[[:space:]]*#\\+\\(begin\\|end\\)_src\\_>" nil t)
                     (string-equal (downcase (match-string 1)) "begin")))
              ;; This is a < or > in an org-src block
              (put-text-property (point) (1- (point))
                                 'syntax-table (string-to-syntax "_"))))))))

  (defun org-setup-<>-syntax-fix ()
    "Setup for characters ?< and ?> in source code blocks.
  Add this function to `org-mode-hook'."
    (make-local-variable 'syntax-propertize-function)
    (setq syntax-propertize-function 'org-mode-<>-syntax-fix)
    (syntax-propertize (point-max)))

  (add-hook 'org-mode-hook #'org-setup-<>-syntax-fix)

#+end_src

***** edit emacs-lisp code block avec xah-elisp-mode

#+begin_src emacs-lisp

  (defun org-src-get-lang-mode (lang)
    "Return major mode that should be used for LANG.
      LANG is a string, and the returned major mode is a symbol."
    (when (string-equal lang "emacs-lisp")
      (setq lang "xah-elisp")
      )
    (intern
     (concat
      (let ((l (or (cdr (assoc lang org-src-lang-modes)) lang)))
        (if (symbolp l) (symbol-name l) l))
      "-mode")))

#+end_src

***** Nouvelle commande pratique pour √©diter du code dans babel

#+begin_src emacs-lisp
  (defun cp/org-edit-special-src-dwim ()
    (interactive)
    (cond
     (org-src-mode
      (when (and (string-equal major-mode cp/emacs-lisp-mode) (yes-or-no-p "√âvaluer le buffer avant de partir ?"))
        (eval-buffer))
      ;; indentation automatique
      (mark-whole-buffer)
      (indent-for-tab-command)
      (deactivate-mark)

      (org-edit-src-exit))
     ((org-in-src-block-p) (org-edit-special))
     ((derived-mode-p 'org-mode)
      (if (string-prefix-p config-directory (buffer-file-name))
          ;; si je suis dans ma config, alors ouvre directement du
          ;; emacs-lisp. sinon, propose le language
          (org-insert-structure-template "src emacs-lisp")
        (call-interactively #'org-insert-structure-template))
      (org-edit-special))))
#+end_src

***** Nouvelle commande pratique pour org-capture

#+begin_src emacs-lisp
  (defun cp/org-open-or-finish-capture ()
    (interactive)
    (message "%s" org-capture-mode)
    (if org-capture-mode
        (org-capture-finalize)
      (org-capture)))  
#+end_src


***** Nouveau raccourcis pour org-src-mode-map (plus besoin gr√¢ce √† cp/org-edit-special-capture-src-dwim)

#+begin_src emacs-lisp

  (defvar org-src-mode-map
    (let ((map (make-sparse-keymap)))
      ;; (define-key map "\C-c'" 'org-edit-src-exit)
      (define-key map "\C-c\C-c" 'org-edit-src-exit) ;; changement ici
      (define-key map "\C-c\C-k" 'org-edit-src-abort)
      (define-key map "\C-x\C-s" 'org-edit-src-save)
      map))

#+end_src

**** Latex
***** TODO Yasnippets de Latex dans org, d√©sactive org bullet, √† faire apr√®s les yasnippets

#+begin_src emacs-lisp :tangle no

  (defun my-org-latex-yas ()
    (yas-minor-mode)
    (yas-activate-extra-mode 'latex-mode)
    )


  (add-hook 'org-mode-hook 'my-org-latex-yas)
  
#+end_src
***** Les nouvelles classes latex

#+begin_src emacs-lisp

  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes
                 '("org-plain-latex"
                   "\\documentclass{article}
                   [NO-DEFAULT-PACKAGES]
                   [PACKAGES]
                   [EXTRA]"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))

                 )

    )

#+end_src
**** Options sur les exports (sauf Latex) + Nouveaux exports org-modet
***** Options g√©n√©rales
****** Ignorer les headline avec le tag ignore:

#+begin_src emacs-lisp
  (with-eval-after-load 'org-contrib
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines))
    )
#+end_src
****** Ignorer les subtree avec le tag noexport
Rien besoin de faire, si √ßa change y mettre ici

***** Html
#+begin_src emacs-lisp 
  (use-package htmlize
    :config
    (setq org-html-doctype "html5")
    (setq org-html-indent nil) ;;indentation du code automatiquement si sur t, mais tue l'indentation des balise exemple, python etc
    )
#+end_src
***** Pour twitter (why not)
#+begin_src emacs-lisp
  (use-package ox-twbs)
#+end_src
***** Epub


#+begin_src emacs-lisp  
  (use-package ox-epub)
#+end_src




**** Notes collaboratives avec org-mode ([[https://floobits.com/help/plugins/emacs][ici]]) 



#+begin_src emacs-lisp :tangle no

(use-package floobits)

#+end_src


*** Choses dans le second cerveau

#+begin_src emacs-lisp
  (when braindump-exists
#+end_src

**** Gestion des liens

Deux stockage d'id : utilis√© dans la db de org-roam, utiliser par org.
Quand on clique sur un lien, les deux marche.
Il faut dire √† org o√π sont les fichiers avec les ids

***** Les id sont cr√©√©s gr√¢ce √† la date

#+begin_src emacs-lisp

  (setq org-id-method 'ts)
  (setq org-id-ts-format "%Y%m%d%H%M%S%6N") ;; le 6N est pr√©sent pour √™tre s√ªr que se soit unique

#+end_src

(use-package org-id
  :straight nil
  :defer t
  :hook ((before-save . vulpea-id-auto-assign)
         (org-capture-prepare-finalize . org-id-get-create))
  :init
  (setq org-id-uuid-program
        "uuidgen | tr \"[:upper:]\" \"[:lower:]\"")
  :config
  (setq
   org-id-track-globally t
   org-id-extra-files
   (list (expand-file-name ".archive/archive" org-directory)
         (expand-file-name ".archive/archive.org" org-directory))
   org-id-link-to-org-use-id t
   org-id-locations-file (expand-file-name "org-id-locations"
                                           path-cache-dir)))

***** Ids chemin relatif

#+begin_src emacs-lisp
(setq org-id-locations-file-relative t)
#+end_src
***** Mise √† jour des ids

#+begin_src emacs-lisp
  ;; (org-roam-update-org-id-locations) ;; =  org-directory and org-roam-directory

  ;; (org-id-update-id-locations) ;;plus besoin normalement

  ;; seul transclude en a besoin. Peut peut-√™tre ralentir les choses

  (advice-add 'org-transclusion-add :before #'org-id-update-id-locations)

#+end_src
***** Les ids des fichiers

#+begin_src emacs-lisp
  ;; This implies that when that function is executed, the files whose
  ;; content is searched for IDs (i.e. they are scanned) are
  ;;
  ;; + The files mentioned in =org-agenda-files=.
  ;; + The archives associated to the files in =org-agenda-files=.
  ;; + The files mentioned in =org-id-locations=.
  ;; + The files provided as arguments to the =org-id-update-id-locations=.
  ;;
  ;; The following are not mentioned in the documentation of
  ;; =org-id-update-id-locations=, but when looking at the source code, you
  ;; can see that the value of the following variables is used
  ;;
  ;; + =org-id-extra-files=
  ;; + =org-id-files=
  ;;

  ;; (setq org-id-files (org-roam-list-files))

  ;;plus propre d'y mettre dans les extras
  (setq org-id-extra-files (append(directory-files-recursively config-directory "org$") (org-roam-list-files)))
#+end_src


***** Les nouveaux "types" de liens

****** Man

D√©j√† dans org-mode natif, juste √† activer

#+begin_src emacs-lisp
  (require 'ol-man)
#+end_src

****** Test de nouveau liens


#+begin_src emacs-lisp :tangle no 

  (defun org-id-open (id _)
    "Go to the entry with id ID."
    (org-mark-ring-push)
    (let ((m (org-id-find id 'marker))
          cmd)
      (unless m
        (error "Cannot find entry with ID \"%s\"" id))
      ;; Use a buffer-switching command in analogy to finding files
      (setq cmd
            (or
             (cdr
              (assq
               (cdr (assq 'file org-link-frame-setup))
               '((find-file . switch-to-buffer)
                 (find-file-other-window . switch-to-buffer-other-window)
                 (find-file-other-frame . switch-to-buffer-other-frame))))
             'switch-to-buffer-other-window))
      (if (not (equal (current-buffer) (marker-buffer m)))
          (funcall cmd (marker-buffer m)))
      (goto-char m)
      (move-marker m nil)
      (org-fold-show-context)))

  (org-link-set-parameters "id" :follow #'org-id-open)
#+end_src

#+begin_src emacs-lisp :tangle no

  (defun org-test-store-link ()
    "Store a link to the current entry, using its ID.

  If before first heading store first title-keyword as description
  or filename if no title."
    (interactive)
    (when (and (buffer-file-name (buffer-base-buffer)) (derived-mode-p 'org-mode))
      (let* ((link (concat "test:" (org-id-get-create)))
             (case-fold-search nil)
             (desc (save-excursion
                     (org-back-to-heading-or-point-min t)
                     (cond ((org-before-first-heading-p)
                            (let ((keywords (org-collect-keywords '("TITLE"))))
                              (if keywords
                                  (cadr (assoc "TITLE" keywords))
                                (file-name-nondirectory
                                 (buffer-file-name (buffer-base-buffer))))))
                           ((looking-at org-complex-heading-regexp)
                            (if (match-end 4)
                                (match-string 4)
                              (match-string 0)))
                           (t link)))))
        (org-link-store-props :link link :description desc :type "test")
        link)))

  (defun org-id-open (id _)
    "Go to the entry with id ID."
    (org-mark-ring-push)
    (let ((m (org-id-find id 'marker))
          cmd)
      (unless m
        (error "Cannot find entry with ID \"%s\"" id))
      ;; Use a buffer-switching command in analogy to finding files
      (setq cmd
            (or
             (cdr
              (assq
               (cdr (assq 'file org-link-frame-setup))
               '((find-file . switch-to-buffer)
                 (find-file-other-window . switch-to-buffer-other-window)
                 (find-file-other-frame . switch-to-buffer-other-frame))))
             'switch-to-buffer-other-window))
      (if (not (equal (current-buffer) (marker-buffer m)))
          (funcall cmd (marker-buffer m)))
      (goto-char m)
      (move-marker m nil)
      (org-fold-show-context)))

  (org-link-set-parameters "id" :follow #'org-id-open)

#+end_src


***** TODO Pour mettre des les archives dans les id

#+begin_src emacs-lisp :tangle no
(use-package org-id
  :straight nil
  :defer t
  :hook ((before-save . vulpea-id-auto-assign)
         (org-capture-prepare-finalize . org-id-get-create))
  :init
  (setq org-id-uuid-program
        "uuidgen | tr \"[:upper:]\" \"[:lower:]\"")
  :config
  (setq
   org-id-track-globally t
   org-id-extra-files
   (list (expand-file-name ".archive/archive" org-directory)
         (expand-file-name ".archive/archive.org" org-directory))
   org-id-link-to-org-use-id t
   org-id-locations-file (expand-file-name "org-id-locations"
                                           path-cache-dir)))
#+end_src

***** Les id sans org-roam

C'est possible, mais pas de backlinks, pas stock√© dans une base de donn√©e, etc. Pour la post√©rit√© cette config, ici ne sert plus √† rien

****** Ce qu'il faut comprendre
Avant, les liens √©tait stock√© comme ceci : [[lien/vers/letruc][descriptioni] ]
Donc, si on change le nom de "letruc", √ßa ne marche plus, mais c'√©tait pratique car c'√©tait des liens relatif (et donc √ßa fonctionnait partout). 
Il faut donc trouver autre chose... les id sont parfait. Mais pas relatif... on l'active, et tout est ok !

Ce qu'il faut faire :
- Ajouter, quand on stocke un lien, un id au titre (logique)
- rendre tout ceci relatif (pour rendre cela accessible de partout)
- Faire un syst√®me de completion pour ins√©rer un lien id (fait, c'est une variable exactement comme org-refile)
- rajouter diff√©rents dossier o√π je veux aussi cr√©er des link. ces dossier doivent aussi √™tre √† la bonne place (fait, comme org-agenda-files. J'ai tout mis)

****** TODO Pour mettre des liens directement avec org-insert-link id

#+begin_src emacs-lisp :tangle no

  ;; pour que les liens soit relatif, et donc pour pouvoir l'installer sur n'importe qu'elle ordinateur ! Tjr utilis√©, car pour faire la correspondance, j'utilise une table qui stocke o√π chaque id est
  (setq org-id-locations-file-relative t)

  ;;lieu du fichier des loccation :
  ;;voir no-littering

  ;;voir le manual pour plus d'information. Ne me cr√©era pas d'id inutile
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

  ;; ;; O√π chercher des fichiers en plus pour les ID.  Si la valeur de org-id-extra-files est nul, alors org-agenda-text-search-extra-files prendra le dessus, mais cela correspond aussi aux fichiers org-agenda ajout√©. Il faut donc prendre d'autres fichiers. L√†, j'ai vraiment tout mis.
  (setq org-id-extra-files
        (append
         mesdocuments-directory-all-org-files
         org-directory-all-org-files
         shared-directory-private-all-org-files
         my-user-emacs-configuration-list
         )
        )

  ;;ceci est la liste des fichiers (qui pernds des liste en param√®tre) qui vont s'afficher quand on va faire un org-insert-link id. m√™me syntaxe que les refile
  (setq org-try-targets
        '(
          ;;refile dans le buffer courant jusqu'au niveau 7
          (nil :maxlevel . 7)
          ;;refile dans tous les fichiers de l'agenda jusqu'au niveau 5
          (org-agenda-files :maxlevel . 5)
          ;;refile les documents
          (mesdocuments-directory-all-org-files :maxlevel . 1)
          ;;pour refile document_partage
          (shared-directory-private-all-org-files :maxlevel . 5)
          (my-user-emacs-configuration-list :maxlevel . 5)
          )
        )


  ;; pour la compl√©tion lors de l'insertion d'un lien id avec org-insert-link id, la compl√©tion est 
  ;;il faut personnaliser org-try-targets comme un org-refile-targets
  (defun org-id-complete-link (&optional arg)
    "Create an id: link using completion"
    (concat "id:"
            (org-id-get-with-outline-path-completion org-try-targets)
            ;; (org-id-get-with-outline-path-completion org-id-extra-files)            ;; l√† je prends vraiment tout
            ;; (org-id-get-with-outline-path-completion org-refile-targets) ;;pas mal pour les refiles
            ;; (org-id-get-with-outline-path-completion) ;; pour avoir d'autres completion par exemple
            )
    )
  ;;pour que √ßa marche apr√®s org 9.0
  (org-link-set-parameters "id" :complete 'org-id-complete-link)


#+end_src

****** Pour nettoyer les id inutilis√©

#+begin_src emacs-lisp :tangle no
(use-package org-id-cleanup)
#+end_src

****** On update √† la fin ?

#+begin_src emacs-lisp
  ;; Update ID file .org-id-locations on startup
  ;; (org-id-update-id-locations)
#+end_src


**** Gestion des m√©tadata

***** Gestion de la derni√®re date de modification, enlever, g√©rer par git

Maj du package : j'enl√®ve la cr√©ation de ctime, car c'est donn√© par l'id ! et je remplace la fonction qui obtient le ctime par la partie de l'id qu'il faut (pour plus tard je pense)

#+begin_src emacs-lisp :tangle no

  
  (use-package org-roam-timestamps
    :after org-roam
    :config

    (defun org-roam-timestamps--on-save ()
      "Set the MTIME property of the current org-roam-node to the current time."
      (when (org-roam-buffer-p)
        (let* ((node (org-roam-node-at-point))
               (file (org-roam-node-file node))
               (pos (org-roam-node-point node))
               (level (org-roam-node-level node))
               (mtime (org-roam-timestamps--get-mtime node)))

          (org-roam-timestamps--add-mtime node mtime)
          (when (and org-roam-timestamps-timestamp-parent-file (not (eq level 0)))
            (let* ((pnode (org-roam-timestamps--get-parent-file-node file))
                   (pmtime (org-roam-timestamps--get-mtime pnode))
                   (ppos (buffer-end -1)))
              (org-roam-timestamps--add-mtime pnode pmtime)
              ))
          nil)))


    (defun org-roam-timestamps-all ()
      "Go through all nodes and add timestamps to them."
      (interactive)
      (when (yes-or-no-p "This will modify all your current notes by adding a ctime and mtime property
        to all property drawers. We will make a backup of your notes and db first.
        This might take a second. Are you sure you want to continue?")
        (let ((backup-dir (expand-file-name "org-roam-timestamp.bak"
                                            (file-name-directory (directory-file-name org-roam-directory))))
              (backup-db (expand-file-name "org-roam-db.bak" (file-name-directory org-roam-db-location))))
          (message "Backing up files to %s" backup-dir)
          (copy-directory org-roam-directory backup-dir)
          (message "Backing up db to %s" backup-db)
          (copy-file org-roam-db-location backup-db))
        (let ((nodes (org-roam-db-query [:select id :from nodes])))
          (dolist (node nodes)
            (let* ((n (org-roam-node-from-id (car node)))
                   (file (org-roam-node-file n))
                   (mtime (org-roam-timestamps-decode (org-roam-node-file-mtime n)))
                   (pos (org-roam-node-point n))
                   (props (org-roam-node-properties n)))
              (org-roam-with-file file nil
                (goto-char pos)
                (unless (assoc-default "MTIME" props)
                  (org-roam-property-add "mtime" mtime ))
                (save-buffer))))))
      (org-roam-db-sync))

    (defun org-roam-timestamps--get-ctime (pos)
      "Return the current ctime for the node at point POS."
      (substring (org-id-get) 0 14)
      ;; (org-with-wide-buffer
      ;; (org-entry-get pos "ctime"))
      )


    (defun org-roam-timestamps-clean-mtime ()
      "Truncate all timestamps to a single value.
  A modifier pour supprimer tous les mtime si jamais"
      (interactive)
      (org-roam-timestamps-mode -1)
      (let ((nodes (org-roam-db-query [:select id :from nodes])))
        (dolist (node nodes)
          (let* ((n (org-roam-node-from-id (car node)))
                 (file (org-roam-node-file n))
                 (pos (org-roam-node-point n)))
            (org-roam-with-file file nil
              (org-with-wide-buffer
               (if-let ((mtime (org-roam-timestamps--get-mtime n))
                        (split (split-string mtime)))
                   (org-entry-put pos "mtime"  (car split)) ;;cette ligne
                 (save-buffer)))))))
      (org-roam-timestamps-mode 1))

    (setq org-roam-timestamps-minimum-gap 3600)
    (org-roam-timestamps-mode)


    )

#+end_src

Ancienne m√©thode :

#+begin_src emacs-lisp :tangle no

  (use-package time-stamp
    :straight nil
    ;; :defer t
    :config
    ;; ne pas oublier de le mettre dans le capture
    ;; :head "#+TITLE: ${title}\n#+CREATED: %U\n#+LAST_MODIFIED: %U\n\n"
    (setq time-stamp-active t
          time-stamp-start "\\- Modifi√© :: [ \t]*"
          time-stamp-end "$"
          time-stamp-format "%Y%m%d%H%M%S"  ;; impossible de mettre des nano seconds, √ßa marchera tr√®s bien quand m√™me
          time-stamp-line-limit 20)

    (add-hook 'before-save-hook 'time-stamp nil)
    ;; (remove-hook 'before-save-hook 'time-stamp nil)
    )


#+end_src




***** Fonctions pour "Fait", permet de mettre quand j'ai fait quelque chose

#+begin_src emacs-lisp

  (defun cp-vulpea-meta-fait-add ()
    (interactive)
    (let* (
           (id (save-excursion (goto-char (point-min)) (org-id-get)))
           (key "Fait")
           (timestamp (format-time-string "%Y%m%d%H%M%S"))
           (fait-p (vulpea-meta-get id key))
           )
      (if fait-p
          (vulpea-meta-set id key (concat (vulpea-meta-get id key) ", " timestamp) t)
        (vulpea-meta-set id key timestamp t))

      )
    )

  (defun cp-vulpea-meta-fait-remove ()
    (interactive)
    (let* (
           (id (save-excursion (goto-char (point-min)) (org-id-get)))
           (key "Fait")
           (timestamp (format-time-string "%Y%m%d%H%M%S"))
           (fait-p (vulpea-meta-get id key))
           )
      (when fait-p
        (vulpea-meta-remove id key)
        )
      )
    )

#+end_src

**** Gestion de capture de connaissances
***** Lieu de mon inbox

#+begin_src emacs-lisp
(setq capture-inbox-file
    (expand-file-name (format "inbox-%s.org" (system-name)) org-roam-directory)
    )
#+end_src

***** Moteur de Org-capture
:PROPERTIES:
:ID:       54e7121a-93ed-4fb8-96b7-83cba535c170
:END:

Si la touche √† appuyer est en maj, ceci est fait pour org-protocol !

#+begin_src emacs-lisp :tangle no



  (setq theKey "4est")

  (setq x 116)



  

  (sequencep )


#+end_src

#+begin_src emacs-lisp

  (defun cp/return-key-for-capture (theKey)
    "theKey is a string"
    (let ((result nil))
      (if (fboundp 'xah-fly--key-char)
          (seq-mapcat (lambda (x) (xah-fly--key-char (char-to-string x)))
                      (string-to-list theKey)
                      'string)
        theKey)))

  (setq org-capture-templates
        `((,(cp/return-key-for-capture "h") "todo" plain (file capture-inbox-file)
           (file "../templatesOrgCapture/todo.org"))
          (,(cp/return-key-for-capture "u") "tickler" entry
           (function cp/vulpea-capture-tickler-target)
           (file "../templatesOrgCapture/tickler.org")
           :immediate-finish t
           )
          (,(cp/return-key-for-capture "n") "un rdv" entry
           (function cp/vulpea-capture-rdv-target)
           (file "../templatesOrgCapture/rdv.org")
           :immediate-finish t
           )

          ("T" "test" entry
           (function cp/vulpea-capture-tickler-target)
           "* TODO %^{Nom du tickler} :tickler:\nSCHEDULED: %^T\n%?"
           )

          ;; ("c" "nouvelle connaissance" entry
          ;; (file capture-inbox-file)
          ;; (file "../templatesOrgCapture/connaissances.org")
          ;; :immediate-finish t
          ;; )

          ))
#+end_src

Ancien : 

#+begin_src emacs-lisp :tangle no


  ;; quand on donne un truc relatif, alors le org-directory est bien appel√© ! Si je mets des fonctions pour les templates √† r√©cup√©r√© √ßa ne marche plus. Oblig√© de laisser les capture templates dans le dossier braindump et en dehors du dossier org-directory (sinon la bdd dit double id)



  ;;les raccourcis ici ne sont pas important, mais doivent faire le liens entre TODO

  ;; (setq org-capture-templates-models (expand-file-name "templatesOrgCapture/" user-emacs-directory))

  (setq org-capture-templates '
        (

         ("t" "Pour les timestamps")
         ("tt" "Tickler" entry
          (file (lambda() (concat orgzly-directory "AgendaTickler.org")))
          (file "templatesOrgCapture/tickler.org")
          :immediate-finish t
          )
         ("te" "√âv√®nement sur plusieurs heures" entry
          (file (lambda() (concat orgzly-directory "AgendaTickler.org")))
          (file "templatesOrgCapture/evenement.org")
          :immediate-finish t
          )

         ("td" "√âv√®nement sur plusieurs jours" entry
          (file (lambda() (concat orgzly-directory "AgendaTickler.org")))
          (file "templatesOrgCapture/evenementplusieursjours.org")
          :immediate-finish t
          )


         ("i" "Inbox (TODO)" entry
          (file (lambda() (concat orgzly-directory "Inbox.org")))
          (file "templatesOrgCapture/todo.org")
          :immediate-finish t
          )
         ("n" "Inbox (NEXT)" entry
          (file capture-inbox-file)
          (file "../templatesOrgCapture/next.org")
          :immediate-finish t
          )

         ("s" "Slipbox for org-roam" entry  (file "braindump/org/inbox.org")
          "* %?\n")

         ("d" "Journal de dissactifaction" entry (file  "org/journal_de_dissatisfaction.org")
          "* %<%Y-%m-%d> \n- %?")

         ("c" "Contacts" entry
          (file+headline (lambda() (concat orgzly-directory "Contacts.org" ))"Inbox")
          (file "templatesOrgCapture/contacts.org")
          ;; :immediate-finish t
          ;; :jump-to-captured t
          )

         ("a" "Image dans Artiste")

         ("at" "Image + artiste" entry (file  "org/artistes.org" )
          (file "templatesOrgCapture/artistes.org")
          :jump-to-captured 1
          )

         ("as" "Image" entry (file "org/artistes.org" )
          (file "templatesOrgCapture/image.org")
          ;; :jump-to-captured 1
          )

         ;; ici se trouve les choses utilis√© pour org-protocol
         ;; pour mes raccourcis
         ("O" "Link capture" entry
          (file+headline "org/orgzly/Bookmarks.org" "INBOX")
          "* %a %U"
          :immediate-finish t)


         ;; ("P" "org-popup" entry (file+headline "braindump/org/inbox.org" "Titled Notes")
         ;; "%[~/.emacs.d/.org-popup]" :immediate-finish t :prepend t)
         )
        )


#+end_src

***** Ajouter des fonctions suites aux captures, comme pour mettre des dates ou cr√©er un ID

#+begin_src emacs-lisp

  ;; pour rajouter un ID OU¬†DES¬†COMMANDES √† la fin de la capture !
  (defun cp/org-capture-finalize ()
    "Comprend la valeur de la key de org capture et d√©cide de faire qql apr√®s le capture ou pas"
    (let ((key  (plist-get org-capture-plist :key))
          (desc (plist-get org-capture-plist :description)))
      (if org-note-abort
          (message "Template with key %s and description ‚Äú%s‚Äù aborted" key desc)
        (message "Template with key %s and description ‚Äú%s‚Äù run successfully" key desc)
        )
      (when (string= key "A") 		;si jamais c'est A, alors faire la suite
        (org-capture-goto-last-stored)
        (org-id-get-create)	    
        )
      (when (string= key "t") 		;etc
        ;; (org-capture-goto-last-stored)
        ;; (org-schedule nil nil)
        ;; (winner-undo)
        )
      (when (string= key "e") 		;etc
        ;; (org-capture-goto-last-stored)
        ;; (org-schedule nil nil)
        ;; (winner-undo)
        )
      (when (string= key "as") 		;etc
        (org-capture-goto-last-stored)
        (newline)
        (newline)
        (org-download-clipboard)
        ;; (org-schedule nil nil)
        ;; (winner-undo)
        )
      )
    )

  ;; (add-hook 'org-capture-after-finalize-hook 'cp/org-capture-finalize)

#+end_src

***** Fonctions pour choisir dynamiquement les destinations

****** un tickler
#+begin_src emacs-lisp

  (defun cp/vulpea-capture-tickler-target ()
    "Return a target for a tickler capture."
    (let ((place (vulpea-select
                  "O√π va le tickler selectionn√© ")))
      ;; unfortunately, I could not find a way to reuse
      ;; `org-capture-set-target-location'
      (if (vulpea-note-id place)
          (let ((path (vulpea-note-path place)))
            (set-buffer (org-capture-target-buffer path))
            ;; Org expects the target file to be in Org mode, otherwise
            ;; it throws an error. However, the default notes files
            ;; should work out of the box. In this case, we switch it to
            ;; Org mode.
            (unless (derived-mode-p 'org-mode)
              (org-display-warning
               (format
                "Capture requirement: switching buffer %S to Org mode"
                (current-buffer)))
              (org-mode))

            (goto-char (point-max))
            ;; (insert "je suis l√†")

            (org-capture-put-target-region-and-position)
            (widen))
        ;;cas si personne trouv√©, alors √ßa va direct dans l'inbox
        (let ((path capture-inbox-file))
          (set-buffer (org-capture-target-buffer path))
          (org-capture-put-target-region-and-position)
          (widen)))))

  ;; plus besoin de cette fonction
  (defun cp/vulpea-capture-tickler-template ()
    "Return a template for a meeting capture."
    (let ((anote (vulpea-select
                  "O√π va le tickler selectionn√© : ")))
      (org-capture-put :target-tickler anote)
      "* TODO %^{Nom du tickler} :tickler:\nSCHEDULED: %^T\n%?"))



#+end_src



****** un rdv
#+begin_src emacs-lisp

  (defun cp/vulpea-capture-rdv-target ()
    "Return a target for a tickler capture."
    (let ((person (vulpea-select
                   "O√π va le rdv selectionn√© : ")))
      ;; unfortunately, I could not find a way to reuse
      ;; `org-capture-set-target-location'
      (if (vulpea-note-id person)
          (let ((path (vulpea-note-path person)))
            (set-buffer (org-capture-target-buffer path))
            ;; Org expects the target file to be in Org mode, otherwise
            ;; it throws an error. However, the default notes files
            ;; should work out of the box. In this case, we switch it to
            ;; Org mode.
            (unless (derived-mode-p 'org-mode)
              (org-display-warning
               (format
                "Capture requirement: switching buffer %S to Org mode"
                (current-buffer)))
              (org-mode))

            (goto-char (point-max))

            (org-capture-put-target-region-and-position)
            (widen)
            )
        ;;cas si personne trouv√©, alors √ßa va direct dans l'inbox
        (let ((path capture-inbox-file))
          (set-buffer (org-capture-target-buffer path))
          (org-capture-put-target-region-and-position)
          (widen)))))

  ;; plus besoin de cette fonction
  (defun cp/vulpea-capture-rdv-template ()
    "Return a template for a meeting capture."
    (let ((anote (vulpea-select
                  "O√π va le tickler selectionn√© : ")))
      (org-capture-put :target-tickler anote)
      "* TODO %^{Nom du tickler} :tickler:\nSCHEDULED: %^T\n%?"))



#+end_src


****** Meeting avec une personne

#+begin_src emacs-lisp

  (defun vulpea-capture-meeting-template ()
    "Return a template for a meeting capture."
    (let ((person (vulpea-select
                   "Person"
                   :filter-fn
                   (lambda (note)
                     (let ((tags (vulpea-note-tags note)))
                       (seq-contains-p tags "people"))))))
      (org-capture-put :meeting-person person)
      (if (vulpea-note-id person)
          "* MEETING [%<%Y-%m-%d %a>] :REFILE:MEETING:\n%U\n\n%?"
        (concat "* MEETING with "
                (vulpea-note-title person)
                " on [%<%Y-%m-%d %a>] :MEETING:\n%U\n\n%?"))))

  (defun vulpea-capture-meeting-target ()
    "Return a target for a meeting capture."
    (let ((person (org-capture-get :meeting-person)))
      ;; unfortunately, I could not find a way to reuse
      ;; `org-capture-set-target-location'
      (if (vulpea-note-id person)
          (let ((path (vulpea-note-path person))
                (headline "Meetings"))
            (set-buffer (org-capture-target-buffer path))
            ;; Org expects the target file to be in Org mode, otherwise
            ;; it throws an error. However, the default notes files
            ;; should work out of the box. In this case, we switch it to
            ;; Org mode.
            (unless (derived-mode-p 'org-mode)
              (org-display-warning
               (format
                "Capture requirement: switching buffer %S to Org mode"
                (current-buffer)))
              (org-mode))
            (org-capture-put-target-region-and-position)
            (widen)
            (goto-char (point-min))
            (if (re-search-forward
                 (format org-complex-heading-regexp-format
                         (regexp-quote headline))
                 nil t)
                (beginning-of-line)
              (goto-char (point-max))
              (unless (bolp) (insert "\n"))
              (insert "* " headline "\n")
              (beginning-of-line 0)))
        (let ((path vulpea-capture-inbox-file))
          (set-buffer (org-capture-target-buffer path))
          (org-capture-put-target-region-and-position)
          (widen)))))

#+end_src


**** Gestion changement rapide de place pour les noeuds
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-27 Wed 18:35]
:END:

Ne pas oublier la commande org-roam-refile.

#+begin_src emacs-lisp

  ;;pour voir le chemin lors du refile
  (setq org-outline-path-complete-in-steps nil)
  ;; permet de d√©placer avec un niveau de titre 1 ! (dans tickler par exemple)
  (setq org-refile-use-outline-path (quote file))



  (setq org-refile-targets
        '(
          ;;refile dans le buffer courant jusqu'au niveau 7
          (nil :maxlevel . 7)
          ;;refile dans tous les fichiers de l'agenda jusqu'au niveau 5
          ;; (org-agenda-files :maxlevel . 5) ;;c'est d√©j√† orgzly-directory-all-org-files
          ;;refile dans mes notes
          (org-roam-list-files :maxlevel . 1)
          )
        )
#+end_src

**** Gestion de l'agenda

***** Options de base


#+begin_src emacs-lisp

  ;; Nouvelle touche pour mieux naviguer avec xah
  (define-key org-agenda-mode-map [remap next-line] #'org-agenda-next-item)
  (define-key org-agenda-mode-map [remap previous-line] #'org-agenda-previous-item)
  ;;
  (define-key org-agenda-mode-map [remap ?\r] #'org-agenda-goto)

  ;;avoir "org", notamment org-schedule, en anglais, indispensable pour orgzly
  (eval-after-load 'org (setq system-time-locale "C"))

  ;;  pour que le curseur soit en haut de org agenda quand t on l'ouvre
  (add-hook 'org-agenda-finalize-hook (lambda () (goto-char (point-min))) 90)

  ;;ouvre l'agenda dans la window actuel
  (setq org-agenda-window-setup 'current-window)

  ;; quand commance l'agenda ?
  ;;pas le week
  (setq org-agenda-start-on-weekday nil)
  ;; mais X jour apr√®s aujourd'hui
  (setq org-agenda-start-day "+0d")

  ;;vue de l'agenda sur X jours
  (setq org-agenda-span 8)

#+end_src



***** Gestion des priorit√©

****** Permet de mettre les t√¢ches sans priorit√© en priorit√© minimal - 1

#+begin_src emacs-lisp
  ;; permet de mettre  A B C nil priorit√© dans l'ordre
  ;; une t√¢che qui n'a pas de priorit√© "poss√®de" donc une priorit√© n√©gative
  (setq cp/org-default-priority (+ org-priority-lowest 1))
  (setq org-default-priority cp/org-default-priority)

  ;; on ne commence par par -1 pour mettre une priorit√©
  (setq org-priority-start-cycle-with-default nil)

#+end_src

****** Permet de savoir si un heading √† une priorit√©

#+begin_src emacs-lisp

  (defun cp/org-get-priority-p(s)
    "Renvoie vrai si il y a un anc√™tre qui √† une priorit√©, peut √™tre en r√©cursive un jour"
    (interactive)
    (save-excursion
      (while (ignore-errors (outline-up-heading 1 t)))
      (let (($p1 (progn (beginning-of-line) (point)))
            ;; ($p2 (progn (cp/org-goto-end-of-heading) (point)))
            ($p2 (progn (end-of-line) (point)))
            result)
        (save-restriction
          (narrow-to-region $p1 $p2)
          (goto-char $p1)
          (when (re-search-forward ".*?\\(\\[#\\([A-Z0-9]+\\)\\] ?\\)" nil t)
            (setq result t))))))

#+end_src

ancien :
#+begin_src emacs-lisp :tangle no

  (defun cp/org-get-priority-p(s)
    (> (org-get-priority s) 0) ;; check si elle est n√©gative
    )

#+end_src

****** Priorit√© h√©rit√©e

Marche pas pour org-ql
M√™me si la priorit√© n'est pas marqu√©, la priorit√© des subheading est bien la m√™me que leur anc√™tre (ou du subheading le plus proche)

#+begin_src emacs-lisp
  ;; ne marche pas ? normal car je veux la priorit√©, pas les propri√©t√©s...
  ;; (setq org-use-property-inheritance t)
#+end_src

#+begin_src emacs-lisp 

  ;; marche, mais seulement pour les fonctionnalit√© qui appelle org-priority-get-priority-function (donc presque tout)
  (defun my/org-inherited-priority (s)
    (save-excursion
      (cond
       ;; Priority cookie in this heading
       ((string-match org-priority-regexp s)
        (* 1000 (- org-priority-lowest
                   (org-priority-to-value (match-string 2 s)))))
       ;; No priority cookie, but already at highest level
       ((not (org-up-heading-safe))
        (* 1000 (- org-priority-lowest org-priority-default)))
       ;; Look for the parent's priority
       (t
        (my/org-inherited-priority (org-get-heading))))))

  (setq org-priority-get-priority-function #'my/org-inherited-priority)

#+end_src

***** Export de l'agenda en icalendar


#+begin_src emacs-lisp

  ;;Lieu de l'export org-icalendar-combine-agenda-files
  (setq org-icalendar-combined-agenda-file (expand-file-name "agendapourgoogle.ics" braindump-directory))

  (setq org-icalendar-with-timestamps 'active) ;; seulement les timestamp active pour exporter les √©v√®menements.
  (setq org-icalendar-include-todo nil) ;; sinon √ßa clone les choses schedulded
  (setq org-icalendar-use-scheduled '(
                                      ;; event-if-not-todo ;;pour pas exporter mes tickler
                                      event-if-todo-not-done
                                      event-if-not-todo ;;‚ÄØ pour exporter mes rdv
                                      ))
  (setq org-icalendar-use-deadline '(event-if-not-todo
                                     event-if-todo-not-done
                                     ))


  ;; ne pas exporter les tickler
  (setq org-icalendar-exclude-tags '("tickler"))


  ;;fonction export en background + message pour v√©rif que √ßa marche
  (defun org-icalendar-combine-agenda-files-background()
    (interactive)
    (message "Lancement du icalendar combine file (pour org.ics)")
    (org-icalendar-combine-agenda-files t)
    )

  (defun org-icalendar-combine-agenda-files-foreground()
    (interactive)
    (org-icalendar-combine-agenda-files nil)
    (message "fini")
    )

  ;; quand je close emacs, lance le processus
  (add-hook 'kill-emacs-hook #'org-icalendar-combine-agenda-files-foreground)

  ;; d√®s que la data base se syncronise, je mets √† jour mon calendrier

  ;; TODO

  ;; (advice-add 'org-roam-db-sync :after #'org-icalendar-combine-agenda-files-background)


  ;; (advice-remove 'org-roam-db-sync #'org-icalendar-combine-agenda-files-background)

#+end_src


***** Gestion de l'agenda (visuel) 


On peut utiliser la propri√©t√© "cat√©gorie", mais c'est long, donc on fait pl√ªt√¥t par rapport au nom du fichier. Mais par d√©faut, le nom √† la date (ce qui est pratique), donc il faut enlever cette date.

Patch de org agenda pour que √ßa marche, avec sa biblioth√®que vulpea

****** Le format des choses affich√©
#+begin_src emacs-lisp

    (setq org-agenda-prefix-format
        '((agenda . " %i %(vulpea-agenda-category 12)%?-12t% s")
          ;; (agenda . " %i %(vulpea-agenda-category 12)%?-12t%-6e% s") ;; pour voir l'effort estimate
          (todo . " %i %(vulpea-agenda-category 12) ")
          (tags . " %i %(vulpea-agenda-category 12) ")
          (search . " %i %(vulpea-agenda-category 12) ")))

  ;; (todo . " %i %(vulpea-agenda-category 12) %(let ((scheduled (org-get-scheduled-time (point)))) (if scheduled (format-time-string \"Schedulded to <%Y-%m-%d-%H-%M %a>\" scheduled) \"\"))")

#+end_src

(setq org-agenda-prefix-format  '((agenda . " %i %-12:c%?-12t% s")
                                    (todo . " %i %-12:c")
                                    (tags . " %i %-12:c")
                                    (search . " %i %-12:c")))

****** Jolie affichage des cat√©gories trop longue, et la cat√©gorie √©gale le titre - la date

#+begin_src emacs-lisp
  (defun vulpea-agenda-category (&optional len)
    "Get category of item at point for agenda.

  Category is defined by one of the following items:

  - CATEGORY property
  - TITLE keyword
  - TITLE property
  - filename without directory and extension

  When LEN is a number, resulting string is padded right with
  spaces and then truncated with ... on the right if result is
  longer than LEN.

  Usage example:

    (setq org-agenda-prefix-format
          '((agenda . \" %(vulpea-agenda-category) %?-12t %12s\")))

  Refer to `org-agenda-prefix-format' for more information."
    (let* ((file-name (when buffer-file-name
                        (file-name-sans-extension
                         (file-name-nondirectory buffer-file-name))))
           (title (vulpea-buffer-prop-get "title"))
           (category (org-get-category))
           (result
            (or (if (and
                     title
                     (string-equal category file-name))
                    title
                  category)
                "")))
      (if (numberp len)
          (s-truncate len (s-pad-right len " " result))
        result)))

#+end_src




****** Voir plus de choses dans l'agenda 



Faire la touche "v" dans l'agenda ! A pour voir les task dans fichiers archiv√©. l pour log-mode (voir les diff√©rents states) ([[https://stackoverflow.com/questions/56228430/display-scheduled-routines-actual-done-time-in-agenda-view][vient d'ici]] pour log-mode correctement)

#+begin_src emacs-lisp

  ;; ajout des choses √† voir avec org-agenda log mode (raccourcis "l" dans l'agenda).
  ;; permet de voir les diff√©rents states notamment
  (setq org-agenda-log-mode-items '(closed clock state))

  ;; si je veux que cela commence en mode log-mode. Pas s√ªr que ce soit CETTE variable
  ;;‚ÄØ(setq org-agenda-start-with-log-mode '(closed clock state))

#+end_src
****** Nombre de jour de pr√©voyance pour la deadline (dans la vue agenda)

#+begin_src emacs-lisp
  (setq org-deadline-warning-days 5)
#+end_src


***** Gestion de l'agenda (commandes)
****** Construction dynamique de mon agenda

Principe : mettre aux notes qui ont un state todo un tag "project", puis parcourir les fichiers de la base de donn√©e, ajouter dans une liste les fichiers avec le tag "projet", et mettre cette liste comme variable :‚ÄØorg-agenda-files. Facile

Ne rajoute pas le tag "projet" au headline dans un fichier qui a comme filetag "project" (logique, car sinon tous les noeuds en dessous ont le tag projet aussi. Seul les fichiers nous int√©resse)

#+begin_src emacs-lisp

    (setq org-tags-exclude-from-inheritance '(
                                              "PROJET"
                                              "PERSONNE" ;;√ßa vraiment ?
                                              "crypt"
                                              )
          )

  
#+end_src

Pour ajouter des fichiers dans une liste:

(setq test "/home/utilisateur/sharedDirectoryPrivate/notes/org/orgzly/GTD.org")
(push test org-agenda-files)

******* Tag projet √† la note si il y a un state TODO dedans

#+begin_src emacs-lisp

  ;; ne pas mettre, emp√™che le d√©marrage d'emacs. Pk ?
  (add-hook 'find-file-hook #'vulpea-project-update-tag)

  (add-hook 'before-save-hook #'vulpea-project-update-tag)

  (defun vulpea-project-update-tag ()
    "Update PROJET tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (vulpea-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (vulpea-buffer-tags-get))
               (original-tags tags))
          (if (vulpea-project-p)
              (setq tags (cons "PROJET" tags))
            (setq tags (remove "PROJET" tags)))

          ;; cleanup duplicates
          (setq tags (seq-uniq tags))

          ;; update tags if changed
          (when (or (seq-difference tags original-tags)
                    (seq-difference original-tags tags))
            (apply #'vulpea-buffer-tags-set tags))))))

  (defun vulpea-buffer-p ()
    "Return non-nil if the currently visited buffer is a note."
    (and buffer-file-name
         (string-prefix-p
          (expand-file-name (file-name-as-directory org-roam-directory))
          (file-name-directory buffer-file-name))))

  (defun vulpea-project-p ()
    "Return non-nil if current buffer has any todo entry.

      TODO entries marked as done are ignored, meaning the this
      function returns nil if current buffer contains only completed
      tasks."
    (org-element-map                          ; (2)
        (org-element-parse-buffer 'headline) ; (1)
        'headline
      (lambda (h)
        (eq (org-element-property :todo-type h)
            'todo))
      nil 'first-match))                     ; (3)

#+end_src

Test :

#+begin_src emacs-lisp :tangle no
  (defun vulpea-project-p ()
    "Return non-nil if current buffer has any todo entry or schedulded.

        TODO entries marked as done are ignored, meaning the this
        function returns nil if current buffer contains only completed
        tasks."
    (org-element-map                          ; (2)
        (org-element-parse-buffer 'headline) ; (1)
        'headline
      (lambda (h)
        (or
         (eq (org-element-property :todo-type h)
             'todo)
         (not (eq (org-element-property :scheduled h)
                  'nil))
         ))
      nil 'first-match))
#+end_src

******** Explication de la derni√®re fonction
This might look a little bit too much, so let me explain the code step by step.

We parse the buffer using org-element-parse-buffer. It returns an abstract syntax tree of the current Org buffer. But sine we care only about headings, we ask it to return only them by passing a GRANULARITY parameter - 'headline. This makes things faster.
Then we extract information about TODO keyword from headline AST, which contains a property we are interested in - :todo-type, which returns the type of TODO keyword according to org-todo-keywords - 'done, 'todo or nil (when keyword is not present).
Now all we have to do is to check if the buffer list contains at least one keyword with 'todo type. We could use seq=find on the result of org-element-map, but it turns out that it provides an optional first-match argument that can be used for our needs. Thanks Gustav for pointing that out.




******* Mise √† jour de l'agenda juste avant son appel


#+begin_src emacs-lisp

  (defun vulpea-project-files ()
    "Return a list of note files containing 'PROJET' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
                :from tags
                :left-join nodes
                :on (= tags:node-id nodes:id)
                :where (like tag (quote "%\"PROJET\"%"))]))))

  (defun vulpea-agenda-files-update (&rest _)
    (interactive)
    "Update the value of `org-agenda-files'."
    (setq org-agenda-files (vulpea-project-files)))

  ;; on skip les fichiers qui ne sont pas accessible
  (setq org-agenda-skip-unavailable-files t)

  (add-hook 'emacs-startup-hook 'vulpea-agenda-files-update);; on l'update une fois au d√©marrage
  ;; (vulpea-agenda-files-update) 


  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
  (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)

  (advice-add 'org-roam-db-sync :after #'vulpea-agenda-files-update)

#+end_src


******* (migration) Mise √† jour automatis√© des tags projets dans les notes avec le projet, √† automatiser √† un endroit. Je sais m√™me pas si j'en ai besoin, car √ßa update √† chaque sauvegarde. Et je sauvegarde tout le temps. Bon exemple apr√®s pour le lisp



#+begin_src emacs-lisp :tangle no
(dolist (file (org-roam-list-files))
  (message "processing %s" file)
  (with-current-buffer (or (find-buffer-visiting file)
                           (find-file-noselect file))
    (vulpea-project-update-tag)
    (save-buffer)))
#+end_src


****** TODO org-super-agenda


#+begin_src emacs-lisp
    (use-package org-super-agenda
      :config
      (org-super-agenda-mode))
#+end_src

****** Agenda custom command

******* Agenda custom command
#+begin_src emacs-lisp

  (setq org-agenda-custom-commands
        '(
          (" " "Agenda"
           ((tags
             "REFILE"
             ((org-agenda-overriding-header "To refile")
              (org-tags-match-list-sublevels nil)))))

          ;;√† supprimer ?
          ("d" "dashboard"
           (
            (todo "RAPPEL" ((org-agenda-overriding-header "Se souvenir de ceci")))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Actions")
                   (org-agenda-max-todos nil)))
            (todo "TODO"
                  ((org-agenda-overriding-header "Tout ce qui est dans Inbox(Unprocessed Inbox Tasks)")
                   (org-agenda-files capture-inbox-file))
                  (org-agenda-text-search-extra-files nil))
            (todo "WAIT"
                  ((org-agenda-overriding-header "Waiting items")
                   (org-agenda-max-todos nil)))
            ;;(stuck "") ;; review stuck projects as designated by org-stuck-projects
            ;; ...other commands here
            )
           )
          )
        )


  ;;(org-agenda-skip-if SUBTREE CONDITIONS)
  (setq org-agenda-custom-commands
        '(("t" "Dashboard"
           (
            (agenda)
            (todo "TODO"
                  ((org-agenda-overriding-header "Les deux  : first task et projet")
                   (org-agenda-skip-function 'cp/super-org-agenda-skip-function-first-task)
                   (org-agenda-todo-ignore-scheduled t)
                   ))
            (todo "TODO"
                  ((org-agenda-overriding-header "Tous mes projets en cours")
                   ;; (org-tags-match-list-sublevels nil) ;;skip les subtask
                   (org-agenda-skip-function 'cp/org-agenda-skip-function-for-project)
                   ))
            (todo "TODO"
                  ((org-agenda-overriding-header "Prochaines t√¢ches pas dans les projets")
                   ;; (org-tags-match-list-sublevels nil) ;;skip les subtask
                   (org-agenda-skip-function 'cp/org-agenda-skip-function-next-task-not-project)
                   ))
            (todo "TODO"
                  ((org-agenda-overriding-header "Liste de mes prochaines t√¢che √† faire pour un projet")
                   (org-agenda-skip-function 'cp/org-agenda-skip-function-first-task)
                   ))

            ))
          ("s" "Liste des projets √† faire TODO"
           (
            ;; (agenda "")
            (stuck "")
            (org-ql-block '(and (tags "project")
                                (not (done))
                                (not (ancestors))
                                ;; (not (descendants (todo "TODO"))) TODO here :‚ÄØtrouver la t√¢che suivante, et elle n'est n'y schedulded ni todo, 
                                )
                          ((org-ql-block-header "Stuck projet"))
                          )
            (todo "" ((org-super-agenda-groups
                       '((:name "Test"  ; Disable super group header
                                :children todo)
                         (:name "Priority >= C items underlined, on black background"
                                :not (:priority>= "C"))
                         (:priority<= "B"
                                      ;; Show this section after "Today" and "Important", because
                                      ;; their order is unspecified, defaulting to 0. Sections
                                      ;; are displayed lowest-number-first.
                                      :order 1)
                         (:discard (:anything t))))))

            ))

          ("A" "En fonction d'un tag"
           (
            ;; (agenda "")
            (tags-todo (cp/org-get-one-of-all-tags)
                       ((org-agenda-overriding-header "Les deux  : first task et projet")
                        (org-agenda-skip-function 'cp/super-org-agenda-skip-function-first-task)
                        ))
            ))

          ("o" "Agenda and Office-related tasks"
           ((agenda "")
            (tags-todo "work")
            (tags "home|office")
            (org-ql-block '(and (todo "TODO")
                                (tags "projet")
                                (not (ancestors))
                                )
                          ((org-ql-block-header "Liste des projets non fini")))
            (org-ql-block '(and (todo "TODO")
                                (tags "WORK")
                                )
                          ((org-ql-block-header "Liste des R√©visions, √† suppr car pas tri√© par org-ql. Faire une requ√™te org-ql √† la place ?")))


            ))))

#+end_src

******* Les fonctions pour skips
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 01:50]
- State "TODO"       from              [2022-07-23 Sat 01:03]
:END:

******** Trouve mes projets en cours

skip :‚ÄØles niveaux autres que 1, pas de todo, ceux qui n'ont pas de fils, pas de priorit√© (ou priorit√© minimal)

#+begin_src emacs-lisp

  (defun cp/org-agenda-skip-function-for-project ()
    "On skip d√®s qu'on peut avec \"cond\""
    (when
        (cp/org-agenda-skip-function-for-project-cond)
      (save-excursion (org-end-of-subtree t))
      )
    )

  (defun cp/org-agenda-skip-function-for-project-cond()
    (cond (
           ;;je ne veux voir le premier heading, car c'est mon projet
           (not (eq (org-current-level) 1)) t)      
          ;; si pas de priorit√© alors on skip, car pas besoin de les voir
          ((not (cp/org-get-priority-p (match-string 0))) t)       
          ;;si il n'a pas de fils, je le skip 
          ((not (save-excursion (org-goto-first-child))) t)              
          )
    )


#+end_src

Ancien : 
#+begin_src emacs-lisp :tangle no

  (defun cp/org-agenda-skip-function-not-level-one ()
    "Skip si n'est pas niveau 1 et si pas de fils"
    (let (should-skip-entry)
      ;;je ne veux voir le premier heading, car c'est mon projet
      (unless (eq (org-current-level) 1)
        (setq should-skip-entry t))
      ;; si priorit√© par d√©fault, alors on skip, car pas besoin de les voir
      (when (eq (org-priority-to-value (org-entry-get (point) "PRIORITY"))  cp/org-default-priority)
        (setq should-skip-entry t))
      ;;si il n'a pas de fils, je le skip 
      (unless (save-excursion (org-goto-first-child))
        (setq should-skip-entry t)
        ) 
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

#+end_src
******** Premi√®re t√¢che √† faire
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 14:25]
- State "TODO"       from              [2022-07-23 Sat 01:56]
:END:


#+begin_src emacs-lisp

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))

  (defun cp/org-agenda-skip-function-first-task ()
    "On skip d√®s qu'on peut avec \"cond\""
    (when
        (cp/org-agenda-skip-function-first-task-cond)
      ;; on va voir la prochaine entr√©e, ou bien bout du fichier si ya plus rien
      (or (outline-next-heading)
          (goto-char (point-max)))
      )
    )

  (defun cp/org-agenda-skip-function-first-task-cond()
    (cond
     ;; pas todo
     ((not (org-current-is-todo)) t)
     ;; si niveau 1 et qu'il n'a pas de fils
     ((and (eq (org-current-level) 1) (not (save-excursion (org-goto-first-child)))) t)

     ;; si pas dans un todo (anc√™tre todo)
     ((progn (save-excursion (while (ignore-errors (outline-up-heading 1 t)))(ignore-errors (not (org-current-is-todo))))) t)

     ;; si il a des fils (pas s√ªr, cela me donner "les parents") dans mes commandes, mais lorsque je scheduldais, √ßa garder les parents. (Il faudrait faire un truc sp√©cial "si pas de fils schedulded") Idem pour la priorit√© : si une t√¢che next avait une priorit√© diff√©rentes du projet... √ßa n'aller pas.
     ((save-excursion (org-goto-first-child)) t)

     ;; si pas de priorit√©
     ((not (cp/org-get-priority-p (match-string 0))) t)
     ;; si le fr√®re pr√©c√©dent existe et est en todo
     ((let (should-skip-entry)
        (save-excursion
          ;; If previous sibling exists and is TODO,
          ;; skip this entry
          (while (and (not should-skip-entry) (org-goto-sibling t) (not (eq (org-current-level) 1)))
            (when (org-current-is-todo)
              (setq should-skip-entry t))))
        should-skip-entry
        )
      t)
     ;; si un anc√™tre avec un todo existe ET que cette anc√™tre poss√®de sibling pr√©c√©dent avec un TODO, alors skip
     ((let (should-skip-entry
            (num-ancestors (org-current-level))
            (ancestor-level 1))
        (while (and (not should-skip-entry) (<= ancestor-level num-ancestors))
          (save-excursion
            ;; When ancestor (parent, grandparent, etc) exists
            (when (ignore-errors (outline-up-heading ancestor-level t))
              ;; j'ai rajouter ici que le heading doit √™tre diff√©rent de 1, comme √ßa on ne skip pas les t√¢ches qui ont un projet avec un todo... mais pourquoi ? c'est dans cette boucle while le pb
              ;;parce qu'on regarde les oncles jusqu'au niveau 1, et donc, quand ya un todo avant, on annule les suivant! Il faut donc arrerter de checker les oncle au plus haut niveau !
              (when (not (eq (org-current-level) 1))
                ;; Else if ancestor is TODO, check previous siblings of
                ;; ancestor ("uncles"); if any of them are TODO, skip
                (when (org-current-is-todo)
                  (while (and (not should-skip-entry) (org-goto-sibling t))
                    (when (org-current-is-todo)
                      (setq should-skip-entry t)))))
              ))
          (setq ancestor-level (1+ ancestor-level))
          )
        should-skip-entry)
      t)

     )

    )

#+end_src

ancien : 
#+begin_src emacs-lisp :tangle no

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))

  (defun cp/org-agenda-skip-function-first-task ()
    "On skip d√®s qu'on peut avec \"cond\""
    (when
        (cond
         ;; pas todo
         ((not (org-current-is-todo)) t)
         ;; si niveau 1
         ((eq (org-current-level) 1) t)
         ;; si pas de priorit√©
         ((not (cp/org-get-priority-p (match-string 0))) t)
         ;; si le fr√®re pr√©c√©dent existe et est en todo
         ((let (should-skip-entry)
            (save-excursion
              ;; If previous sibling exists and is TODO,
              ;; skip this entry
              (while (and (not should-skip-entry) (org-goto-sibling t))
                (when (org-current-is-todo)
                  (setq should-skip-entry t))))
            should-skip-entry
            )
          t)
         ;; si un anc√™tre avec un todo existe ET que cette anc√™tre poss√®de sibling pr√©c√©dent avec un TODO, alors skip
         ((let (should-skip-entry
                (num-ancestors (org-current-level))
                (ancestor-level 1))
            (while (and (not should-skip-entry) (<= ancestor-level num-ancestors))
              (save-excursion
                ;; When ancestor (parent, grandparent, etc) exists
                (when (ignore-errors (outline-up-heading ancestor-level t))
                  ;; j'ai rajouter ici que le heading doit √™tre diff√©rent de 1, comme √ßa on ne skip pas les t√¢ches qui ont un projet avec un todo... mais pourquoi ? c'est dans cette boucle while le pb
                  ;;parce qu'on regarde les oncles jusqu'au niveau 1, et donc, quand ya un todo avant, on annule les suivant! Il faut donc arrerter de checker les oncle au plus haut niveau !
                  (when (not (eq (org-current-level) 1))
                    ;; Else if ancestor is TODO, check previous siblings of
                    ;; ancestor ("uncles"); if any of them are TODO, skip
                    (when (org-current-is-todo)
                      (while (and (not should-skip-entry) (org-goto-sibling t))
                        (when (org-current-is-todo)
                          (setq should-skip-entry t)))))
                  ))
              (setq ancestor-level (1+ ancestor-level))
              )
            should-skip-entry)
          t)
         )
      ;; on va voir la prochaine entr√©e, ou bien bout du fichier si ya plus rien
      (or (outline-next-heading)
          (goto-char (point-max)))
      )
    )
#+end_src

******** Trouve les t√¢ches de niveau 1, priorit√© non nul, sans enfants
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 22:29]
- State "TODO"       from              [2022-07-23 Sat 22:29]
- State "TODO"       from              [2022-07-23 Sat 14:52]
:END:

#+begin_src emacs-lisp
  (defun cp/org-agenda-skip-function-next-task-not-project ()
    "On skip d√®s qu'on peut avec \"cond\""
    (when
        (cp/org-agenda-skip-function-next-task-not-project-cond)
      (save-excursion (org-end-of-subtree t))
      )
    )


  (defun cp/org-agenda-skip-function-next-task-not-project-cond()
    (cond (;;je veux voir les premiers heading seulement
           (not (eq (org-current-level) 1)) t)      
          ;; si pas de priorit√© alors on skip, car pas besoin de les voir
          ((not (cp/org-get-priority-p (match-string 0))) t)
          ;;si il a un fils, je le skip 
          ((save-excursion (org-goto-first-child)) t)              
          )
    )




#+end_src

******** Rassembler les deux yes fait !
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 22:50]
- State "TODO"       from              [2022-07-23 Sat 22:50]
- State "TODO"       from              [2022-07-23 Sat 14:47]
:END:

Ne garde que les premi√®re conditions, pourquoi ?

#+begin_src emacs-lisp 
  (defun cp/super-org-agenda-skip-function-first-task ()
    "On skip d√®s qu'on peut avec \"cond\""
    (when (and
           (cp/org-agenda-skip-function-next-task-not-project-cond)
           (cp/org-agenda-skip-function-first-task-cond)
           )
      (or (outline-next-heading)
          (goto-char (point-max)))
      )
    )
#+end_src

******* R√©cup√®re un tag parmis tous

#+begin_src emacs-lisp

  (defun cp/org-get-one-of-all-tags()
    "Renvoie un strig d'un des tags de org-agenda-files"
    (let* (
           ;;vive cette variable
           (org-complete-tags-always-offer-all-agenda-tags t)

           (all-tags (org-get-tags))
           (table (setq org-last-tags-completion-table
                        (org--tag-add-to-alist
                         (and org-complete-tags-always-offer-all-agenda-tags
                              (org-global-tags-completion-table
                               (org-agenda-files)))
                         (or org-current-tag-alist (org-get-buffer-tags)))))
           (current-tags
            (cl-remove-if (lambda (tag) (get-text-property 0 'inherited tag))
                          all-tags))
           (inherited-tags
            (cl-remove-if-not (lambda (tag) (get-text-property 0 'inherited tag))
                              all-tags))
           (tags
            (replace-regexp-in-string
             ;; Ignore all forbidden characters in tags.
             "[^[:alnum:]_@#%]+" ":"
             (if (or (eq t org-use-fast-tag-selection)
                     (and org-use-fast-tag-selection
                          (delq nil (mapcar #'cdr table))))
                 (org-fast-tag-selection
                  current-tags
                  inherited-tags
                  table
                  (and org-fast-tag-selection-include-todo org-todo-key-alist))
               (let ((org-add-colon-after-tag-completion (< 1 (length table)))
                     (crm-separator "[ \t]*:[ \t]*"))
                 (mapconcat #'identity
                            (completing-read-multiple
                             "Tags: "
                             org-last-tags-completion-table
                             nil nil (org-make-tag-string current-tags)
                             'org-tags-history)
                            ":"))))))
      tags))


#+end_src

******* TODO Permet de monter le titre en haut de sa section
:LOGBOOK:
- State "TODO"       from              [2022-07-23 Sat 00:32]
:END:

#+begin_src emacs-lisp

(defun bjm/org-headline-to-top ()
  "Move the current org headline to the top of its section"
  (interactive)
  ;; check if we are at the top level
  (let ((lvl (org-current-level)))
    (cond
     ;; above all headlines so nothing to do
     ((not lvl)
      (message "No headline to move"))
     ((= lvl 1)
      ;; if at top level move current tree to go above first headline
      (org-cut-subtree)
      (beginning-of-buffer)
      ;; test if point is now at the first headline and if not then
      ;; move to the first headline
      (unless (looking-at-p "*")
        (org-next-visible-heading 1))
      (org-paste-subtree))
     ((> lvl 1)
      ;; if not at top level then get position of headline level above
      ;; current section and refile to that position. Inspired by
      ;; https://gist.github.com/alphapapa/2cd1f1fc6accff01fec06946844ef5a5
      (let* ((org-reverse-note-order t)
             (pos (save-excursion
                    (outline-up-heading 1)
                    (point)))
             (filename (buffer-file-name))
             (rfloc (list nil filename nil pos)))
        (org-refile nil nil rfloc))))))
#+end_src

****** Faire des requ√™te avec des commandes

[[https://github.com/alphapapa/org-ql/blob/master/examples.org#stuck-projects-block-agenda][voir des exemples ici]]

#+begin_src emacs-lisp
  (use-package org-ql
    :config

    )
#+end_src


https://github.com/alphapapa/org-ql/pull/237
#+begin_src emacs-lisp :tangle no

  (setq org-ql-regexp-part-ts-time
        (rx " " (repeat 1 2 digit) ":" (repeat 2 digit)
            (optional "-" (repeat 1 2 digit) ":" (repeat 2 digit))))

  (org-ql-select '("/home/utilisateur/braindump/org/pages/20220718223109-test_de_todo_org_ql.org")
    '(and
      (not (done))
      (ts-active :to today)
      )
    )

#+end_src


Tests :

#+begin_src emacs-lisp :tangle no

  (defun my-org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-todo)
        (setq should-skip-entry t))
      ;;je ne veux pas voir le premier heading, car c'est ma liste de t√¢che √† faire pour un noeud X, qui repr√©sente la cat√©gorie
      ;; (when (eq (org-current-level) 1)
      ;; (setq should-skip-entry t))

      (save-excursion
        ;; If previous sibling exists and is TODO,
        ;; skip this entry
        (while (and (not should-skip-entry) (org-goto-sibling t))

          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (let ((num-ancestors (org-current-level))
            (ancestor-level 1))
        (while (and (not should-skip-entry) (<= ancestor-level num-ancestors))
          (save-excursion
            ;; When ancestor (parent, grandparent, etc) exists
            (when (ignore-errors (outline-up-heading ancestor-level t))
              ;; If ancestor is WAITING, skip entry
              (if (string= "WAITING" (org-get-todo-state))
                  (setq should-skip-entry t)
                ;; Else if ancestor is TODO, check previous siblings of
                ;; ancestor ("uncles"); if any of them are TODO, skip
                (when (org-current-is-todo)
                  (while (and (not should-skip-entry) (org-goto-sibling t))
                    (when (org-current-is-todo)
                      (setq should-skip-entry t)))))))
          (setq ancestor-level (1+ ancestor-level))
          ))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

#+end_src

******* DONE trouver mes projet
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 01:46]
- State "TODO"       from              [2022-07-23 Sat 01:46]
:END:

J'utilise org-mode

#+begin_src emacs-lisp :tangle no

  (defun cp/mes-projets ()
    (interactive)
    (org-ql-search (org-agenda-files)
      '(and (not (done))
            (not (ancestors))
            (children)
            )
      :sort '(priority)
      :super-groups '(
                      (:name "Mes projets en cours"
                             :priority>= "C" :order 1)
                      ))
    )

#+end_src

****** TODO Stuck projet

√Ä rajouter avec org agenda custo command ?
Se baser sur org-ql

Ce sont les projets qui n'ont 1 ni priorit√© 2 ni deadline

#+begin_src emacs-lisp
(add-to-list 'org-agenda-custom-commands
      '("b" "Stuck Projects"
         ((org-ql-block '(and (tags "@project")
                              (not (done))
                              (not (descendants (todo "NEXT")))
                              (not (descendants (scheduled))))
                        ((org-ql-block-header "Stuck Projects"))))))
#+end_src

[[https://orgmode.org/manual/Stuck-projects.html][ici]] pour le mode d'emploi version org-mode
ne sert √† rien, √† part les afficher √† un moment, remplacable par org-ql je pense

#+begin_src emacs-lisp
  ;; (setq org-stuck-projects
        ;; '("+PROJECT/-MAYBE-DONE" ("NEXT" "TODO") ("@shop")
          ;; "\\<IGNORE\\>"))
#+end_src


****** Fonctions pour faire des choses global sur l'agenda apr√®s avoir marqu√© (m) faire B

#+begin_src emacs-lisp

  (setq org-agenda-bulk-custom-functions '(
                                           (?D (lambda nil (org-agenda-priority 65)))
                                           (?L (lambda nil (org-agenda-priority 66)))
                                           (?\? (lambda nil (org-agenda-priority 67)))
                                           (?Q (lambda nil (org-agenda-priority 68)))
                                           ))

  
#+end_src


****** Refresh l'agenda apr√®s voir un item en done

#+begin_src emacs-lisp
(advice-add 'org-agenda-todo :after #'org-agenda-redo-all)
#+end_src

****** TODO Save les buffers org-mode apr√®s le refresh de l'agenda. √Ä faire un jour peut-√™tre
:LOGBOOK:
- State "TODO"       from              [2022-10-08 Sat 18:06]
:END:

#+begin_src emacs-lisp :tangle no
    (advice-add 'org-agenda-redo-all :after #'org-save-all-org-buffers)
    (advice-remove 'org-agenda-redo-all #'org-save-all-org-buffers)
    (add-hook 'org-agenda-mode-hook
              (lambda ()
                (add-hook 'auto-save-hook 'org-save-all-org-buffers nil t)))

  (add-hook 'auto-save-hook 'org-save-all-org-buffers)

  ;; xah-save-all-unsaved ?

#+end_src

***** Gestion de l'agenda (t√©l√©phone)

****** TODO Avoir les notifications
:LOGBOOK:
- State "TODO"       from              [2022-10-16 Sun 21:35]
:END:

Voir les commentaires !

#+begin_src emacs-lisp
    (use-package org-yaap
    :straight (org-yaap :type git :host gitlab :repo "tygrdev/org-yaap")
    :config

    (setq
     org-yaap-overdue-alerts '(5 30 180 1440)
     org-yaap-alert-before '(30 0) ;; pr√©venir 30mins avant et √† 0 (voir issue github)
     org-yaap-todo-only t ;; pour pas avoir les non todo (les rendez-vous simple par exemple).
     ;; org-yaap-include-tags '(test)
     )

    (org-yaap-mode 1))
#+end_src

pour tester : 
(org-yaap--check-heading (org-element-at-point)) (org-yaap--get-alerts (org-element-at-point))

**** Gestion des t√¢ches

***** Les keywords

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(!)" "|" "DONE(!)" )))
#+end_src


***** Tracer les √©tats / states des todo dans des tiroirs 

Il faut rajouter "!" dans les org-todo-keywords.

#+begin_src emacs-lisp

  ;; (setq org-log-done 'time) ;; rajoute "CLOSED:" quand on termine une t√¢che. Pas besoin gr√¢ce √† la variables org-log-into-drawer
  (setq org-log-into-drawer t);; le mets dans un propreties

#+end_src


***** Gestion des projets
****** Emp√™che les parent d'√™tre coch√© si les fils ne le sont pas

#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src

****** TODO Permet de rajouter les statistics cookies automatiquement
:LOGBOOK:
- State "TODO"       from              [2022-07-23 Sat 16:07]
:END:

******* Ajouter

#+begin_src emacs-lisp :tangle no

  (defun cp/org-goto-end-of-heading ()
    "Move cursor √† la fin du titre, en ne prenant pas en compte les tags et les cookies"
    (interactive)
    (save-restriction
      (org-narrow-to-subtree)
      (goto-char (point-min))
      (setq heading-with-cookies (org-get-heading t t t t))
      (setq heading-without-cookies (substring heading-with-cookies 0 (string-match "\\(\\(\\[[0-9]*%\\]\\)\\|\\(\\[[0-9]*/[0-9]*\\]\\)\\)" heading-with-cookies)))
      (re-search-forward (string-trim heading-without-cookies) nil t)
      )
    )  


  (defun cp/org-insert-statistics-cookies()
    "TODO"
    (interactive)
    (let
        ((cookie-re "\\(\\(\\[[0-9]*%\\]\\)\\|\\(\\[[0-9]*/[0-9]*\\]\\)\\)"))
      (save-excursion
        (when (> (org-outline-level) 1)
          (outline-up-heading 1)
          (when (org-entry-is-todo-p)
            (save-restriction
              (org-narrow-to-subtree)
              (unless (re-search-forward cookie-re nil t)
                ;; on s'avance jusqu'√† la fin de la ligne, 
                (cp/org-goto-end-of-heading)
                ;; cas sans le tag et apr√®s le tag
                (insert " [/]")
                (org-update-statistics-cookies nil)
                )))))))


  (add-hook 'org-insert-heading-hook #'cp/org-insert-statistics-cookies)
  ;; (add-hook 'org-after-todo-state-change-hook 'cp/org-insert-statistics-cookies)

#+end_src

ancien : 
(defun cp/org-goto-end-of-heading ()
    "Move cursor √† la fin du titre, en ne prenant pas en compte les tags et les cookies"
    (interactive)
    (save-restriction
      (org-narrow-to-subtree)
      (goto-char (point-min))
      ;; on s'avance jusqu'√† la fin de la ligne, 
      (if (re-search-forward org-tag-line-re nil t)
          (progn
            (while (search-backward ":" nil t))
            )
        (end-of-line))
      (skip-chars-backward " ")
      (when (re-search-backward "\\(\\(\\[[0-9]*%\\]\\)\\|\\(\\[[0-9]*/[0-9]*\\]\\)\\)" nil t)
        (skip-chars-backward " ")  
        )
      ;; cas sans le tag et apr√®s le tag
      )
    )

******* TODO Supprimer
:LOGBOOK:
- State "TODO"       from              [2022-07-23 Sat 13:58]
:END:

#+begin_src emacs-lisp :tangle no
  (defun org-delete-statistics-cookies()
    "Peut pas marcher, car pas de hook"
    (interactive)
    (let
        (
         (cookie-re "\\(\\(\\[[0-9]*%\\]\\)\\|\\(\\[[0-9]*/[0-9]*\\]\\)\\)")
         )
      (save-excursion
        (unless (org-goto-first-child)
          (outline-up-heading 0)
          (save-restriction
            (org-narrow-to-subtree)
            (unless (re-search-forward cookie-re nil t)
              (end-of-line)
              (insert "[/]")
              (org-update-statistics-cookies nil)
              ))))
      )

    )
  ;; (add-hook 'org-insert-heading-hook #'org-delete-statistics-cookies)

#+end_src

****** Rajoute le tag projet automatiquement

#+begin_src emacs-lisp :tangle no
  
  (defun cp/org-toggle-tag-projet()
    (org-toggle-tag "projet" 'on)
    )

  (defun cp/org-toggle-tag-projet-level-one()
    (save-excursion
      (when (> (org-outline-level) 1)
        (while (ignore-errors (outline-up-heading 1 t)))
        (when (org-entry-is-todo-p)
          (cp/org-toggle-tag-projet)
          ))))

    (add-hook 'org-insert-heading-hook #'cp/org-toggle-tag-projet-level-one)

#+end_src

***** Gestions des habitues

#+begin_src emacs-lisp
(require 'org-habit)
#+end_src

**** Gestion des tags (sauf tag PROJET, PERSONNE et LIEU), voir l'agenda
***** Les diff√©rents tags

#+begin_src emacs-lisp

(setq org-tag-alist '((:startgrouptag)
                      ("GTD")
                      (:grouptags)
                      ("Control")
                      ("Persp")
                      (:endgrouptag)
                      (:startgrouptag)
                      ("Control")
                      (:grouptags)
                      ("Context")
                      ("Task")
                      (:endgrouptag)))
  
#+end_src

#+begin_src emacs-lisp :tangle no

  ;; faire une hi√©rarchie. un tag peut apartenir √† plusieurs hi√©rarchie. il faut donc qu'il soit unique pour mes cours (S4SVT par exemple)
  (setq org-tag-alist '(:startgrouptag
                        ("GTD")
                        :grouptags
                        ("Control")
                        ("Persp")
                        :endgrouptag
                        :startgrouptag
                        ("Control")
                        :grouptags
                        ("Context")
                        ("Task")
                        :endgrouptag
                        ))

  (setq org-tag-alist '((Test) (GTD) 
                        ))

#+end_src

***** Tag qui sont pas √† 2 km, mais juste apr√®s le titre

#+begin_src emacs-lisp
  (setq org-tags-column 0)
#+end_src

***** Nouvelle fonction pour ajout de tag

Fait appel √† la fonction pour ajouter un tag √† la personne 

#+begin_src emacs-lisp
  (defun vulpea-tags-add ()
    "Add a tag to current note."
    (interactive)
    ;; since https://github.com/org-roam/org-roam/pull/1515
    ;; `org-roam-tag-add' returns added tag, we could avoid reading tags
    ;; in `vulpea-ensure-filetag', but this way it can be used in
    ;; different contexts while having simple implementation.
    (when (call-interactively #'org-roam-tag-add)
      (vulpea-ensure-filetag)))

#+end_src
***** Fonction permettant d'enlever le tag BROUILLON

#+begin_src emacs-lisp

  (defun cp-vulpea-buffer-tags-remove-BROUILLON ()
    "Use all files for org-agenda."
    (interactive)
    (vulpea-buffer-tags-remove "BROUILLON"))
  
#+end_src
***** Permet de rechercher avec une hi√©rarchie !

  (cp/vulpea-select-from-tags-with-children '("Persp"))

#+begin_src emacs-lisp

  (defun cp/org-get-tags-with-children(tags)
    "Take a list of tag, and return this list of tag WITH the sub-tags (define in org-tag-alist) of each tag in entry"
    (interactive)
    (let (tags-result)
      (dolist (tag tags)
        (dolist (tag-to-add (org-tags-expand tag t))
          (push tag-to-add tags-result)))
      (delete-dups tags-result)
      )
    )

  (defun cp/vulpea-select-from-tags-with-children (tags)
    "Takes a list of tags, and allows the user to choose a note that has one of these tags OR has a child tag from the list given in parameter"
    (let ((links (vulpea-db-query-by-tags-some (cp/org-get-tags-with-children tags))))
      (unless links
        (user-error "There are note with the current tag (or children)"))
      (vulpea-find
       :candidates-fn (lambda (_) links)
       :require-match t))
    )


#+end_src

***** Tag √©v√®nement

****** D√©finition du tag
#+begin_src emacs-lisp

  (setq cp/tag-for-event "√©v√®nement")

#+end_src

****** Trouver la derni√®re note avec le tag √©v√®nement cr√©er yeah

Se base sur les ids pour la date ctime

#+begin_src emacs-lisp

  (defun cp/find-last-note-with-tag-event ()
    "DOCSTRING"
    (interactive)
    (find-file
     (caar
      (org-roam-db-query
       [:select [nodes:file]
                :from tags
                :left-join nodes
                :on (= tags:node-id nodes:id)
                :where (like tag  $r1)
                :order-by [(desc node-id)]
                :limit 1
                ]
       (concat "%\""(format "%s" cp/tag-for-event) "\"%")))))

#+end_src


**** TODO Fonctions g√©rant l'insertions des m√©tadatas automatiquement avec les tags 
:LOGBOOK:
- State "TODO"       from              [2022-08-05 Fri 23:03]
:END:
***** Les fonctions
****** Fonction permettant d'avoir la liste des m√©tadata d'une note

#+begin_src emacs-lisp

  (defun cp/vulpea-note-meta-get-list-of-name (note)
    "Get a list of all metadata from NOTE"
    (mapcar 'car (vulpea-note-meta note)))

#+end_src
****** Fonction pour parser liste de liste ne hash

#+begin_src emacs-lisp 

  (defun cp/xah-list-to-hash (list)
    "Return a list that represent the HASHTABLE
              Each element is a proper list: '(key value).
              URL `http://xahlee.info/emacs/emacs/elisp_hash_table.html'
              Version 2019-06-11 2022-05-28"
    (let ((myHash (make-hash-table :test 'equal)))
      (mapcar
       (lambda (x)
         (let ((k (car x))
               (v (car(last x)))
               )
           (message "v =%s" v)
           (puthash k v myHash)
           )
         )
       list)
      myHash))

  ;; (setq var '(
  ;; ("salut" ("val" "vul"))
  ;; ("key" ("val" "vul"))
  ;; ))
  ;; (setq test (cp/xah-list-to-hash var))
  ;; (gethash "salut" test)


#+end_src
****** Permet d'avoir les tags d'une note

#+begin_src emacs-lisp
(defun cp/vulpea-buffer-tags-get (note)
    "Return filetags value for a note."
    (save-window-excursion
      (find-file (vulpea-db-get-file-by-id (vulpea-note-id note)))
      (vulpea-buffer-prop-get-list "filetags" "[ :]")))
#+end_src

***** Variable d√©finissant ma h√©rirachie

#+begin_src emacs-lisp

  ;; tags √† ignorer
  (setq ignore-meta '("Origine" "Lieu" "Fait" "" cp/vulpea-date))

  ;; mes tags avec leurs propri√©t√©s
  (setq tags-for-meta-list '(
                             ("RECETTE" ("temps" "autre"))
                             ("INSTALLATION" ("val" "vul" "vol"))
                             ("Blog" ("Publish Date" "Pulbished Where" "Published Link"))
                             ("nateun" ("val"))
                             ))
  (setq tags-for-meta (cp/xah-list-to-hash tags-for-meta-list))

  ;; (gethash "salut" tags-for-meta)

  (defun all-meta-list()
    "Renvoie la liste de toutes mes m√©tadata pr√©sente dans ma hi√©rarchie"
    (delq nil (delete-dups (let (result)
                             (dolist (value (hash-table-values tags-for-meta))
                               (setq result (append result value)))
                             result))))



#+end_src

***** Base (√† renommer)
#+begin_src emacs-lisp :tangle no

  ;; une fonction qui update. appele
  ;; une fonction qui r√©cup√®re les tags
  ;; une fonction qui traduit les tags en m√©tadata et qui les ajoute si besoin
  ;; pour mettre √† jour mes tags, pour la fonction du mec de vulpea

  (defun cp/vulpea-buffer-update-meta ()
    (interactive)
    (when-let ((note (vulpea-db-get-by-id (save-excursion
                                            (goto-char (point-min))
                                            (org-id-get)))))
      (cp/vulpea-buffer-update-meta-add note)
      (cp/vulpea-buffer-update-meta-remove note))
    )

  (defun cp/vulpea-buffer-update-meta-add(note)
    "Update la note en fonction de ses tags gr√¢ce √† une variable globa"
    (let ((tags (cp/vulpea-buffer-tags-get note)))
      (dolist (tag tags)
        (when-let ((list-of-meta (gethash tag tags-for-meta)))
          (dolist (meta list-of-meta)
            (unless (vulpea-meta-get note meta))
            (when-let ((prop meta)
                       (value-type (completing-read
                                    (format "Valeur pour la m√©tadata \"%s\" dans la note \"%s\" : " meta (vulpea-note-title note))
                                    '(string number link note)
                                    nil 'require-match))
                       (value (vulpea-meta--read-value value-type)))
              (vulpea-meta-set note prop value 'append)))))
      ;; cas de zotero ici ?

      ))

  (defun cp/vulpea-buffer-update-meta-remove(note)
    "Idem que l'autre, mais les supprime si elles font pas parti de la liste"
    (when-let ((metas (cp/vulpea-note-meta-get-list-of-name note))
               (tags (cp/vulpea-buffer-tags-get note))
               (all-meta (all-meta-list))
               )
      (dolist (meta metas)
        (let ((delete nil))
          (when (not (member meta ignore-meta)) ;; ici, mettre si appartient pas √† zotero
            (unless (member meta all-meta) 
              (setq delete t))) 
          (when delete
            (message "La m√©tadata \"%s\" dans la note \"%s\" a √©t√© supprim√© "meta (vulpea-note-title note))
            (vulpea-meta-remove note meta))))))



  ;; pour mettre √† jour lors ce que je modifie ma liste de tags ! √† appeler pour faire une "mise √† jour" lors du changement de la variable d√©finissant ma hi√©rarchie
  (defun cp/vulpea-update-all-metadata-tag
      (interactive)
    (dolist (file (org-roam-list-files))
      (message "processing %s" file)
      (with-current-buffer (or (find-buffer-visiting file)
                               (find-file-noselect file))
        (cp/vulpea-buffer-update-meta)
        )))

  (add-hook 'before-save-hook #'cp/vulpea-buffer-update-meta)

#+end_src


**** Gestion des polys√®mes

***** Fonction permettant de faire la pages de polys√©mes :‚ÄØ

gestion des homonymes : une page homonyme g√©n√©r√© automatiquement. Fonction : scan les notes et d√®s que trouve "logique (blabla)" et "logique (blublu)", soit cr√©er la page logique homonyme et ins√®re une liste de liens dedans, soit la page est d√©j√† cr√©er et met √† jour la liste. Fonction diff√©rentes pour mettre √† jour (rajoute √† la fin quoi)



Principe de base :
=simplifier les choses en stockant directements les notes au lieu des id ?=
Deux dico : un dico A et un dico B
Dico A regroupe toutes mes notes, structure :‚ÄØ
titleDeLaNoteSansLesParenth√®ses :‚ÄØlisteDesIdPoss√©dantsCeTitre
Dico B regroupe seulements mes notes avec polys√®mes (je garde seulements les notes du dico A qui ont listeDesIdPoss√©dantsCeTitre de taille sup√©rieur ou √©gale √† 2). structure :
titleDeLaNoteSansLesParenth√®sesSup√©rieur√Ä2 :‚ÄØlisteDesIdPoss√©dantsCeTitre

Test de performances OK :

#+begin_src emacs-lisp :tangle no
  (setq x 0)
  (while (< x 100000)
    ;; (print (format "number is %d" x))
    (setq x (1+ x)))
  
  (defun silly-loop (n)
    "Return the time, in seconds, to run N iterations of a loop."
    (let ((t1 (float-time)))
      (while (> (setq n (1- n)) 0))
      (- (float-time) t1)))


  (silly-loop 10000000)
#+end_src


1. cr√©ation du dico A en partant de rien comparer chaque title de note √† toutes les autres sans les parenth√®ses
   #+begin_src emacs-lisp :tangle no

        (defun title-without-parens-and-space (name)
          (string-trim (substring name 0
                                  (if (string-match "\\(\(\\)" name)
                                      (string-match "\\(\(\\)" name) 
                                    (length name)))))

        (defun cp-hash-for-polyseme ()
          "Renvoie un dico, avec cl√© les titre des notes en double moins les parenth√®se, en en valeur une liste d'id qui sont les notes en doubles"
          (let ((nodes (org-roam-db-query [:select [title id] :from notes]))
                (hash (make-hash-table :test 'equal)))
            (dolist (node nodes)
              (let* (
                     (nameComplete (car node))
                     ;; on r√©cup√®re le nom sans les parenth√®ses !
                     (name (title-without-parens-and-space nameComplete))
                     (id (last node))
                     )
                (if (gethash name hash)
                    (puthash name  (push id (gethash name hash)) hash) ;; si √ßa existe, il faut ajouter √† la liste l'id
                  (puthash name (list id) hash) ;; si √ßa n'existe pas, il faut ajouter le hash avec une liste du un √©l√©ment avec l'id
                  )))
            ;; on return le hash
            hash
            )
          )

        ;; (xah-print-hash (cp-hash-for-polyseme))

      #+end_src

2. Je cr√©er le dico raccourci B

   #+begin_src emacs-lisp :tangle no
     
     (defun cp-dico-B (hash)
       "on scan le dico, et si la liste fait deux ou plus, on cr√©er la page"
       (maphash
        (lambda (k v)
          (when (< (length v) 2)
            (remhash k hash)))
        hash)
       hash ;; on renvoie hash
       )

   #+end_src

3. Faut que je stocke les dicos √† un endroit. En effet, je ne veux pas √† avoir √† les refaire √† chaque lancement d'emacs. Les stock avec le kill d'emacs je pense
   Deux solutions possibles (prendre la premi√®re et modifier le nom des fonctions):

      #+begin_src emacs-lisp :tangle no


     (defun dap--read-from-file (file)
       "Read a lisp expression from FILE."
       (with-temp-buffer
         (insert-file-contents file)
         (cl-first (read-from-string
                    (buffer-substring-no-properties (point-min) (point-max))))))

     (defun dap--persist (file to-persist)
       "Serialize TO-PERSIST to FILE."
       (with-demoted-errors
           "Failed to persist file: %S"
         (make-directory (file-name-directory file) t)
         (with-temp-file file
           (erase-buffer)
           (insert (prin1-to-string to-persist)))))

     (dap--persist "/home/utilisateur/Testdedossier/test.txt" "salu")
     (setq test (dap--read-from-file "/home/utilisateur/Testdedossier/test.txt"))


   #+end_src


  ou alors :

   #+begin_src emacs-lisp :tangle no

     (unless (file-directory-p (expand-file-name "braindump/" no-littering-var-directory))
       (mkdir (expand-file-name "braindump/" no-littering-var-directory))
       )
     (setq braindump-configuration-directory (expand-file-name "braindump/" no-littering-var-directory))

     (unless (file-exists-p (expand-file-name "hash-for-polyseme.el" braindump-configuration-directory))
       (with-temp-file (expand-file-name "hash-for-polyseme.el" braindump-configuration-directory)
         (insert ""))
       )
     (setq braindump-configuration-directory-hash (expand-file-name "hash-for-polyseme.el" braindump-configuration-directory))



     (defun print-to-file (filename data)
       (with-temp-file filename
         (prin1 data (current-buffer))))

     (defun read-from-file (filename)
       (with-temp-buffer
         (insert-file-contents filename)
         (cl-assert (eq (point) (point-min)))
         (read (current-buffer))))

     (setq malist '(1 2 4))

     ;; Usage:


     (setq monHash (read-from-file braindump-configuration-directory-hash))
           (if
               (cp-hash-for-polyseme)

               )

           )

     (print-to-file braindump-configuration-directory-hash monHash)
     ;; (1 2 "foo" (quote bar))
     (read-from-file braindump-configuration-directory-hash)
     ;; (1 2 "foo" (quote bar))

     ;;pour quand les stocker
     ;; (add-hook 'kill-emacs-hook #'org-icalendar-combine-agenda-files-foreground)

  #+end_src


  
4. TODO Fonction de mise √† jour de mon dico A. Elle consiste √† :‚ÄØ
   Prendre mon dico A, et appliquer la condition de la fonction de cr√©ation du dico
5. Recr√©ation du dico B, si la variable B est modifi√©, alors je dois recr√©er mes pages
   #+begin_src emacs-lisp :tangle no

     ;;ceci marche d√©s que je touche √† la variable, pas seulement si je la modifie.
     ;; (defun my-watch (symbol newval op where)
     ;; (message "SYM: %S, VAL: %S, OP: %S, WHERE: %S" symbol newval op where))
     ;; (add-variable-watcher 'teste #'my-watch)

     ;;ceci fonctionne :

     (setq dico-B-ancien dico-B)
    (setq dico-B new-dico-from-maj)
     ;;puis on compare si dico dico-B = dico-B-ancien en les transformant en liste et avec la condition d'apr√®s


     (setq myHash
           #s(hash-table
              size 30
              test equal
              data (
                    "joe" 3
                    "jane" 9
                    "liz" 5 )))

     (setq myHash2
           #s(hash-table
              size 30
              test equal
              data (
                    "joe" 3
                    "jane" 9
                    "liz" 5 )))


     (defun xah-hash-to-list (hash-table)
       "Return a list that represent the HASH-TABLE
          Each element is a list: (list key value).
          See also, emacs 24.4's new functions.
           (require 'subr-x)
           `hash-table-keys'
           `hash-table-values'
          http://ergoemacs.org/emacs/elisp_hash_table.html
          Version 2015-04-25"
       (let (result)
         (maphash
          (lambda (k v)
            (push (list k v) result))
          hash-table)
         result))

     (if (equal (xah-hash-to-list myHash) (xah-hash-to-list myHash2))
         (message "vrai")
       (message "faux")
       )





   #+end_src

6. pour recr√©er ou cr√©er une page de polys√®me :
   Pour cr√©er la note :‚ÄØ
   #+begin_src emacs-lisp :tangle no
     (vulpea-create
      "Rich note"
      "pages/%<%Y%m%d%H%M%S>-${slug}.org"
      :properties '(("COUNTER" . "1")
                    ("STATUS" . "ignore")
                    ("ROAM_ALIASES" . "\"Very rich note with an alias\""))
      :tags '("documentation" "showcase")
      :head "#+author: unknown\n#+date: today"
      :body "It was a very %?nice day.\n\nBut I didn't feel that."
      ;; :immediate-finish t
      )
   #+end_src
   1. voir si la page existe, cr√©er si elle existe pas (dans le dossier polys√®me)
   2. Si elle existe pas, mettre un truc de ce style :‚ÄØ
      #+begin_example
   PROPRI√âT√â
   Title : Mercure
   (Description du terme)
   blabla
   Mercure vient du latin blabla.



   * "Le concept X peut poss√©der ces diff√©rentes significations selon le contexte :‚ÄØ"
   Ce qu'i' y a au dessus de cette ligne sera modifi√© par moi
    Ce qui y a en dessous de cette ligen sera g√©n√©r√© automatiquement

      #+end_example
   3. mettre en heading quelque chose comme :
      "Le concept X peut poss√©der ces diff√©rentes significations selon le contexte :‚ÄØ"
      Puis, clean la suite de ce titre
   4. revenir sur le titre
   5. ins√©rer en dessous du heading, pour chaque valeur de la liste, un lien vers les pages :

      #+begin_example
      * "Le concept X peut poss√©der ces diff√©rentes significations selon le contexte :‚ÄØ"
   - liste
   - de
   - l√† o√π la cha√Æne de caract√®re "mercure" est pr√©sente
   - d'abord ceux en premier
   - Mercure (dieu)
   - Mercure (plan√®te)
      #+end_example

7. ins√©rer dans les notes reli√© la m√©tadada "polys√®me :: page vers Mercure"
   Je prends mon dico B, et pour chaque note cl√©, j'ajoute √† la note avec id une m√©tadata

   #+begin_src emacs-lisp :tangle no
     ;; un truc de ce style :
     ;; transformer le dico en liste je pense, cera plus simple
     (dolist (node nodes)
       (vulpea-meta-set (last notes) "Polys√®me"
                        ;;ins√©rer le lien vers la page
                        )
       )


   #+end_src
8. maj :‚ÄØ
   1. comparer la nouvelle notes √† toutes les autres
   2. cas nouveau polys√®me
   3. cas ancien polys√®me
9. 





***** Fonction permettant de supprimer les parenth√®ses lors de l'insertion de polys√®mes 

Pratique pour pas lire √† chaque fois "Mercure (dieu)" alors que je sais tr√®s bien qu'avec le contexte c'est le dieu.

#+begin_src emacs-lisp

  (defun delete-parens-note-after-insertion(_)
    "Permet de supprimer les parenth√®se. Attention, ne marche qu'apr√®s l'insertion !"
    (interactive)
    (save-excursion
      (let
          (($p2 (point))
           ($p1 (search-backward "[")))
        (save-restriction
          (narrow-to-region $p1 $p2)
          (when (search-forward "(" nil t) ;;cas o√π je trouve la parenth√®se
            (unless (boundp 'delete-parens-for-node) ;; si pas de variable local activ√©
              (defvar-local delete-parens-for-node nil)
              )
            (when (and (not delete-parens-for-node) (y-or-n-p "Insertion d'une note avec des parenth√®ses, voulez vous les supprimer ? Si oui, vous n'aurez plus cette demande dans le buffer actuel la prochaine fois"))
              (setq-local delete-parens-for-node t)
              )
            (when delete-parens-for-node
              (xah-delete-backward-char-or-bracket-text)
              (xah-fly-delete-spaces)
              )))))
    )

  ;;on le "hook"
  ;; (advice-add 'vulpea-insert :after #'delete-parens-note-after-insertion)
  ;; (advice-remove 'vulpea-insert  #'delete-parens-note-after-insertion)

  (add-hook 'vulpea-insert-handle-functions #'delete-parens-note-after-insertion)
  ;; (remove-hook 'vulpea-insert-handle-functions #'delete-parens-note-after-insertion)

#+end_src



**** Gestion des personnes et des lieux

***** Personne et lieu

Cela permet de faire des projets √©galement pour des personnes (Nell hehe)
Si je connais la personne, alors je la tag avec people. Si j'ai des choses en rapport √† faire avec elle, alors je lui mets un tag "@NomDeLaPersonne"

Je peux chercher les tag dans l'agenda

Chaque personne √† son fichier org roam.

Pour appeler une fonction qui ajoute les tags, et si jamais le tag people est mis, alors ajoute automatiquement le tag de la personne au fichier !!! ‚ÄØPratique


M√™me raisonnement pour les lieux

****** Cr√©er automatiquement le tag "NomPersonne" si la personne √† le tag people

Appeler dans vulpea-tags-add

#+begin_src emacs-lisp
  (defun vulpea-ensure-filetag ()
    "Add respective file tag if it's missing in the current note."
    (let ((tags (vulpea-buffer-tags-get))
          (tag (vulpea--title-as-tag)))
      (when (and (seq-contains-p tags "PERSONNE")
                 (not (seq-contains-p tags tag)))
        (vulpea-buffer-tags-add tag))

      (when (and (seq-contains-p tags "LIEU")
                 (not (seq-contains-p tags tag)))
        (vulpea-buffer-tags-add tag))
      ))

  (defun vulpea--title-as-tag ()
    "Return title of the current note as tag."
    (vulpea--title-to-tag (vulpea-buffer-title-get)))

  (defun vulpea--title-to-tag (title)
    "Convert TITLE to tag."
    (concat "@" (s-replace " " "" title)))

#+end_src

****** Automatisation insertion tag de la personne qd on la cite ailleurs ! 

Qd on ins√®re avec la fonction vulpea-insert une personne ailleurs dans un todo, ins√®re le tag automatiquement
#+begin_src emacs-lisp

  (defun my-vulpea-insert-handle (note)
    "Hook to be called on NOTE after `vulpea-insert'."
    (when-let* ((title (vulpea-note-title note))
                (tags (vulpea-note-tags note)))
      (when (seq-contains-p tags "PERSONNE")
        (save-excursion
          (ignore-errors
            (org-back-to-heading)
            (when (eq 'todo (org-element-property
                             :todo-type
                             (org-element-at-point)))
              (org-set-tags
               (seq-uniq
                (cons
                 (vulpea--title-to-tag title)
                 (org-get-tags nil t))))))))


      (when (seq-contains-p tags "LIEU")
        (save-excursion
          (ignore-errors
            (org-back-to-heading)
            (when (eq 'todo (org-element-property
                             :todo-type
                             (org-element-at-point)))
              (org-set-tags
               (seq-uniq
                (cons
                 (vulpea--title-to-tag title)
                 (org-get-tags nil t))))))))


      ))

  (defun vulpea--title-to-tag (title)
    "Convert TITLE to tag."
    (concat "@" (s-replace " " "" title)))

  (add-hook 'vulpea-insert-handle-functions
            #'my-vulpea-insert-handle)

#+end_src

****** Fonction qui demande TOUTES les t√¢ches associ√© √† une personne

#+begin_src emacs-lisp
  (defun vulpea-agenda-personne ()
    "Show main `org-agenda' view."
    (interactive)
    (let* ((person (vulpea-select
                    "Person"
                    :filter-fn
                    (lambda (note)
                      (seq-contains-p (vulpea-note-tags note)
                                      "PERSONNE"))))
           (node (org-roam-node-from-id (vulpea-note-id person)))
           (names (cons (org-roam-node-title node)
                        (org-roam-node-aliases node)))
           (tags (seq-map #'vulpea--title-to-tag names))
           (query (string-join tags "|")))
      (dlet ((org-agenda-overriding-arguments (list t query)))
        (org-agenda nil "M"))))


  (defun vulpea-agenda-lieu ()
    "Show main `org-agenda' view."
    (interactive)
    (let* ((person (vulpea-select
                    "Person"
                    :filter-fn
                    (lambda (note)
                      (seq-contains-p (vulpea-note-tags note)
                                      "LIEU"))))
           (node (org-roam-node-from-id (vulpea-note-id person)))
           (names (cons (org-roam-node-title node)
                        (org-roam-node-aliases node)))
           (tags (seq-map #'vulpea--title-to-tag names))
           (query (string-join tags "|")))
      (dlet ((org-agenda-overriding-arguments (list t query)))
        (org-agenda nil "M"))))

#+end_src



****** Fonction appel√© lors de la cr√©ation de la capture pour permettre de cr√©er un lieu ou d'un contact/personne

#+begin_src emacs-lisp

  (defun cp/org-roam-property-file-add (prop val)
    "Add VAL value to PROP property for the node at point.
          Both, VAL and PROP are strings."
    (let* ((p (org-entry-get (point-min) prop))
           (lst (when p (split-string-and-unquote p)))
           (lst (if (memq val lst) lst (cons val lst)))
           (lst (seq-uniq lst)))
      (save-excursion
        (goto-char (point-min))
        (org-set-property prop (combine-and-quote-strings lst))
        val
        )
      ))

  ;;  TODO : (read-string "Enter name:") renvoie un string
  (defun cp/add-other-auto-props-to-org-roam-properties ()
    ;; if the file already exists, don't do anything, otherwise...
    ;; if there's also a CREATION_TIME property, don't modify it
    (when (member "PERSONNE" (vulpea-buffer-tags-get))
      (cp/org-roam-property-file-add "VERSION" "3.0")
      (cp/org-roam-property-file-add "EMAIL" "")
      (cp/org-roam-property-file-add "EMAIL_HOME" "")
      (cp/org-roam-property-file-add "EMAIL_WORK" "")
      (cp/org-roam-property-file-add "PHONE" "")
      (cp/org-roam-property-file-add "CELL" "")
      (cp/org-roam-property-file-add "LANDLINE_HOME" "")
      (cp/org-roam-property-file-add "LANDLINE_WORK" "")
      (cp/org-roam-property-file-add "TITLE" "")
      (cp/org-roam-property-file-add "ORG" "")
      (cp/org-roam-property-file-add "ADDRESS_HOME" "")
      (cp/org-roam-property-file-add "ADDRESS_WORK" "")
      (cp/org-roam-property-file-add "BIRTHDAY" "")
      (cp/org-roam-property-file-add "URL" "")
      (cp/org-roam-property-file-add "NOTE" "")
      (cp/org-roam-property-file-add "CATEGORIES" "")
      (let
          ((note (vulpea-db-get-by-id (vulpea-db-get-id-by-file (buffer-file-name))))
           )
        (add-contact-to-file-of-contact note)
        )

      ;;on met √† jour les tags apr√®s l'insertion des options
      (vulpea-ensure-filetag)

      )
    (when (member "LIEU" (vulpea-buffer-tags-get))


      ;;on met √† jour les tags apr√®s l'insertion des options
      ;; (vulpea-ensure-filetag)
      )

    )

  ;;on hook apr√®s la capture
  (add-hook 'org-capture-after-finalize-hook #'cp/add-other-auto-props-to-org-roam-properties)

  ;; (remove-hook 'org-roam-capture-new-node-hook #'cp/add-other-auto-props-to-org-roam-properties)

#+end_src



****** On ajoute les personnes au fichiers pour pouvoir exporter en vcard dans le fichier


1. aller dans inbox
2. cr√©er un sous titre
3. ajouter la ligne avec le bon lien !
   #+transclude: [[id:20220621120442360949][test contac]] :lines 0-20
4. il faut le hook avec l'autre fonction, voir m√™me la lancer en m√™me temps dans "when personne" !

#+begin_src emacs-lisp

  (setq file-of-contact (expand-file-name (concat org-roam-directory "pages/20220621120424-liste_de_mes_contacts_pour_org_contact.org")))
  (defun add-contact-to-file-of-contact (note)
      (save-window-excursion
        (find-file file-of-contact)
        (search-forward "Inbox" nil t)
        (org-insert-heading-after-current)
        ;; (org-metaright)
        (insert (vulpea-note-title note))
        (newline)
        ;;on ins√®re le lien, je pourrais concat mais flemme
        (insert ":PROPERTIES:")
        (newline)
        (insert "#+transclude:")
        ;;pour ins√©rer la note (prendre fonction vulpea-utils-link-make-string un jour)
        (progn
          (insert (org-link-make-string
                   (concat " id:" (vulpea-note-id note))
                   (vulpea-note-title note)))
          (run-hook-with-args
           'vulpea-insert-handle-functions
           note))
        (insert " :lines 3-18")
        (newline)
        (insert ":END:")
        )
    )

#+end_src


****** Fonction pour exporter mes contacts
#+begin_src emacs-lisp

  (use-package org-vcard
    :init
    ;;la version utilis√©e (pour pouvoir y envoyer sur google)
    (setq org-vcard-default-version "3.0")
    :config
    (setq org-vcard-default-export-file (concat org-roam-directory "Contacts.vcf"))
    )


  (fset 'cp/export-org-contact-macro
        (kmacro-lambda-form [?a ?o ?r ?g ?- ?v ?c ?a ?r ?d ?- ?e ?x ?p ?o ?r ?t return ?b ?u return ?f ?i ?l return home ?b ?p ?n ?u ?C ?o ?n ?t ?a ?c ?t ?s ?. ?v ?c ?f return] 0 "%d"))


  (defun cp/function-to-export-org-contact ()
    (interactive)
    (save-window-excursion
      (find-file file-of-contact)
      (cp/export-org-contact-macro)
      )
    )


#+end_src

**** TODO maj Ins√©rer du texte dans un note en fonction d'une autre 

D√©pendant des ids dans id-locations.el

#+begin_src emacs-lisp
  (use-package org-transclusion
    :config
    ;;pour exporter les propri√©t√©s
    (setq org-transclusion-exclude-elements '(property-drawer
                                              ;; center-block
                                              keyword ;; pour pas exporter les truc avec #+ (comme les titres)
                                              )))
#+end_src

**** Gestion des fichiers et des dossiers en pi√®ce jointe 

***** Quand on rajoute un fichier en attachment, on store le link pour l'insertion

#+begin_src emacs-lisp
  (setq org-attach-store-link-p 'file)
  ;; pour que le lien soit relatif au dossier data, modifier cette fonction
  ;; org attach attach
#+end_src



***** On cr√©er les dossier par ann√©es/mois/jour/lerest par rapport √† la date de la cr√©ation du noeud pour les rangements

#+begin_src emacs-lisp

  ;;The first function in this list defines the preferred function which will be used when creating new attachment folders.
  (setq org-attach-id-to-path-function-list
        '(org-attach-id-ts-folder-format
          org-attach-id-uuid-folder-format))


  (defun org-attach-id-ts-folder-format (id)
    "Translate an ID based on a timestamp to a folder-path.
    Useful way of translation if ID is generated based on ISO8601
    timestamp.  Splits the attachment folder hierarchy into
    year-month, the rest."
    (format "%s" id)
    )



#+end_src

ancien : 
#+begin_src emacs-lisp :tangle no
(defun org-attach-id-ts-folder-format (id)
    "Translate an ID based on a timestamp to a folder-path.
  Useful way of translation if ID is generated based on ISO8601
  timestamp.  Splits the attachment folder hierarchy into
  year-month, the rest."
    (format "%s/%s/%s/%s"
            (substring id 0 4)
            (substring id 4 6)
            (substring id 6 8)
            (substring id 9)
            )
    )
#+end_src





***** Dired attachment

2 windows :‚ÄØune avec fichiers dired, l'autre avec le curseur sur le subtree ou attacher les fichiers
marquer les fichiers sur dired, appeler la fonction org-attach-dired-to-subtree, et voil√† !


#+begin_src emacs-lisp
(add-hook 'dired-mode-hook
          (lambda ()
            (define-key dired-mode-map
              (kbd "C-c C-x a")
              #'org-attach-dired-to-subtree)))
#+end_src

              

***** Chemin de org attach

#+begin_src emacs-lisp
    ;; (setq org-attach-id-dir (expand-file-name ".data/" vulpea-directory))

  (setq org-attach-id-dir (expand-file-name ".data/" org-roam-directory))

#+end_src

***** Pour pouvoir attacher des dossiers

Patch de la fonction pour pouvoir attach des dossiers

#+begin_src emacs-lisp

  ;; (advice-remove 'org-attach-attach 'my-new-org-attach-attach)

  (defun org-attach-attach (file &optional visit-dir method)
    "Move/copy/link FILE into the attachment directory of the current outline node.
  If VISIT-DIR is non-nil, visit the directory with `dired'.
  METHOD may be `cp', `mv', `ln', `lns' or `url' default taken from
  `org-attach-method'."
    (interactive
     (list
      (read-file-name "File to keep as an attachment: "
                      (or (progn
                            (require 'dired-aux)
                            (dired-dwim-target-directory))
                          default-directory))
      current-prefix-arg
      nil))
    (setq method (or method org-attach-method))
    (when (file-directory-p file)
      (setq file (directory-file-name file)))
    (let ((basename (file-name-nondirectory file)))
      (let* ((attach-dir (org-attach-dir 'get-create))
             (attach-file (expand-file-name basename attach-dir)))
        (cond
         ((eq method 'mv) (rename-file file attach-file))
         ((eq method 'cp)
          (if (file-directory-p file)
              (copy-directory file attach-file nil nil t)
            (copy-file file attach-file)))
         ((eq method 'ln) (add-name-to-file file attach-file))
         ((eq method 'lns) (make-symbolic-link file attach-file))
         ((eq method 'url) (url-copy-file file attach-file)))
        (run-hook-with-args 'org-attach-after-change-hook attach-dir)
        (org-attach-tag)
        (cond ((eq org-attach-store-link-p 'attached)
               (push (list (concat "attachment:" (file-name-nondirectory attach-file))
                           (file-name-nondirectory attach-file))
                     org-stored-links))
              ((eq org-attach-store-link-p t)
               (push (list (concat "file:" file)
                           (file-name-nondirectory file))
                     org-stored-links))
              ((eq org-attach-store-link-p 'file)
               (push (list (concat "file:" attach-file)
                           (file-name-nondirectory attach-file))
                     org-stored-links)))
        (if visit-dir
            (dired attach-dir)
          (message "File %S is now an attachment" basename)))))

#+end_src


(defun my-new-org-attach-attach (file &optional visit-dir method)
    "Move/copy/link FILE into the attachment directory of the current outline node.
        If VISIT-DIR is non-nil, visit the directory with `dired'.
        METHOD may be `cp', `mv', `ln', `lns' or `url' default taken from
        `org-attach-method'."
    (interactive
     (list
      (read-file-name "File to keep as an attachment: "
                      (or (progn
                            (require 'dired-aux)
                            (dired-dwim-target-directory))
                          default-directory))
      current-prefix-arg
      nil))
    (setq method (or method org-attach-method))
    (let ((basename (file-name-nondirectory file)))
      (let* ((attach-dir (org-attach-dir 'get-create))
             (attach-file (expand-file-name basename attach-dir)))
        (cond
         ((eq method 'mv) (rename-file file attach-file))
         ((eq method 'cp) (if (file-directory-p file)
                              (copy-directory file
                                              (concat attach-file
                                                      (concat "/" (file-name-nondirectory
                                                                   (directory-file-name
                                                                    (file-name-directory file))))))
                            (copy-file file attach-file)
                            ))
         ((eq method 'ln) (add-name-to-file file attach-file))
         ((eq method 'lns) (make-symbolic-link file attach-file))
         ((eq method 'url) (url-copy-file file attach-file)))
        (run-hook-with-args 'org-attach-after-change-hook attach-dir)
        (org-attach-tag)
        (cond ((eq org-attach-store-link-p 'attached)
               (push (list (concat "attachment:" (file-name-nondirectory attach-file))
                           (file-name-nondirectory attach-file))
                     org-stored-links))
              ((eq org-attach-store-link-p t)
               (push (list (concat "file:" file)
                           (file-name-nondirectory file))
                     org-stored-links))
              ((eq org-attach-store-link-p 'file)
               (push (list (concat "file:" attach-file)
                           (file-name-nondirectory attach-file))
                     org-stored-links)))
        (if visit-dir
            (dired attach-dir)
          (if (string-equal basename "")

              (message "File %S is now an attachment" (file-name-nondirectory
                                                                   (directory-file-name
                                                                    (file-name-directory file))))
              (message "File %S is now an attachment" basename)
              )
          ))))

          




***** Pour prendre des notes sur des fichiers

#+begin_src emacs-lisp
  ;; (use-package org-noter) ;; outdated ?


  ;; marche pas
  ;; (use-package org-noter
    ;; :straight (org-noter-plus-djvu
               ;; :type git
               ;; :host github
               ;; :repo "c1-g/org-noter-plus-djvu")
    ;; )


  (use-package org-remark)
  (require 'org-remark-global-tracking)
  (org-remark-global-tracking-mode +1)

  ;; Key-bind `org-remark-mark' to global-map so that you can call it
  ;; globally before the library is loaded.

  (define-key global-map (kbd "C-c n m") #'org-remark-mark)

  ;; The rest of keybidings are done only on loading `org-remark'
  (with-eval-after-load 'org-remark
    (define-key org-remark-mode-map (kbd "C-c n o") #'org-remark-open)
    (define-key org-remark-mode-map (kbd "C-c n ]") #'org-remark-view-next)
    (define-key org-remark-mode-map (kbd "C-c n [") #'org-remark-view-prev)
    (define-key org-remark-mode-map (kbd "C-c n r") #'org-remark-remove))


  ;; (use-package org-noter
  ;;   :after (:any org pdf-view)
  ;;   :config
  ;;   (setq
  ;;    ;; The WM can handle splits
  ;;    org-noter-notes-window-location 'other-frame
  ;;    ;; Please stop opening frames
  ;;    org-noter-always-create-frame nil
  ;;    ;; I want to see the whole file
  ;;    org-noter-hide-other nil
  ;;    ;; Everything is relative to the main notes file
  ;;    org-noter-notes-search-path (list org_notes)
  ;;    )
  ;;   )

#+end_src
          
**** Gestion des archives

***** Base
#+begin_src emacs-lisp


  (use-package org-archive
    :straight nil
    :defer t

    :init
    (setq-default
     org-archive-file-header-format "" ;;ce qui est affich√© au d√©but du fichier
     org-archive-location
     (concat braindump-directory "org/.archive/%s_archive" "::")
     ;; (concat braindump-directory "org/.archive/%s_archive" "::" "* T√¢ches archiv√©es") pl√©onasme
     ;; (concat braindump-directory "org/.archive/%s_archive" "::" "datetree/")
     ;; (concat braindump-directory "org/.archive/datetree.org::datetree/")
     org-archive-save-context-info
     '(time file ltags itags todo category olpath))

    :config
    ;; (setq org-attach-archive-delete t) ;; permet, si jamais ya des pi√®ces jointe avec un subtree qui est archiv√©, de les supprimer
    )

  ;; (setq org-archive-location "%s_archive::* ArchivedTasksfrom%s")
#+end_src

***** auto-archiver
****** Lors du changement d'une t√¢che simple

#+begin_src emacs-lisp

  (defun cp/org-archive-done-tasks ()
    (interactive)
    (when (org-roam-buffer-p)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward
                (concat "\\* " (regexp-opt org-done-keywords) " ") nil t)
          ;; (goto-char (line-beginning-position))
          (when (= (org-outline-level) 1)
            ;; (when (y-or-n-p  (format "voulez vous archiver %S ?" (org-entry-get nil "ITEM")))
            (org-archive-subtree)
            ;; )
            )))))

  ;; (add-hook 'org-trigger-hook 'save-buffer)
  ;; (remove-hook 'org-trigger-hook 'save-buffer)

  (add-hook 'before-save-hook 'cp/org-archive-done-tasks)
  ;; (remove-hook 'before-save-hook 'cp/org-archive-done-tasks)

#+end_src

#+begin_src emacs-lisp :tangle no

  ;; auto-archiver
  (defun cp/auto-org-archive-subtree()
    (when (and (org-entry-is-done-p) (eq (org-current-level) 1))
      (when (y-or-n-p  (format "voulez vous archiver %S ?" (org-entry-get nil "ITEM")))
        (org-archive-subtree))))

  ;; (add-hook 'org-after-todo-state-change-hook 'cp/auto-org-archive-subtree)
  ;; (remove-hook 'org-after-todo-state-change-hook 'cp/auto-org-archive-subtree)


#+end_src

****** Les rdv pass√©s en done automatiquement, et donc provoque l'archivage

Au final, je fais les actions, puis √† la sauvegarde, j'archive.


#+begin_src emacs-lisp
  ;; commande pour trouver et mettre en done les √©v√®nement pass√©e
  (defun cp/org-ql-search-for-past-timestamps()
    (org-ql-select (org-agenda-files)
      '(and
        (not (scheduled))
        (not (deadline))
        (not (done))
        (ts-active :to today)
        )
      :action '(org-todo "DONE")
      )
    )

  ;; on clean quand on kill emacs
  (add-hook 'kill-emacs-hook #'cp/org-ql-search-for-past-timestamps)
#+end_src


Attendre r√©ponse mec org-ql. Juste faire la commande suivante, tout s√©lectionner et mettre en done (B puis t puis done)

Nombreux bugs, notamment au niveau de l'archivage. Il semblerait que le curseur se d√©place ailleurs avant de demander pour l'archivage, ce qui veut dire qu'il archive le mauvais lol.

Au final, deux cas :‚ÄØ
1. Niveau 1 :‚ÄØcertains heading ne sont pas archiv√©, on fait donc une boucle tant qu'il en reste
2. pas niveau 1, sinon √ßa break tout. On mets juste la t√¢che en done. Auto-archivage ne fonctionne pas encore bien non plus. 


#+begin_src emacs-lisp :tangle no
  
    (defun test()
      (interactive)
      (save-excursion
        (org-archive-subtree)))

  (org-ql-select (org-agenda-files)
        '(and
          (not (scheduled))
          (not (deadline))
          (not (done))
          (ts-active :to today)
          )
        :action '(org-archive-subtree)
        )



    ;; archiver les choses qui ne doivent pas avoir une action et qui sont juste timestamp (exemple : un rdv)
    ;; pas besoin de while normalement, juste l√† √ßa bug. Tant qu'il en reste, refaire la commande


    ;; seulement pour les niveaux 1
    (defun cp/auto-org-done-task-past-timestamp-and-not-todo-level-one()
      (while (org-ql-select (org-agenda-files)
               '(and
                 (not (scheduled))
                 (ts-active :to today)
                 (level 1)
                 )
               )
        (org-ql-select (org-agenda-files)
          '(and
            (not (scheduled))
            (ts-active :to today)
            (level 1)
            )
          :action '(org-todo "DONE")
          )
        )
      )

    ;; (cp/auto-org-done-task-past-timestamp-and-not-todo-level-one)

    (defun cp/auto-org-done-task-past-timestamp-and-not-todo-not-level-one()
      (while (org-ql-select (org-agenda-files)
               '(and
                 (not (scheduled))
                 (not (todo "DONE"))
                 (ts-active :to today)
                 (level '> 1)
                 )
               )
        (org-ql-select (org-agenda-files)
          '(and
            (not (scheduled))
            (not (todo "DONE"))
            (ts-active :to today)
            (level '> 1)
            )
          :action '(org-todo "DONE")
          )))
    ;; (cp/auto-org-done-task-past-timestamp-and-not-todo-not-level-one)

#+end_src



(org-ql-select (org-agenda-files)
        '(and
          (rifle "le focus")
          (scheduled :to today)
          (ts-active :to today))
        ;; :action '(org-toggle-tag "Emacs" 'on) ;; mettre la bonne action ici
        ;; :action '(org-todo "DONE")
        :action #'org-archive-subtree)

**** Gestion de l'int√©raction avec le pc

#+begin_src emacs-lisp
  (require 'org-protocol)
#+end_src

**** Gestion du cryptage

Pour crypter automatiquement : epa + tag "crypt" sur des arbres org-mode

***** TODO EPA

Edit .gnupg/gpg-agent.conf (create it if necessary) by adding the following:
allow-emacs-pinentry

#+begin_src emacs-lisp 

  (use-package epa-file
    :straight nil ;; included with Emacs
    :config
    (epa-file-enable)
    ;; (setq epa-file-encrypt-to '("my@email.address.org"))
    (setq epa-file-select-keys nil)
    (when termux-p
      (setq epa-pinentry-mode 'loopback) ;;demande le mdp dans le mini-buffer
      (setq epg-gpg-program "/data/data/com.termux/files/usr/bin/gpg")
      )
    )

#+end_src

***** Org


#+begin_src emacs-lisp :tangle no
  (load "~/.emacs.d/config/lisp/sensitive-minor-mode.el")
  (require 'sensitive-minor-mode)
#+end_src

#+begin_src emacs-lisp



  (use-package org-crypt
    :straight nil  ;; included with org-mode
    :after org
    :custom
    ;; (org-crypt-key "my@email.address.org")
    (org-crypt-key nil)
    :config
    (org-crypt-use-before-save-magic)
    ;; org-tags-exclude-from-inheritance '("crypt")
    ;; (require 'org-crypt)
    )


#+end_src

**** T√©l√©charger les infobox de Wikip√©dia rapidement (sympas)

#+begin_src emacs-lisp

  (use-package wikinforg
    :config
    (setq wikinforg-wikipedia-edition-code "fr")
    )

#+end_src

**** Gestion des dates


***** Gestion de la fonction d'annotation
#+begin_src emacs-lisp
  ;;‚ÄØmodification de ma fonction d'annotation
  (setq vulpea-select-annotate-fn #'cp/vulpea-select-annotate)

  ;; variable de la date
  (setq cp/vulpea-date "date")

  ;;‚ÄØajout de la date dans les annotations
  (defun cp/vulpea-select-annotate (note)
    "Annotate a NOTE for completion."
    (let* ((alias-str
            (if (vulpea-note-primary-title note)
                (concat "("
                        (vulpea-note-primary-title note)
                        ")")
              ""))
           (tags-str (mapconcat
                      (lambda (x) (concat "#" x))
                      (vulpea-note-tags note)
                      " "))
           (date-str (if (vulpea-meta-get note cp/vulpea-date)
                         (vulpea-meta-get note cp/vulpea-date)
                       ;; (make-string 8 (string-to-char " "))
                       ""
                       ))
           (sections (seq-remove #'string-empty-p
                                 (list
                                  date-str
                                  alias-str
                                  tags-str
                                  ))))
      (if (null sections)
          ""
        (concat " " (string-join sections " ")))))
#+end_src

***** Gestion de la dur√©e des t√¢ches 

****** Gestion de l'effort estimate

Je peux juste afficher les t√¢che sup inf ou √©gale √† quelque chose avec org-agenda-filter-by-effort

****** Gestion de (org-clock)
******* TODO Package pratique pour nouvelle fonction directement dans l'agenda
:LOGBOOK:
- State "TODO"       from              [2022-11-03 Thu 21:33]
:END:
  https://github.com/dfeich/org-clock-convenience

******* Autre


R dans org-agenda pour tout voir



**** TODO Publier son site un jour
**** Fin du when
#+begin_src emacs-lisp
)
#+end_src



** Org-roam, seulement si ya mon braindump (logique)

#+begin_src emacs-lisp

  (use-package org-roam
    :if braindump-exists

#+end_src


*** Org-roam pur

**** Init

#+begin_src emacs-lisp
  :init
  ;;√©viter d'avoir la nottif de version 1 √† 2 
  (setq org-roam-v2-ack t)
#+end_src

**** Config

#+begin_src emacs-lisp
  :config
#+end_src

***** Mise √† jour de la org-roam-db sur mes appareil si il y a un changement

#+begin_src emacs-lisp

  (defun org-roam-db-sync-when-change (event)
    (message "Mise √† jour de la base de donn√©e d'org-roam")
    (org-roam-db-sync)  
    )

  (require 'filenotify)
  (file-notify-add-watch (concat braindump-directory "org/pages")
                         '(attribute-change) 'org-roam-db-sync-when-change)



#+end_src


***** Am√©lioration mineur et completion

  ;;pour mes fichiers agenda prennent en compte les hook, il suffit de faire un revert

#+begin_src emacs-lisp


  ;; compl√©tion et proprosition
  (setq org-roam-completion-everywhere t) ;; pour avoir la compl√©tion partout avec company
  (setq completion-ignore-case t) ;; ne d√©pend pas de la case pour la compl√©tion
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-capf) ;;completion avec org-roam
    )


  (with-eval-after-load 'company-box

    (add-hook 'org-mode-hook 'company-mode)
    (add-hook 'org-mode-hook (lambda () (company-box-mode 0)))

    )
  
  ;; syncro automatique avec les fichiers
  (org-roam-db-autosync-mode)

  ;; pour am√©liorer les perf
  (setq org-roam-db-gc-threshold most-positive-fixnum)

  ;; On prend pas les fichiers org dans org-attach
  (setq org-roam-file-exclude-regexp ".data/")


#+end_src


***** TODO Quelles sont les liens que je veux ignorer (ou pas lol) ?
:LOGBOOK:
- State "TODO"       from              [2022-10-31 Mon 23:50]
:END:

Par exemple, si je veux que mes transclude soit consid√©rer comme des backlinks, il faudra que je touche cette variable

#+begin_src emacs-lisp
  
  (setq org-roam-db-extra-links-exclude-keys '((node-property . ("ROAM_REFS"))
                                               (keyword . ("transclude"))))

  ;; org-roam-db-extra-links-elements
#+end_src


***** Org-roam capture

#+begin_src emacs-lisp

  ;;ajout du tag BROUILLON tant que c'est pas fini
  (defun jethro/tag-new-node-as-draft ()
    (when
        ;; (not (member (buffer-file-name) (org-roam-dailies--list-files)))
        (string-equal (expand-file-name default-directory)
                      (concat org-roam-directory org-roam-dailies-directory))
      (org-roam-tag-add '("BROUILLON"))
      )
    ;; (org-roam-tag-add '("BROUILLON"))
    )
  (add-hook 'org-roam-capture-new-node-hook #'jethro/tag-new-node-as-draft)


  (setq org-roam-capture-templates
        '(
          ("d" "default" plain "%?"
           :target (file+head "pages/%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}\n")
           :unnarrowed t)
          ("p" "connaissances multiples √† trier ds 2jours" plain (file "../templatesOrgCapture/connaissance.org")
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t)

          ("l" "lien simple" plain (file "../templatesOrgCapture/lien.org")
           :target (file+head "liens/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t
           :immediate-finish t)
          ("s" "simple/basique" plain (file "../templatesOrgCapture/simple.org")
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t
           :immediate-finish t)
          ("c" "contact" plain (file "../templatesOrgCapture/contact.org")
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t)

          ("C" "Crypter" plain "%?"
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org.gpg"
                              "#+title: ${title}\n")
           :unnarrowed t)


          ("T" "Test de nouveau nom" plain "%?"
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t)

          ("r" "bibliography reference" plain
           (file "../templatesOrgCapture/key.org")
           :if-new 
           (file+head "reference/${citekey}.org" "#+title: ${title}\n")
           :unnarrowed t
           :jump-to-captured t)


          ("r" "bibliography reference" plain
           (file "../templatesOrgCapture/key.org")
           :target
           (file+head "reference/${citekey}.org" "#+title: ${title}\n")
           :unnarrowed t)
        
          )
        )

#+end_src

***** Journal

#+begin_src emacs-lisp
  ;;d√©fini la capture de mon journal
  (setq org-roam-dailies-directory "journals/")

  (setq org-roam-dailies-capture-templates  '(
                                              ("d" "default" entry "* %<%H:%M> %?" :target
                                               (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))
                                              ))
#+end_src

***** Buffer des backlinks

#+begin_src emacs-lisp

  ;;ce qu'il y a dans le buffer de backlinks
  (setq org-roam-mode-sections
        (list #'org-roam-backlinks-section
              #'org-roam-reflinks-section
              #'org-roam-unlinked-references-section
              ))

  ;; on peut mettre des options !
  ;; (org-roam-mode-sections
  ;; '((org-roam-backlinks-section :unique t)
  ;; org-roam-reflinks-section))
#+end_src

***** TODO Lors de la recherche d'un noeud, info sup

****** TODO Voir le nombre de backlinks d'une note + Utiliser la souris sur le buffer backlinks

#+begin_src emacs-lisp

  (with-eval-after-load 'org-roam
    (define-key org-roam-mode-map [mouse-1] #'org-roam-visit-thing)
    ;; for org-roam-buffer-toggle
    ;; Recommendation in the official manual
    (add-to-list 'display-buffer-alist
                 '("\\*org-roam\\*"
                   (display-buffer-in-direction)
                   (direction . right)
                   (window-width . 0.33)
                   (window-height . fit-window-to-buffer)))
    ;;pour avoir le nombre de backlinks lorsque que l'on cherche un node
    (cl-defmethod org-roam-node-directories ((node org-roam-node))
      (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
          (format "%s" (car (f-split dirs)))
        ""))
    (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
      (let* ((count (caar (org-roam-db-query
                           [:select (funcall count source)
                                    :from links
                                    :where (= dest $s1)
                                    :and (= type "id")]
                           (org-roam-node-id node)))))
        (format "%d" count)))
    )


#+end_src

****** TODO hi√©rarchie quand on cherche/insert une note

#+begin_src emacs-lisp


  (with-eval-after-load 'org-roam


    ;; pour avoir la hi√©rarchie lorsque c'est une sous note 
    (cl-defmethod org-roam-node-filetitle ((node org-roam-node))
    "Return the file TITLE for the node."
    (org-roam-get-keyword "TITLE" (org-roam-node-file node)))


    (cl-defmethod org-roam-node-hierarchy ((node org-roam-node))
    "Return the hierarchy for the node."
    (let ((title (org-roam-node-title node))
    (olp (org-roam-node-olp node))
    (level (org-roam-node-level node))
    (filetitle (org-roam-node-filetitle node)))
    (concat
    (if (> level 0) (concat filetitle " -> "))
    (if (> level 1) (concat (string-join olp " -> ") " -> "))
    title))) ;; soit disant une erreur ici, mais tout va bien

    )


    ;; (setq org-roam-node-display-template "${directories:15} ${tags:40} ${backlinkscount:1}")
    ;; (setq org-roam-node-display-template "${directories:10} ${tags:10} ${title:100} ${backlinkscount:6}")

#+end_src

****** Qu'est ce qu'on met lorsque l'on recherche un node (nombre = nombre de caract√®re)

#+begin_src emacs-lisp
  (with-eval-after-load 'org-roam
    ;; (setq org-roam-node-display-template "${directories:15} ${hierarchy:105} ${tags:40} ${backlinkscount:1}") ;;plus besion des fichiers


    (cl-defmethod org-roam-node-type ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (file-name-nondirectory
           (directory-file-name
            (file-name-directory
             (file-relative-name (org-roam-node-file node) org-roam-directory))))
        (error "")))

    (setq org-roam-node-display-template "${type:15} ${hierarchy:130} ${tags:40} ${backlinkscount:2}")

    )
#+end_src



**** Fin de use-package org-roam
#+begin_src emacs-lisp
)
#+end_src


*** Fonctionnalit√© en plus gr√¢ce √† l'utilisation d' org-roam

***** TODO Biblioth√®que pour g√©rer certaines choses utiles

#+begin_src emacs-lisp
  (straight-use-package '(nursery
                          :host github
                          :repo "chrisbarrett/nursery"))



  ;; deps
  (use-package org-drill)
  (use-package org-roam-review
    :straight nil ;; c'est dans nursery, c'est donc d√©j√† charg√©
    ;; :load-path "config/lisp/nursery/lisp/" 
    ;; :load-path "straight/build/nursery"
    :commands (org-roam-review
               org-roam-review-list-by-maturity
               org-roam-review-list-recently-added)

    ;; ;; Optional - tag all newly-created notes as seedlings.
    ;; :hook (org-roam-capture-new-node . org-roam-review-set-seedling)

    ;; ;; Optional - keybindings for applying Evergreen note properties.
    ;; :general
    ;; (:keymaps 'org-mode-map
    ;; "C-c r r" '(org-roam-review-accept :wk "accept")
    ;; "C-c r u" '(org-roam-review-bury :wk "bury")
    ;; "C-c r x" '(org-roam-review-set-excluded :wk "set excluded")
    ;; "C-c r b" '(org-roam-review-set-budding :wk "set budding")
    ;; "C-c r s" '(org-roam-review-set-seedling :wk "set seedling")
    ;; "C-c r e" '(org-roam-review-set-evergreen :wk "set evergreen"))

    ;; ;; Optional - bindings for evil-mode compatability.
    ;; :general
    ;; (:states '(normal) :keymaps 'org-roam-review-mode-map
    ;; "TAB" 'magit-section-cycle
    ;; "g r" 'org-roam-review-refresh)
    )


  (use-package org-roam-search
    :straight nil ;; c'est dans nursery, c'est donc d√©j√† charg√©
    :commands (org-roam-search))

  (use-package org-roam-dblocks
    :straight nil ;; c'est dans nursery, c'est donc d√©j√† charg√©
    :hook (org-mode . org-roam-dblocks-autoupdate-mode))

  (use-package org-roam-consult
    :straight nil ;; c'est dans nursery, c'est donc d√©j√† charg√©
    :commands (org-roam-consult))

  ;; (use-package org-roam-gc
  ;; :commands (org-roam-consult))



#+end_src

***** Gestion des noeuds

****** CANCELLED‚ÄØQuand on-change le titre, √ßa change le nom du fichier

#+begin_src emacs-lisp :tangle no

  (defun org-roam-rename-file-with-new-title ()
    (when-let*
        ((is-roam-file (org-roam-file-p old-file))
         (is-not-a-key ())
         (old-file (buffer-file-name))

         (file-node (save-excursion
                      (goto-char 1)
                      (org-roam-node-at-point)))
         (date (substring (number-to-string  (read
                                              (split-string
                                               (org-roam-node-id
                                                (save-excursion
                                                  (goto-char 1)
                                                  (org-roam-node-at-point))) "-"))) 0 14))
         (slug (org-roam-node-slug file-node))
         (new-file (expand-file-name (concat date "-" slug ".org")))
         (different-name? (not (string-equal old-file new-file))))
      (when (not (member old-file (org-roam-dailies--list-files)))

        ;; ;; on le fait que si c'est pas dans le journal ou si c'est pas une cl√©!
        (rename-buffer new-file)
        (rename-file old-file new-file)
        (set-visited-file-name new-file)
        (set-buffer-modified-p nil)
        )
      ))

  ;; (add-hook 'before-save-hook 'org-roam-rename-file-with-new-title)
  ;; (remove-hook 'before-save-hook 'org-roam-rename-file-with-new-title)

#+end_src


****** Lors de l'ajout d'un noeud, permet de remplacer dans les org-files les unlinked references par le titre



#+begin_src emacs-lisp

  (defun cp/org-roam-unlinked-references-find-and-replace ()
    (message "Check unlinked references")
    (save-window-excursion
      (if-let* ((note (vulpea-db-get-by-id (org-id-get)))
                (id (vulpea-note-id note))
                (title (vulpea-note-title note))
                (FROM-STRING title) 
                (TO-STRING (concat "[[id:" id "][" title "]]")))
          (progn


            (dolist (file (org-roam-list-files))
              ;; on check pas les fichiers crypt√©s !
              (unless (string-equal (file-name-extension file) "gpg")
                (find-file file)
                (unless (string-equal id (vulpea-db-get-id-by-file (buffer-file-name))) ;;faut pas que ce soit le fichier de base
                  (save-excursion
                    (goto-char (point-min))
                    (while (re-search-forward
                            (concat "\\([ ]\\|^\\)" title "\\([ ]\\|$\\)")
                            nil t)
                      (goto-char (match-beginning 0))
                      (skip-chars-forward " ")
                      (search-forward FROM-STRING)

                      (when (y-or-n-p "Remplac√© le texte par un lien vers le nouveau titre ?")

                        ;; oblig√© de faire √ßa √† cause du y-or-n-p qui me brise mon match. Je pourrais juste mettre (search-forward FROM-STRING) ici, mais si je remplace pas le texte, boucle infini
                        (search-backward FROM-STRING)
                        (goto-char (match-end 0))

                        (replace-match TO-STRING)
                        (message "Texte remplac√©")
                        )))
                  ;; ancien ;;(query-replace FROM-STRING TO-STRING nil (point-min) (point-max)) ;; pour pas prendre en compte quand c'est dans une cha√Æne 3 argument t
                  (save-buffer)
                  )))
            (message "Fin check unlinked references")
            )        ;; fin du si oui

        (progn (message "Pas besoin de check les r√©f√©rences"))
        )))

  ;;(add-hook 'org-capture-after-finalize-hook #'(lambda () (when (member (buffer-file-name) (org-roam-list-files)) (cp/org-roam-unlinked-references-find-and-replace))))


  (add-hook 'org-capture-after-finalize-hook
            #'(lambda ()
                (save-window-excursion
                  (org-capture-goto-last-stored)
                  (when (member (buffer-file-name) (org-roam-list-files)) (cp/org-roam-unlinked-references-find-and-replace)))))


#+end_src
****** Permet de rename un noeud partout ! Pas s√ªr que cela marche
******* Avec Nursery

#+begin_src emacs-lisp

  (use-package org-roam-rewrite
    :straight nil ;; c'est dans nursery, c'est donc d√©j√† charg√©
    :commands (org-roam-rewrite-rename
               org-roam-rewrite-remove
               org-roam-rewrite-inline
               org-roam-rewrite-extract))

#+end_src
******* Ma version
#+begin_src emacs-lisp :tangle no

    ;; todo : utiliser ceci
    ;; (title-without-parens-and-space "testetau   ()")


  (defun cp/org-roam-rename-and-replace ()
    (interactive)
    (save-window-excursion
      (let* ((note (vulpea-select-from "la note √† changer de nom" (vulpea-db-query)))
             (id (vulpea-note-id note))
             (title (vulpea-note-title note))
             (new-title (read-string "nouveau nom "))
             (FROM-STRING (concat "[[id:" id "][" title "]]")) 
             (TO-STRING (concat "[[id:" id "][" new-title "]]")))
        ;; on rename dans le fichier de base
        (find-file (vulpea-db-get-file-by-id id))
        (vulpea-buffer-title-set new-title)
        ;; pour les autres fichiers
        (dolist (file (org-roam-list-files))
          (find-file file)
          (unless (string-equal id (vulpea-db-get-id-by-file (buffer-file-name))) ;;faut pas que ce soit le fichier de base
            (query-replace FROM-STRING TO-STRING nil (point-min) (point-max)) ;; pour pas prendre en compte quand c'est dans une cha√Æne 3 argument t
            (save-buffer)
            )))))
  


#+end_src



****** Voir l'historique d'un fichier (avec magit)

#+begin_src emacs-lisp

  (defun cp/history-of-a-node (&optional file)
      (interactive (list (vulpea-db-get-file-by-id (vulpea-note-id (vulpea-select-from "historique de cette note : " (vulpea-db-query))))))
      (find-file file)
      (magit-log-buffer-file)
      (delete-other-windows)
      )

#+end_src



****** Fonction pour naviguer rapidement au niveau des noeuds (ou bien utiliser org-roam-ui !!!!)

Deux fonctions : une qui ajoute "Backlinks :" au debut des titres et l‚Äôautre "Links :". prend en param√©tre une liste de note vulpea (g√©rer le cas vide). et retourne une nouvelle liste modifi√©.
Pas possible, car impossible de modifi√© une note-vulpea dans une liste. Rip. Faire autrement (un jour)

Voir apr√®s pour un mini test de ces deux fonctions

#+begin_src emacs-lisp

  (defun cp/vulpea-get-id-at-point()
    "renvoie l'id du noeud au point actuel"
    (let ((id (org-id-get)))
      ;; tant que actuelle pas d'id, alors on monte,
      (save-excursion
        (while (and (ignore-errors (outline-up-heading 1 t)) (not id))
          (when (org-id-get)
            (setq id (org-id-get)))
          )
        ;; sinon on prend l'id du buffer
        (unless id
          (save-excursion
            (goto-char (point-min))
            (setq id (org-id-get)))
          ))
      id
      ))

  (defun cp/vulpea-links-to()
    "Renvoie une liste de note pr√©sent dans le noeud"
    (let (end)
      (dolist (id (remove nil
                          (mapcar
                           (lambda (x)
                             (when (string-equal (car x) "id")
                               (cdr x))
                             )
                           (vulpea-note-links (vulpea-db-get-by-id
                                               (cp/vulpea-get-id-at-point)
                                               ))
                           )))
        ;; (message "test %S"(vulpea-db-get-by-id id))
        (push (vulpea-db-get-by-id id) end)
        )
      end
      )
    )


  (defun cp/vulpea-find-backlink-and-links ()
    "Select and find a note linked to current note."
    (interactive)
    (let* ((node (org-roam-node-at-point 'assert))
           (backlinks (vulpea-db-query-by-links-some
                       (list (cons "id"
                                   (org-roam-node-id node)))))
           (links-to (cp/vulpea-links-to))
           )
      (unless (or backlinks links-to)
        (user-error "Pas de lien vers ni de backlinks"))
      ;; (message "les deux %S" (append test backlinks))
      ;; (message "back %S" backlinks)
      (vulpea-find
       :candidates-fn (lambda (_) (append
                                   backlinks
                                   ;; '(#s(vulpea-note "20220728120707052420" "/home/utilisateur/braindump/org/pages/20220728120707-test_nom_simpl.org" 0 "Liens vers :" nil nil nil (("id" . "20220617105540968308") ("id" . "20220617115633324937") ("id" . "20220623142208004885") ("id" . "20220616193340664791")) (("CATEGORY" . "20220728120707-test_nom_simpl") ("ID" . "20220728120707052420") ("BLOCKED" . "") ("FILE" . "/home/utilisateur/braindump/org/pages/20220728120707-test_nom_simpl.org") ("PRIORITY" . "D")) (("linkInTitle" "[[id:20220617105540968308][Git]]" "[[id:20220617115633324937][Page de Test]]" "[[id:20220623142208004885][Histoire de la chine]]" "[[id:20220616193340664791][Comment faire un second cerveau]]"))))
                                   links-to))
       :require-match t)))

  (defun cp/vulpea-navigate-with-backlink-and-links ()
    (interactive)
    (if (member (buffer-file-name) (org-roam-list-files))
        (while t
          (cp/vulpea-find-backlink-and-links)
          )
      (message "il faut √™tre dans un buffer org-mode")
      )
    )

#+end_src

Autre version, peut-√™tre √† choisir (mais break la s√©mantique de vulpea-find) :

#+begin_src emacs-lisp :tangle no

  (cl-defun vulpea-find-no-create (&key other-window
                                        filter-fn
                                        candidates-fn
                                        require-match)
    "As vulpea-find, but if the note does not exist, then return t instead of creating it"
    (interactive)
    (let* ((region-text
            (when (region-active-p)
              (org-link-display-format
               (buffer-substring-no-properties
                (set-marker
                 (make-marker) (region-beginning))
                (set-marker
                 (make-marker) (region-end))))))
           (note (vulpea-select-from
                  "Note"
                  (funcall
                   (or
                    candidates-fn
                    vulpea-find-default-candidates-source)
                   (or
                    filter-fn
                    vulpea-find-default-filter))
                  :require-match require-match
                  :initial-prompt region-text)))
      (if (vulpea-note-id note)
          (org-roam-node-visit
           (org-roam-node-from-id (vulpea-note-id note))
           (or current-prefix-arg
               other-window))
        (when (not require-match)
          t))))



  (defun cp/vulpea-find-backlink-and-links ()
    "Select and find a note linked to current note."
    (interactive)
    (let* ((node (org-roam-node-at-point 'assert))
           (backlinks (vulpea-db-query-by-links-some
                       (list (cons "id"
                                   (org-roam-node-id node)))))
           (links-to (cp/vulpea-links-to))
           )
      (unless (or backlinks links-to)
        (user-error "Pas de lien vers ni de backlinks"))
      ;; (message "les deux %S" (append test backlinks))
      ;; (message "back %S" backlinks)
      (vulpea-find-no-create
       :candidates-fn (lambda (_) (append
                                   backlinks
                                   links-to))
       ;; :require-match t
       )
      ))

  (defun cp/vulpea-navigate-with-backlink-and-links ()
    (interactive)
    (if (member (buffer-file-name) (org-roam-list-files))
        (while (not (cp/vulpea-find-backlink-and-links)))
      (message "You must be in a file of org-roam")
      )
    )

#+end_src

****** TODO Fonctions pour faire des recherches

#+begin_src emacs-lisp :tangle no




  (vulpea-select-from "texet" (vulpea-db-query
                               (lambda (note)
                                 (and
                                  ;; (string-equal (vulpea-meta-get note "utilisateur") "email")
                                  ;; (= (vulpea-note-level note) 0)
                                  (< (vulpea-note-meta-get note "numbers" 'number) 100)
                                  )
                                 )))


  (setq note (vulpea-db-get-by-id (org-id-get)))


  (vulpea-select-from "Choses √† voir"
                      (vulpea-db-query
                       (lambda (note)
                         ;; (and
                         ;; (seq-contains-p (vulpea-note-links note) (cons "id" "8f62b3bd-2a36-4227-a0d3-4107cd8dac19"))
                         (or
                          ;; (seq-contains-p (vulpea-meta-get note "utilisateur") "testee")
                          (string-equal (vulpea-meta-get note "utilisateur") "email")
                          (seq-contains-p (vulpea-note-tags note) "utilisateur")
                          ;; )
                          )))
                      )

  (vulpea-select-from "texte" (vulpea-db-query
                       (lambda (note)
                         (< (vulpea-note-meta-get note "numbers" 'number) 100))))


#+end_src


****** Fonction pour savoir o√π je parle de X chose. Super 


#+begin_src emacs-lisp

  (defun cp/vulpea-find-backlinks-every ()
    "Find the notes that contain links to X other notes"
    (interactive)
    (let* (
           (notes (vulpea-utils-collect-while
                   #'vulpea-select
                   nil
                   "Note" :require-match t))
           (list-of-cons (seq-map
                          #'(lambda (note) (cons "id" (vulpea-note-id note)))
                          notes
                          ))
           (links (vulpea-db-query-by-links-every list-of-cons))     
           )
      (unless links
        (user-error "There are no notes with the links you demand"))
      (vulpea-find
       :candidates-fn (lambda (_) links)
       :require-match t)
      )
    )


#+end_src

****** Naviguer avec un menu sur le cot√© (backlinks and normal)

https://github.com/chrisbarrett/nursery

#+begin_src emacs-lisp :tangle no


(use-package org-roam-links
    :straight nil ;; c'est dans nursery, c'est donc d√©j√† charg√©
    :commands (org-roam-links))

#+end_src

****** TODO Fonction permettant de corriger les titres et de mettre des m√©tadata titre apr√®s la capture (ne pas faire comme √ßa)
:LOGBOOK:
- State "TODO"       from              [2022-08-06 Sat 00:20]
:END:

#+begin_src emacs-lisp :tangle no

  (defun test ()
    (interactive)
    (goto-char (point-min))
    (message "salut, le point est l√† : %s" (point))
    (message "salut, le point est l√† :")
    )

  (add-hook
   'org-capture-after-finalize-hook
   #'(lambda () (message "dedans hook : %s" (buffer-file-name))
       (when
           (member (buffer-file-name) (org-roam-list-files))
         (test)
         (message "dedans whe")
         )))

  (add-hook 'org-capture-after-finalize-hook
            #'(lambda ()
                (save-window-excursion
                  (org-capture-goto-last-stored)
                  (when (member (buffer-file-name) (org-roam-list-files)) (test)))))


  (remove-hook 'org-capture-after-finalize-hook #'(lambda () (when (member (buffer-file-name) (org-roam-list-files)) (test))))

#+end_src



****** Transforme un heading en note

#+begin_src emacs-lisp

  ;;‚ÄØl'am√©liorer en prenant les choses diff√©rents et avec tout dans un let
  (defun cp/vulpea-heading-to-note()
    (interactive)
    (when-let* ((note (vulpea-db-get-by-id (cp/vulpea-get-id-at-point)))
                (heading (org-entry-get nil "ITEM"))
                (title (progn (while (setq name (vulpea-note-id (setq notetest (vulpea-select "Veuillez choisir un nom qui n'existe pas :" :initial-prompt heading))))
                                )
                              (vulpea-note-title notetest))
                       )

                (source (vulpea-meta-get note "Source"))
                (lieu (vulpea-meta-get note "Lieu"))
                )
      (save-excursion
        (ignore-errors (outline-up-heading 0))
        (save-restriction
          (org-narrow-to-subtree)
          ;; on coupe le titre
          (delete-region (line-beginning-position) (line-beginning-position 2))
          ;;
          (setq contenu (buffer-substring-no-properties (point-min) (point-max)))
          (delete-region (point-min) (point-max))
          (vulpea-create
           title
           "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
           ;; :properties '(("COUNTER" . "1")
           ;; ("STATUS" . "ignore")
           ;; ("ROAM_ALIASES" . "\"Very rich note with an alias\""))
           ;; :tags '("documentation" "showcase")
           ;; :head "#+author: unknown\n#+date: today"
           :body (concat
                  "- Source :: " source "\n"
                  "- Lieu :: " lieu "\n"
                  contenu
                  )
           ;; :immediate-finish t
           )))))

#+end_src


***** R√©f√©rence key

****** On n'ajoute pas une citation d√©j√† mise ailleurs

#+begin_src emacs-lisp

  (defun cp/org-roam-ref-add-check (keys-entries)
    (interactive (list (citar-select-ref :multiple nil :rebuild-cache t)))
    (let ((title (citar--format-entry-no-widths (cdr keys-entries)
                                                "${author editor} :: ${title}"))

          (citation-key (car keys-entries))
          )
      (when (member `(,citation-key) ;; ` = liste, mais permet d'√©valuer la variable juste apr√®sle,
                    (org-roam-db-query
                     [:select ref
                              :from refs
                              :left-join nodes
                              :on (= refs:node-id nodes:id)]))
        (org-roam-ref-remove (citar-org-return-citation-string (citar--extract-keys (list citation-key))))
        (user-error "La r√©f√©rence est d√©j√† mise dans un autre noeud pour la ROAM_REFS"))
      ))

  ;; (advice-add 'cp/org-roam-ref-add :before #'cp/org-roam-ref-add-check)
  ;; (advice-remove 'cp/org-roam-ref-add #'cp/org-roam-ref-add-check)

  ;; (advice-add 'org-roam-ref-add :before #'cp/org-roam-ref-add-check)
  ;; (advice-remove 'org-roam-ref-add #'cp/org-roam-ref-add-check)


#+end_src


****** Quand on ajoute un ref, proprose directement si citar configur√©

#+begin_src emacs-lisp

  (defun citar-org-return-citation-string (keys &optional style)
    "Inspir√© de citar-org-insert-citation. Au lieu d'ins√©rer, renvoie"
    (let ((context (org-element-context)))
      (when style
        (let ((raw-style
               (citar-org-select-style)))
          (setq style
                (if (string-equal raw-style "") raw-style
                  (concat "/" raw-style)))))
      (if-let ((citation (citar-org--citation-at-point context)))
          (when-let ((keys (seq-difference keys (org-cite-get-references citation t)))
                     (keystring (mapconcat (lambda (key) (concat "@" key)) keys "; "))
                     (begin (org-element-property :contents-begin citation)))
            (if (<= (point) begin)
                (org-with-point-at begin
                  (insert keystring ";"))
              (let ((refatpt (citar-org--reference-at-point)))
                (org-with-point-at (or (and refatpt (org-element-property :end refatpt))
                                       (org-element-property :contents-end citation))
                  (if (char-equal ?\; (char-before))
                      (insert-before-markers keystring ";")
                    (insert-before-markers ";" keystring))))))
        (format "[cite%s:%s]" (or style "")
                (mapconcat (lambda (key) (concat "@" key)) keys "; "))
        )))

  (defun cp/org-roam-ref-add (keys-entries)
    "Add REF to the node at point."
    (interactive (list (citar-select-ref :multiple nil :rebuild-cache t)))
    (cp/org-roam-ref-add-check keys-entries) ;;check si la ref est d√©ja mise
    (let ((node (org-roam-node-at-point 'assert))
          (ref-key (citar-org-return-citation-string (citar--extract-keys (list keys-entries)))))
      (save-excursion
        (goto-char (org-roam-node-point node))
        (org-roam-property-add "ROAM_REFS" ref-key))))

#+end_src


***** Ouvrir une url en roam

#+begin_src emacs-lisp

  (defun cp-open-node-roam-ref-url (&optional id)
    "Open the URL in this node's ROAM_REFS property, if one exists"
    (interactive)
    (when-let*
        ((roam_refs
          (progn
            (save-window-excursion
              (when (not (null id))
                (find-file (vulpea-db-get-file-by-id id)))
              (ignore-errors(split-string (org-entry-get-with-inheritance "ROAM_REFS"))))))
         (url-re
          ;; "\\b\\(\\(www\\.\\|\\(s?https?\\|ftp\\|file\\|gopher\\|nntp\\|news\\|telnet\\|wais\\|mailto\\|info\\):\\)\\(//[-a-z0-9_.]+:[0-9]*\\)?\\(?:[-a-z0-9_=#$@~%&*+\\/[:word:]!?:;.,]+([-a-z0-9_=#$@~%&*+\\/[:word:]!?:;.,]+)\\(?:[-a-z0-9_=#$@~%&*+\\/[:word:]!?:;.,]+[-a-z0-9_=#$@~%&*+\\/[:word:]]\\)?\\|[-a-z0-9_=#$@~%&*+\\/[:word:]!?:;.,]+[-a-z0-9_=#$@~%&*+\\/[:word:]]\\)\\)"
          url-handler-regexp
          )
         ref-url 
         )
      (dolist (ref roam_refs)
        (when (string-match url-re ref)
          (setq ref-url ref)))
      (browse-url ref-url)))


#+end_src




***** Deft, pour chercher dans toutes les notes d'org-roam, remplac√© par consult org-roam

#+begin_src emacs-lisp :tangle no
  (use-package deft
    :after org-roam
    :config
    (setq deft-extensions '("org")
          deft-directory org-roam-directory
          deft-recursive t
          deft-strip-summary-regexp ":PROPERTIES:\n\\(.+\n\\)+:END:\n"
          deft-use-filename-as-title t)
    )
#+end_src

***** Consult org-roam

#+begin_src emacs-lisp 
  (use-package consult-org-roam
     :config
     ;; Activate the minor-mode
     (consult-org-roam-mode 1)
     (setq consult-org-roam-grep-func #'consult-ripgrep))
#+end_src


***** Convertir les fichiers org en markdown hugo

#+begin_src emacs-lisp
  (use-package ox-hugo
    :after org org-roam
    ;; :custom
    ;;√† modifier
    ;; (org-hugo-base-dir "/home/msi/Documents/Projet/SitesWeb/braindump")
    )
#+end_src


***** Org roam ui (org roam server pour org roam v2)


La vue en bulle, comme Obsidian
Il faut que le serveur soit d√©marr√©
Se trouve √† cette adresse http://127.0.0.1:35901/ 

#+begin_src emacs-lisp

  (when termux-p
    ;; This makes Emacs in Termux use your Android browser for opening urls
    (setq browse-url-browser-function 'browse-url-xdg-open)
    )

  (use-package org-roam-ui
    :after org-roam
    :straight
    (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    ;; :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start nil)
    )

#+end_src

** Gestion des r√©f√©rences/bibliographie


#+begin_src emacs-lisp
  (setq bibtex-dialect 'biblatex)

  (setq bibtex-completion-bibliography bibliography-file-list)
  (setq bibtex-completion-library-path bibliography-library-paths)
  (setq bibtex-completion-pdf-field "File") ;; pour trouver les pdf

#+end_src


*** Gestion des insertions et de l'export
**** Ce qu'il reste √† fairepour org-cite (un jour)
:PROPERTIES:
:ID:       8aac069c-ecda-4a5f-82df-add2a7ddfdcb
:END:
   
1. trouver pour tout le temps print la bibliographie sans mettre print_bibliographie √† la fin

2. 

3.
**** Comment √ßa marche avec org-cite ?
***** Pour l'installation de zotero + extension betterbitex
:PROPERTIES:
:ID:       e254ed4d-d47b-4b9d-9155-108772b8b2c7
:END:
Cela permet d'auto exporter la biblioth√®que.

[[https://blog.tecosaur.com/tmio/2021-07-31-citations.html#using-csl][Bon site pour comprendre comment √ßa marche]]
Pour la gestion des r√©f√©rences :¬†installation de Zotero + [[https://github.com/retorquere/zotero-better-bibtex/releases/tag/v6.2.5][extension betterbibtex]] qui est sur github (voir un tuto pour l'installer)


1. In the main menu go to Tools > Add-ons
2. Select ‚ÄòExtensions‚Äô
3. Click on the gear in the top-right corner and choose ‚ÄòInstall Add-on From File‚Ä¶‚Äô
4. Choose .xpi that you‚Äôve just downloaded, click ‚ÄòInstall‚Äô
5. Restart Zotero


puis on automatise l'exportation avec l'extension !
(Fichier->exporter biblioth√®que, s√©lectionner Better BibLatex et cocher : exporter les notes et garder √† jour ! )

([[https://retorque.re/zotero-better-bibtex/exporting/auto/][ici]])

***** Pour citar et citeproc
On utilise les package citar et citeproc. Le premier pour ins√©rer les citations , le deuxi√®me pour exporter
Il faut configurer la variable de la/les biblioth√®ques.

Pour r√©sum√©, il faut juste :
# #+bibliography: references.bib ;;pas besoins car remplacer par la variable juste en dessous
# [cite:@key]
# #+print_bibliography:

Pour exporter :
# #+cite_export: csl
ou bien juste :

(Pour la conversion de org-ref √† org-cite, il suffit juste d'enlever une paire de crochet au r√©f√©rences de org-ref, puis de remplacer le "&" par "@", et de moddifier le print_biblio en 
[[bibliography:../biblio.bib] ] , logique quoi et assez simple √† faire je pense)

**** Citar, les propositions avec citar-insert-citation

#+begin_src emacs-lisp

  (use-package citar
    ;; :after all-the-icons ;; besoin des icones pour charger les propositions
    ;; :after oc-csl all-the-icons
    :custom
    ;;lieu de ma bibliographie
    (citar-bibliography bibliography-file-list)
    ;; lieu de mes fichiers pour citar
    (citar-library-paths bibliography-library-paths)
    :config
    ;; pour compl√©t√© avec consult yeah, pas besoin
    ;; (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

    ;; comment on g√®re l'affichage des propositions en dur
    (setq citar-templates
          '((main . "${author editor:30}     ${date year issued:4}     ${title:48}")
            (suffix . "          ${=key= id:15}    ${=type=:12}    ${tags keywords:*}")
            (preview . "${author editor} (${year issued date}) ${title}, ${journal journaltitle publisher container-title collection-title}.\n")
            (note . "Notes on ${author editor}, ${title}")))
    ;;le s√©parateur
    (setq citar-symbol-separator "  ")

    ;; et affichage des ic√¥nes √† gauche
    (setq citar-symbols
          `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
            (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
            (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " ")))

    ;; automatiquement refresh lorque l'on modifie la bibliographie
    (citar-filenotify-setup '(LaTeX-mode-hook org-mode-hook))

    ;;ancien et test    
    ;; (require 'filenotify)
    ;; (file-notify-add-watch "/home/utilisateur/biblio.bib"
    ;; '(attribute-change) 'citar-refresh)

    ;; (dolist (bibliography-file bibliography-file-list)
    ;; (file-notify-add-watch bibliography-file
    ;; '(attribute-change) 'citar-refresh)
    ;; )

    ;; (require 'filenotify)
    ;; (setq citar-filenotify-callback 'refresh-cache)
    ;; (citar-filenotify-setup '(LaTeX-mode-hook org-mode-hook))
    ;; (defun gen-bib-cache-idle ()
    ;; "Generate bib item caches with idle timer"
    ;; (run-with-idle-timer 0.5 nil #'citar-refresh))
    ;; (add-hook 'LaTeX-mode-hook #'gen-bib-cache-idle)
    ;; (add-hook 'org-mode-hook #'gen-bib-cache-idle)


    ;;patch pour ajouter des citations dans le mini-buffer avec le style POUR‚ÄØORG-MODE SEULEMENT‚ÄØ
    (defcustom citar-major-mode-functions
      '(((org-mode) .
         ((local-bib-files . citar-org-local-bib-files)
          (insert-citation . citar-org-insert-citation)
          (insert-edit . citar-org-insert-edit)
          (key-at-point . citar-org-key-at-point)
          (citation-at-point . citar-org-citation-at-point)
          (list-keys . citar-org-list-keys)))
        ((latex-mode) .
         ((local-bib-files . citar-latex-local-bib-files)
          (insert-citation . citar-latex-insert-citation)
          (insert-edit . citar-latex-insert-edit)
          (key-at-point . citar-latex-key-at-point)
          (citation-at-point . citar-latex-citation-at-point)
          (list-keys . reftex-all-used-citation-keys)))
        ((markdown-mode) .
         ((insert-keys . citar-markdown-insert-keys)
          (insert-citation . citar-markdown-insert-citation)
          (insert-edit . citar-markdown-insert-edit)
          (key-at-point . citar-markdown-key-at-point)
          (citation-at-point . citar-markdown-citation-at-point)
          (list-keys . citar-markdown-list-keys)))

        ;;patch d√©but ici
        ((minibuffer-mode) .
         ( (insert-citation . citar-org-insert-citation)
           ))
        ;;patch fin ici

        (t .
           ((insert-keys . citar--insert-keys-comma-separated))))
      "The variable determining the major mode specific functionality.

                  It is alist with keys being a list of major modes.

                  The value is an alist with values being functions to be used for
                  these modes while the keys are symbols used to lookup them up.
                  The keys are:

                  local-bib-files: the corresponding functions should return the list of
                  local bibliography files.

                  insert-keys: the corresponding function should insert the list of keys given
                  to as the argument at point in the buffer.

                  insert-citation: the corresponding function should insert a
                  complete citation from a list of keys at point.  If the point is
                  in a citation, new keys should be added to the citation.

                  insert-edit: the corresponding function should accept an optional
                  prefix argument and interactively edit the citation or key at
                  point.

                  key-at-point: the corresponding function should return the
                  citation key at point or nil if there is none.  The return value
                  should be (KEY . BOUNDS), where KEY is a string and BOUNDS is a
                  pair of buffer positions indicating the start and end of the key.

                  citation-at-point: the corresponding function should return the
                  keys of the citation at point, or nil if there is none.  The
                  return value should be (KEYS . BOUNDS), where KEYS is a list of
                  strings and BOUNDS is pair of buffer positions indicating the
                  start and end of the citation.

                  list-keys: the corresponding function should return the keys
                  of all citations in the current buffer."
      :group 'citar
      :type 'alist)
    )

#+end_src

**** Pour les exports
:PROPERTIES:
:ID:       7ebb8fdb-0d07-4b8d-b86a-9d8cf2109848
:END:

#+begin_src emacs-lisp

  (use-package citeproc
    :straight (:host github :repo "andras-simonyi/citeproc-el")
    :after citar

    :init
    ;; nom du titre export√© pour la bibliographie
    (with-eval-after-load 'ox-hugo
      (plist-put org-hugo-citations-plist :bibliography-section-heading "References"))

    :config
    
    (setq org-cite-global-bibliography bibliography-file-list) ;; pour que org-cite sache o√π est ma biblio


    (require 'oc-csl)
    (setq org-cite-export-processors '((t csl)));; exporter tout le temps avec la m√©thode csl

    ;; les fichiers de configuration. Impossible de les configurer "normalement" (voir en dessous), j'utilise donc les fichiers "fallback" qui sont ceux par d√©faut
    ;; (setq org-cite-csl--fallback-style-file "/home/msi/documents/notes/braindump/org/chicago-author-date-16th-edition.csl") ;;

    (setq org-cite-csl--fallback-locales-dir bibliography-directory)
    (setq org-cite-csl--fallback-style-file (concat bibliography-directory "vancouver-brackets.csl"));;¬†pour changer le style. Vancouver = num√©ro

    )

  ;;le bordel ici, mais pas utilis√©
  ;; pas utilis√©, mais voir aussi les variable de jethro
  ;; (setq
  ;; org-cite-global-bibliography my-bibliography-list ;; pour que org-cite sache o√π est ma biblio
  ;; citar-format-reference-function 'citar-citeproc-format-reference
  ;; org-cite-csl-styles-dir "~/Zotero/styles/"
  ;; citar-citeproc-csl-styles-dir org-cite-csl-styles-dir
  ;; citar-citeproc-csl-locales-dir "~/Zotero/locales/"

  ;; doute sur lui, voir le dot de jethro
  ;; citar-citeproc-csl-style (concat (expand-file-name org-cite-csl-styles-dir
  ;; )"apa.csl")

  ;;pour que √ßa marche, il faut r√©gler ces deux variables
  ;; apr√®s avoir ex√©cut√© ceci, les export marches TODO
  ;; org-cite-csl--fallback-style-file "/home/msi/documents/notes/braindump/org/reference/chicago-author-date-16th-edition.csl"
  ;; org-cite-csl--fallback-locales-dir "/home/msi/documents/notes/braindump/org/reference"
  ;; )

  ;; (setq org-cite-csl-styles-dir "~/Zotero/styles/")
  ;; (setq org-cite-csl-locales-dir "/home/msi/documents/notes/braindump/org/reference/")

#+end_src

*** Modifications des r√©f√©rences
**** Pour g√©n√©rer des cl√©es proprements

#+begin_src emacs-lisp
  (setq bibtex-autokey-year-length 4
        bibtex-autokey-name-year-separator "-"
        bibtex-autokey-year-title-separator "-"
        bibtex-autokey-titleword-separator "-"
        bibtex-autokey-titlewords 2
        bibtex-autokey-titlewords-stretch 1
        bibtex-autokey-titleword-length 5)
#+end_src

**** Pour avoir une interface clean de modification 
#+begin_src emacs-lisp
  (use-package ebib
    :config
    (setq ebib-bibtex-dialect 'biblatex
          ebib-preload-bib-files bibliography-file-list

          ebib-link-file-path-type 'adaptive

          ebib-truncate-file-names t ;; pour pas couper le nom des fichiers
          ebib-default-directory "/home/utilisateur/.emacs.d/config/dossierCitation/"
          ebib-file-search-dirs bibliography-library-paths

          ebib-file-associations nil ;; pour ouvrir pdf ou autre. Si rien, alors fait juste un "find-file", donc parfait

          )

    (define-key ebib-index-mode-map [remap next-line] #'ebib-next-entry)
    (define-key ebib-index-mode-map [remap previous-line] #'ebib-prev-entry)

    (define-key ebib-entry-mode-map [remap next-line] #'ebib-next-field)
    (define-key ebib-entry-mode-map [remap previous-line] #'ebib-prev-field)

    )

  (use-package parsebib
    :straight (parsebib
               :type git
               :host github
               :repo "joostkremers/parsebib")
    )
#+end_src
**** Pour permettre de clean proprement une entry

T√©l√©charge le pdf et autre choses



#+begin_src emacs-lisp

  ;; juste pour la fonction org-ref-clean-bibtex-entry
  (use-package org-ref
    :config
    (setq org-ref-bibtex-pdf-download-dir (car bibliography-library-paths))

    (setq org-ref-clean-bibtex-entry-hook
          '(org-ref-bibtex-format-url-if-doi
            orcb-key-comma
            ;; org-ref-replace-nonascii ;; pour que les accents ne reste pas
            orcb-&
            orcb-%
            org-ref-title-case-article
            orcb-clean-year
            orcb-key
            orcb-clean-doi
            orcb-clean-pages
            orcb-check-journal
            org-ref-sort-bibtex-entry
            orcb-fix-spacing
            orcb-download-pdf
            org-ref-stringify-journal-name
            ))


    (setq org-ref-bibtex-sort-order
          '(("article"  . ("author" "title" "journal" "volume" "number" "pages" "year" "doi" "url"))
            ("inproceedings" . ("author" "title" "booktitle" "year" "volume" "number" "pages" "doi" "url"))
            ("book" . ("author" "title" "year" "publisher" "url"))
            ("online" . ("author" "title" "booktitle" "year" "volume" "number" "pages" "doi" "url"))
            ))

    ;;d√©pendence non charg√©

    (use-package async)

    ;; corrections

    (defun orcb-check-journal ()
      "Check entry at point to see if journal exists in `org-ref-bibtex-journal-abbreviations'.
              If not, issue a warning."
      (interactive)
      (bibtex-beginning-of-entry) ;;moddif ici
      (when
          (string= "article"
                   (downcase
                    (cdr (assoc "=type=" (bibtex-parse-entry)))))
        (save-excursion
          (bibtex-beginning-of-entry)
          (let* ((entry (bibtex-parse-entry t))
                 (journal (or (cdr (assoc "journal" entry)) (cdr (assoc "journaltitle" entry)))))  ;;moddif ici condition
            (when (null journal)
              (warn "Unable to get journal for this entry."))
            (unless (member journal (-flatten org-ref-bibtex-journal-abbreviations))
              (message "Journal \"%s\" not found in org-ref-bibtex-journal-abbreviations." journal))))))

    ;;   ;;check tjr les cl√©es
    ;;   (defun orcb-key (&optional allow-duplicate-keys)
    ;;     "Replace the key in the entry.
    ;; Prompts for replacement if the new key duplicates one already in
    ;; the file, unless ALLOW-DUPLICATE-KEYS is non-nil."
    ;;     (let ((key (funcall org-ref-clean-bibtex-key-function
    ;;                         (bibtex-generate-autokey))))
    ;;       ;; remove any \\ in the key
    ;;       (setq key (replace-regexp-in-string "\\\\" "" key))
    ;;       ;; first we delete the existing key
    ;;       (bibtex-beginning-of-entry)
    ;;       (re-search-forward bibtex-entry-maybe-empty-head)
    ;;       (if (match-beginning bibtex-key-in-head)
    ;;           (delete-region (match-beginning bibtex-key-in-head)
    ;;                          (match-end bibtex-key-in-head)))
    ;;       ;; check if the key is in the buffer


    ;;       (message "salut %s %s %s" (not allow-duplicate-keys) key
    ;;                    (bibtex-search-entry key nil nil))

    ;;       (when (and (not allow-duplicate-keys)
    ;;                  (save-excursion

    ;;                    (bibtex-search-entry key)))

    ;;         (save-excursion
    ;;           (bibtex-search-entry key)
    ;;           (bibtex-copy-entry-as-kill)
    ;;           (switch-to-buffer-other-window "*duplicate entry*")
    ;;           (bibtex-yank))
    ;;         (setq key (bibtex-read-key "Duplicate Key found, edit: " key)))

    ;;       (insert key)
    ;;       (kill-new key)))

(defun bibtex-autokey-get-year ()
  "Return year field contents as a string obeying `bibtex-autokey-year-length'."
  (let* ((str (bibtex-autokey-get-field '("date" "year"))) ; possibly ""
         (year (or (and (iso8601-valid-p str)
                        (let ((year (decoded-time-year (iso8601-parse str))))
                          (and year (number-to-string year))))
                   ;; BibTeX permits a year field "(about 1984)", where only
                   ;; the last four nonpunctuation characters must be numerals.
                   (and (string-match "\\([0-9][0-9][0-9][0-9]\\)[^[:alnum:]]*\\'" str)
                        (match-string 1 str))
                   (user-error "Year or date field `%s' invalid" str))))
    (substring year (max 0 (- (length year) bibtex-autokey-year-length)))))
    
    )



#+end_src

*** Connection entre org-roam et citar et biblatex

orb-note-actions orb-edit-citation-note

#+begin_src emacs-lisp

  (use-package org-roam-bibtex
    :config 

    (setq citar-open-note-functions '(orb-citar-edit-note))
    ;; (setq citar-notes-paths nil) ;; si jamais je ne configure pas citar-open-note-functions
    (setq orb-citekey-format 'org-cite) ;; pour @key

    (setq orb-preformat-keywords
          '("citekey" "title" "url" "author-or-editor" "keywords" "file")
          orb-process-file-keyword t
          orb-attached-file-extensions '("pdf"))

    )

#+end_src

*** M√©thode pour ajouter des r√©f√©rences aux bibfiles
**** Via quelque chose qui permet de l'identifier

#+begin_src emacs-lisp
  (use-package biblio
    :config
    (setq biblio-download-directory (car bibliography-library-paths))
    )

#+end_src
**** Traducteur zotero

Pour faire ceci :

#+begin_src sh

  # installation de node js
  curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
  sudo apt-get install -y nodejs

  # installation du traducteur
  git clone --recurse-submodules https://github.com/zotero/translation-server
  cd translation-server
  npm install

  # lancer le serveur de traducteur (√† chaque fois)(doit etre dans le dossier github t√©l√©charg√© pr√©c√©demment)
  npm start

#+end_src


#+begin_src emacs-lisp

  (defun lancer-serveur-zotra()
    (interactive)
    (async-shell-command
     (concat
      "cd && cd .emacs.d/config/dossierCitation/translation-server/"
      " && npm start"
      ))
    )

  (unless termux-p (lancer-serveur-zotra))

  (use-package zotra
    :straight (zotra
               :type git
               :host github
               :repo "mpedramfar/zotra")
    :config

    (add-hook 'zotra-after-add-entry-hook 'org-ref-clean-bibtex-entry)

    (setq zotra-default-entry-format "biblatex")
    (setq zotra-default-bibliography (car bibliography-file-list))
    (setq zotra-url-retrieve-timeout 5) ;; plus de temps pour les demandes
    )

#+end_src
*** TODO Drag and drop des pdf

[[https://github.com/rougier/pdf-drop-mode][ici]]

** Pr√©sentation avec org-mode

#+begin_src emacs-lisp

  (use-package visual-fill-column)

  (use-package org-present
    :config

    (defun my/org-present-prepare-slide (buffer-name heading)
      ;; Show only top-level headlines
      (org-overview)

      ;; Unfold the current entry
      (org-show-entry)

      ;; Show only direct subheadings of the slide but don't expand them
      (org-show-children))

    (defun my/org-present-start ()
      ;; Tweak font sizes
      (setq-local face-remapping-alist '(
                                         ;; (default (:height 1.5) variable-pitch)
                                         ;; ;;provoque tr√®s sur les images
                                         (header-line (:height 4.0) variable-pitch)
                                         (org-document-title (:height 1.75) org-document-title)
                                         (org-code (:height 1.55) org-code)
                                         (org-verbatim (:height 1.55) org-verbatim)
                                         (org-block (:height 1.25) org-block)
                                         (org-block-begin-line (:height 0.7)
                                                               org-block)))

      ;; (setq-local org-image-actual-width 1500) ;; r√©gl√© directement au niveau des images

      ;; Set a blank header line string to create blank space at the top
      (setq header-line-format " ")
      ;; (setq org-ellipsis "ÔÑá")

      ;;joli √©cri
      (variable-pitch-mode 1)

      ;; Display inline images automatically
      (org-display-inline-images)

      (hide-mode-line-mode)
      (toggle-frame-fullscreen)
      (set-frame-parameter (selected-frame) 'alpha '(90 . 100))

      ;; Center the presentation and wrap lines
      (setq visual-fill-column-width 150)
      (setq visual-fill-column-center-text t)
      (visual-fill-column-mode 1)
      (visual-line-mode 1))

    (defun my/org-present-end ()
      ;; Reset font customizations
      (setq-local face-remapping-alist '((default variable-pitch default)))

      ;; Clear the header line string so that it isn't displayed
      (setq header-line-format nil)

      (variable-pitch-mode -1)

      ;; Stop displaying inline images
      (org-remove-inline-images)

      (hide-mode-line-mode -1)
      (set-frame-parameter (selected-frame) 'alpha '(100 . 100))
      (toggle-frame-fullscreen)
      ;; Stop centering the document
      (setq visual-fill-column-width nil)
      (setq visual-fill-column-center-text nil)
      (visual-fill-column-mode 0)
      (visual-line-mode 0))

    ;; Turn on variable pitch fonts in Org Mode buffers
    ;; (add-hook 'org-mode-hook 'variable-pitch-mode)

    ;; Register hooks with org-present
    (add-hook 'org-present-mode-hook 'my/org-present-start)
    (add-hook 'org-present-mode-quit-hook 'my/org-present-end)
    (add-hook 'org-present-after-navigate-functions 'my/org-present-prepare-slide)
    ;; (remove-hook 'org-present-after-navigate-functions 'my/org-present-prepare-slide)

    ;; null. fonction √† faire :
    (defun cp/org-present-next-heading ()
      "Jump to next top-level heading."
      (interactive)

      ;; (widen)
      (if (org-current-level)	      ;;‚ÄØinside heading
          (if (= (org-current-level) 1) ;;inside heading 1
              (progn
                (outline-next-heading)
                (recenter)
                (org-show-subtree))
    ;if that was last, go back to top before narrow
            ;; else go to children
            (if (org-get-next-sibling)
                (progn
                  (recenter)
                  (outline-show-children)
                  (outline-show-entry))
              (progn
                (widen)
                (outline-next-heading)
                (org-present-narrow)
                (org-present-run-after-navigate-functions))))
        (org-present-next)))

    ;; d√©sactiver le hook de system crafter pour faire la fonction. il faut donc : si titre 0, alors go titre 1. Si titre 1, alors allez au prochain
    ;; titre 2 et le d√©plier. doit √™tre en haut. puis, deux choix :‚ÄØsoit pas de
    ;; fils. donc, on passe au prochain titre 2. soit, il a un fils. donc, on
    ;; plie les pr√©c√©dents et on affiche titre 3. puis deux solution, soit etc.

    )
#+end_src

** Gestion de mon CV avec org-mode

#+begin_src emacs-lisp

  ;; deleted unwanted file extensions after latex export
  (setq
   org-latex-remove-logfiles t
   org-latex-logfiles-extensions
   (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "xmpi" "run.xml" "bcf" "acn" "acr" "alg" "glg" "gls" "ist")))


  (setq org-latex-packages-alist 'nil)
  ;; (setq org-latex-default-packages-alist
  ;; '(("rm" "roboto"  t)
  ;; ("defaultsans" "lato" t)
  ;; ("" "paracol" t)))
  ;; mettre ceci dans le document plutot :
  ;;#+LATEX_HEADER: \usepackage{paracol}
  ;;#+LATEX_HEADER: \usepackage{lato}
  ;;#+LATEX_HEADER: \usepackage{roboto}

  (use-package org-contrib
    :config
    (require 'ox-extra)
    (use-package ox-extra
      :config
      (ox-extras-activate '(latex-header-blocks ignore-headlines))))


  (add-to-list 'org-latex-classes
               '("altacv" "\\documentclass[10pt,a4paper,ragged2e,withhyper]{altacv}

            % Change the page layout if you need to
            \\geometry{left=1.25cm,right=1.25cm,top=1.5cm,bottom=1.5cm,columnsep=1.2cm}

            % Use roboto and lato for fonts
            \\renewcommand{\\familydefault}{\\sfdefault}

            % Change the colours if you want to
            \\definecolor{SlateGrey}{HTML}{2E2E2E}
            \\definecolor{LightGrey}{HTML}{666666}
            \\definecolor{DarkPastelRed}{HTML}{450808}
            \\definecolor{PastelRed}{HTML}{8F0D0D}
            \\definecolor{GoldenEarth}{HTML}{E7D192}
            \\colorlet{name}{black}
            \\colorlet{tagline}{PastelRed}
            \\colorlet{heading}{DarkPastelRed}
            \\colorlet{headingrule}{GoldenEarth}
            \\colorlet{subheading}{PastelRed}
            \\colorlet{accent}{PastelRed}
            \\colorlet{emphasis}{SlateGrey}
            \\colorlet{body}{LightGrey}

            % Change some fonts, if necessary
            \\renewcommand{\\namefont}{\\Huge\\rmfamily\\bfseries}
            \\renewcommand{\\personalinfofont}{\\footnotesize}
            \\renewcommand{\\cvsectionfont}{\\LARGE\\rmfamily\\bfseries}
            \\renewcommand{\\cvsubsectionfont}{\\large\\bfseries}

            % Change the bullets for itemize and rating marker
            % for \cvskill if you want to
            \\renewcommand{\\itemmarker}{{\\small\\textbullet}}
            \\renewcommand{\\ratingmarker}{\\faCircle}
            "

                 ("\\cvsection{%s}" . "\\cvsection*{%s}")))


#+end_src

** Gestion de ma lettre de motivation avec org-mode


#+begin_src emacs-lisp :tangle no
  (eval-after-load 'ox '(require 'ox-koma-letter))
  (eval-after-load 'ox-koma-letter
    '(progn
       (add-to-list 'org-latex-classes
                    '("my-letter"
                      "\\documentclass\{scrlttr2\}
       \\usepackage[english]{babel}
       \\setkomavar{frombank}{(1234)\\,567\\,890}
       \[DEFAULT-PACKAGES]
       \[PACKAGES]
       \[EXTRA]"))

       (setq org-koma-letter-default-class "my-letter")))

  (eval-after-load 'ox-latex
    '(add-to-list 'org-latex-packages-alist '("AUTO" "babel" t) t))

  (setq org-latex-packages-alist '(("AUTO" "babel" t)))

#+end_src


** Gestion des flashcards


*** brutes
#+begin_src emacs-lisp

  (use-package anki-editor
    :straight (anki-editor
               :type git
               :host github
               :repo "louietan/anki-editor"))

  (use-package org-anki)

#+end_src

*** dans le texte directement

#+begin_src emacs-lisp
  
  ;; (use-package org-mode-incremental-reading
  ;;   :straight (incremental-reading
  ;;             :type git
  ;;             :host github
  ;;             :repo "vascoferreira25/org-mode-incremental-reading"))

  (straight-use-package '(org-mode-incremental-reading
                          :host github
                          :repo "vascoferreira25/org-mode-incremental-reading"))
#+end_src
