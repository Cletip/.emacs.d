

Ici, je veux utiliser org mode.

Par contre, mon second cerveau utilise une partie d'org-mode et org-roam.
J'active donc les parties de org-mode qd il faut, et org-roam seulement si ya mon braindump


* Config + code final

** Variables de chemins et autres utile dans tous les cas
*** Lieu de mon dossier org-directory (tout se base sur lui)

#+begin_src emacs-lisp
  (setq org-directory (expand-file-name "org/" braindump-directory))
#+end_src

*** Lieu du org-roam-directory

#+begin_src emacs-lisp
(setq org-roam-directory org-directory)
#+end_src

*** Lieu de mon dossier de bibliographie

#+begin_src emacs-lisp

  (setq bibliography-directory (expand-file-name "dossierCitation/" config-directory))
  ;; (setq my-bibliography-list (list (expand-file-name "dossierCitation/biblio.bib" bibliography-directory)
  ;; "/path/to/another/"
  ;; "/path/to/another/"
  ;; ))

  (setq bibliography-file-list (list
                                (concat bibliography-directory "biblio.bib")
                                ;; "test"
                                ))


  ;; où sont mes fichiers
  (setq bibliography-library-paths (list
                                (concat bibliography-directory "fichiers/")
                                ;; "test"
                                ))

#+end_src

** La bibliothèque d'automatisations des choses (à placer tôt) 


À mettre à un endroit (org-roam-db-sync 'force) pour termux automatiquement ? non

#+begin_src emacs-lisp
  (use-package vulpea
    :if braindump-exists
    :straight (vulpea
               :type git
               :host github
               :repo "d12frosted/vulpea")
    ;; hook into org-roam-db-autosync-mode you wish to enable
    ;; persistence of meta values (see respective section in README to
    ;; find out what meta means)
    :hook ((org-roam-db-autosync-mode . vulpea-db-autosync-enable))
    :config
    (defun org-roam-vulpea-bdd ()
      (interactive)
      "Mets à jour la bdd pour l'utilisation de velpua"
      (org-roam-db-sync 'force)
      )
    )
  (require 'vulpea);;sinon ne charge pas tout je comprends pas pk

  (advice-add 'org-transclusion-add :before #'org-id-update-id-locations)


#+end_src


** Org-mode

*** Choses toujours présentes (pour l'édition n'importe où notamment)
**** Optimisation de bases
***** Les TODO en done quand tous les sous arbres sont done


Bug, car provoque les logs de state dans le titre au début. Devrait être réglé avec ce thread : 
https://mail.gnu.org/archive/html/emacs-orgmode/2022-07/msg00065.html

#+begin_src emacs-lisp :tangle no

  (defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all subentries are done, to TODO otherwise."
    (let (org-log-done org-log-states)   ; turn off logging
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)


#+end_src

Pour les checkbox
    #+begin_src emacs-lisp
      
            (defun my/org-checkbox-todo ()
              "Switch header TODO state to DONE when all checkboxes are ticked, to TODO otherwise"
              (let ((todo-state (org-get-todo-state)) beg end)
                (unless (not todo-state)
                  (save-excursion
                (org-back-to-heading t)
                (setq beg (point))
                (end-of-line)
                (setq end (point))
                (goto-char beg)
                (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                               end t)
                    (if (match-end 1)
                    (if (equal (match-string 1) "100%")
                        (unless (string-equal todo-state "DONE")
                          (org-todo 'done))
                      (unless (string-equal todo-state "TODO")
                        (org-todo 'todo)))
                      (if (and (> (match-end 2) (match-beginning 2))
                           (equal (match-string 2) (match-string 3)))
                      (unless (string-equal todo-state "DONE")
                        (org-todo 'done))
                    (unless (string-equal todo-state "TODO")
                      (org-todo 'todo)))))))))

      (add-hook 'org-checkbox-statistics-hook 'my/org-checkbox-todo)

    #+end_src

***** Better templates / <el shortcutt

Now, you can type "<el or <sh" then "tab", and let's go for org-babel !


#+begin_src emacs-lisp
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
  (add-to-list 'org-structure-template-alist '("cd" . "src C"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
  (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
  (add-to-list 'org-structure-template-alist '("json" . "src json"))
  
#+end_src

***** TODO Pour insérer du sons + Jouer un son quand Done

#+begin_src emacs-lisp :tangle no

  ;; pour insérer un son
  (use-package emms)
  (emms-all)
  (emms-default-players)
  ;; (setq emms-source-file-default-directory "~/Notes/Roam/sounds")
  (use-package org-emms)

  ;; pour le done
  (defun my-org-after-todo-state-change ()
    (when (string-equal org-state "DONE")
      (org-clock-out-if-current)
      (emms-add-file "~/.emacs.d/sound/done.mp3")
      (emms-start)
      ;; (emms-play-file "/home/msi/.emacs.d/sound/done.mp3")
      )
    )

  (add-hook 'org-after-todo-state-change-hook 'my-org-after-todo-state-change)


#+end_src
***** Pour avoir une barre de navigation sur le côté

#+begin_src emacs-lisp

    (use-package org-sidebar)
      
#+end_src
***** Pour insérer un nouveau titre comme le précédent visible 

Si je fait avec C-u, alors org-insert-heading !

#+begin_src emacs-lisp :tangle no

  ;;chargement d'une bibliothèque
  ;; (add-to-list 'org-modules 'org-fold)

  (defun org-meta-return (&optional arg)
    "Insert a new heading or wrap a region in a table.
    Calls `org-insert-heading', `org-insert-item' or
    `org-table-wrap-region', depending on context.  When called with
    an argument, unconditionally call `org-insert-heading'."
    (interactive "P")
    ;; (org-fold-check-before-invisible-edit 'insert)
    (or (run-hook-with-args-until-success 'org-metareturn-hook)
        (call-interactively (cond (arg #'org-insert-heading)
                                  (current-prefix-arg #'org-insert-heading)
                                  ((org-at-table-p) #'org-table-wrap-region)
                                  ((org-in-item-p) #'org-insert-item)
                                  (t #'org-insert-heading-after-current)))))

#+end_src

***** Ne pas éditer qd le heading est plié

#+begin_src emacs-lisp
(setq-default org-catch-invisible-edits nil)
#+end_src

***** Pas plier des heading vide

#+begin_src emacs-lisp
  (setq org-cycle-separator-lines -1)
#+end_src

***** Avoir des liste avec l'alphabet

#+begin_src emacs-lisp
  (setq org-list-allow-alphabetical t)
#+end_src

***** Laisser une ligne vide entre les titres org-mode

#+begin_src emacs-lisp
  (setq org-blank-before-new-entry
 '((heading . t)
   (plain-list-item . auto)))
#+end_src

***** Cacher les properties drawer

#+begin_src emacs-lisp :tangle no
  (defun org-cycle-hide-drawers (state)
      "Re-hide all drawers after a visibility state change."
      (interactive)
      (when (and (derived-mode-p 'org-mode)
                 (not (memq state '(overview folded contents))))
        (save-excursion
          (let* ((globalp (memq state '(contents all)))
                 (beg (if globalp
                        (point-min)
                        (point)))
                 (end (if globalp
                        (point-max)
                        (if (eq state 'children)
                          (save-excursion
                            (outline-next-heading)
                            (point))
                          (org-end-of-subtree t)))))
            (goto-char beg)
            (while (re-search-forward org-drawer-regexp end t)
              (save-excursion
                (beginning-of-line 1)
                (when (looking-at org-drawer-regexp)
                  (let* ((start (1- (match-beginning 0)))
                         (limit
                           (save-excursion
                             (outline-next-heading)
                               (point)))
                         (msg (format
                                (concat
                                  "org-cycle-hide-drawers:  "
                                  "`:END:`"
                                  " line missing at position %s")
                                (1+ start))))
                    (if (re-search-forward "^[ \t]*:END:" limit t)
                      (outline-flag-region start (point-at-eol) t)
                      (user-error msg))))))))))
#+end_src

**** Esthétique d'org-mode
***** Petite bulles des titres

#+begin_src emacs-lisp 

    ;; (use-package org-bullets
    ;; :after org
    ;; :hook(org-mode . org-bullets-mode)
    ;; :config

    ;; (setq org-bullets-bullet-list '("◉" "✸" "☯" "✿" "✜" "◆" "▶"))
    ;; (setq org-bullets-bullet-list '("◉" "○" "✸" "✜" "◆" "▶"))
    ;; )

  (use-package org-superstar
      :after org
      :hook (org-mode . org-superstar-mode)
      :config
      (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✜" "◆" "▶"))
        ;; (set-face-attribute 'org-superstar-header-bullet nil :inherit 'fixed-pitched :height 200)
      
      ;; :custom
      ;; set the leading bullet to be a space. For alignment purposes I use an em-quad space (U+2001)
      ;; (org-superstar-headline-bullets-list '(" "))
      ;; (org-superstar-todo-bullet-alist '(("DONE" . ?✔)
                                         ;; ("TODO" . ?⌖)
                                         ;; ("NEXT" . ?)
                                         ;; ("ISSUE" . ?)
                                         ;; ("BRANCH" . ?)
                                         ;; ("FORK" . ?)
                                         ;; ("MR" . ?)
                                         ;; ("MERGED" . ?)
                                         ;; ("GITHUB" . ?A)
                                         ;; ("WRITING" . ?✍)
                                         ;; ("WRITE" . ?✍)
                                         ;; ))
      ;; (org-superstar-special-todo-items t)
      ;; (org-superstar-leading-bullet "")

      )







#+end_src

***** Org emphasis (surligné, souligné etc)
****** Couleurs
#+begin_src emacs-lisp 

  (setq org-emphasis-alist
	'(("*" bold)
	  ("/" italic)
	  ("_" underline)
	  ("=" (:foreground "yellow")) ;;on ne peut pas surligner lors de l'export
	  ("~" org-code verbatim)
	  ("+" (:strike-through t))))

  (defface my-org-emphasis-bold
    '((default :inherit bold)
      (((class color) (min-colors 88) (background light))
       :foreground "#a60000")
      (((class color) (min-colors 88) (background dark))
       :foreground "#ff8059"))
    "My bold emphasis for Org.")

  (defface my-org-emphasis-italic
    '((default :inherit italic)
      (((class color) (min-colors 88) (background light))
       :foreground "#005e00")
      (((class color) (min-colors 88) (background dark))
       :foreground "#44bc44"))
    "My italic emphasis for Org.")

  (defface my-org-emphasis-underline
    '((default :inherit underline)
      (((class color) (min-colors 88) (background light))
       :foreground "#813e00")
      (((class color) (min-colors 88) (background dark))
       :foreground "#d0bc00"))
    "My underline emphasis for Org.")

  (defface my-org-emphasis-strike-through
    '((((class color) (min-colors 88) (background light))
       :strike-through "#972500" :foreground "#505050")
      (((class color) (min-colors 88) (background dark))
       :strike-through "#ef8b50" :foreground "#a8a8a8"))
    "My strike-through emphasis for Org.")


#+end_src

****** Pour voir directement les liens, faire disparaître l'emphasis

#+begin_src emacs-lisp 

  (setq org-hide-emphasis-markers t)
  (straight-use-package '(org-appear :type git :host github :repo "awth13/org-appear"))
  (add-hook 'org-mode-hook 'org-appear-mode)

  ;;affiche les liens entier avec t
  ;; (setq org-appear-autolinks t)

#+end_src

***** Org font (police et taille des titres et checkbox)

Tout se trouve dans .dotfiles/.fonts

#+begin_src emacs-lisp

  ;;Pour obtenir des polices proportionnelles
  ;; (variable-pitch-mode 1)

  ;; Make sure org-indent face is available

  (require 'org-indent)

  (set-face-attribute 'org-document-title nil :font "Fira Mono" :weight 'bold :height 1.5)
  (dolist (face '((org-level-1 . 1.3)
                  (org-level-2 . 1.25)
                  (org-level-3 . 1.20)
                  (org-level-4 . 1.15)
                  (org-level-5 . 1.10)
                  (org-level-6 . 1.05)
                  (org-level-7 . 1.0)
                  (org-level-8 . 1.0)))
    ;; (set-face-attribute (car face) nil :font "JetBrains Mono" :weight 'medium :height (cdr face))
    (set-face-attribute (car face) nil :font "Fira Mono" :weight 'medium :height (cdr face))
    )


  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
  (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

  ;;couleur des checkbox
  (defface org-checkbox-todo-text
    '((t (:inherit org-todo)))
    "Face for the text part of an unchecked org-mode checkbox.")

  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?: \\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-checkbox-todo-text prepend))
   'append)

  (defface org-checkbox-done-text
    '((t (:inherit org-done)))
    "Face for the text part of a checked org-mode checkbox.")

  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-checkbox-done-text prepend))
   'append)

#+end_src
***** Nouveau symbole à fin de titres

#+begin_src emacs-lisp

  (setq org-ellipsis "⬎")

  ;; (setq org-ellipsis " ")

#+end_src

***** Voir directement les images + leur ajuster leur taille

#+begin_src emacs-lisp
    (setq org-startup-with-inline-images t)
    (setq org-image-actual-width '(800)) ;; dans une liste. voir la doc string. comme cela, je peux me servir de #+ATTR_ORG: :width 1000 ce qui est cool. un nombre simple écrase tout, une liste est le fallback
  ;;  (setq org-image-actual-width (* (display-pixel-width) 0.8))
  (setq shr-max-image-proportion 0.9) ;; proportion de l'image prise au max. pas sûr que cela marche
#+end_src

***** Voir les prévisualisations de latex 

#+BEGIN_SRC emacs-lisp   
      (use-package org-fragtog
    :hook (org-mode . org-fragtog-mode)
    :config
    ;;taille du latex
    (plist-put org-format-latex-options :scale 1.5))
#+END_SRC

***** Indente automatiquement en fonction des titres (attention, que visuel)

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
  (diminish org-indent-mode)
#+end_src


***** Jolie icones, ne marche pas chez moi (si mais fait buguer les icônes de dired)

#+begin_src emacs-lisp :tangle no

  (defun org-icons+todoicons ()
	   "Beautify org mode keywords."
	   (interactive)
	   (setq prettify-symbols-alist '(
					  ("TODO" . "")
					  ("PEUT-ÊTRE" . "")
					  ("EN-COURS" . "")
					  ("ANNULÉ" . "")
					  ("DONE" . "")
					  ("[#A]" . "")
					  ("[#B]" . "")
					  ("[#C]" . "")
					  ("-" . "➤")
					  ("[ ]" . "")
					  ("[X]" . "")
					  ("[-]" . "")
					  ("#+begin_src" . ?)
					  ("#+BEGIN_SRC" . ?)
					  ("#+end_src" . ?)
					  ("#+END_SRC" . ?)
					  (":PROPERTIES:" . "")
					  (":END:" . "―")
					  ("#+STARTUP:" . "")
					  ("#+TITLE: " . "")
					  ("#+RESULTS:" . "")
					  ("#+NAME:" . "")
					  (":ROAM_ALIASES:" . "")
					  ("#+FILETAGS:" . "")
					  ("#+HTML_HEAD:" . "")
					  ("#+SUBTITLE:" . "")
					  ("#+AUTHOR:" . "")
					  (":Effort:" . "")
					  ("SCHEDULED:" . "")
					  ("DEADLINE:" . "")
					  ))
	   (prettify-symbols-mode)
	   (magic-icon-fix)
	   )

  (defun magic-icon-fix ()
      (interactive)
	(let ((fontset (face-attribute 'default :fontset)))
	      (set-fontset-font fontset '(?\xf000 . ?\xf2ff) "FontAwesome" nil 'append)))



#+end_src

***** TODO Pour mettres les jolis tags :

#+begin_src emacs-lisp :tangle no

(use-package org-pretty-tags
  :config
   (setq org-pretty-tags-surrogate-strings
	 (quote
	  (("@office" . "✍")
	   ("PROJEKT" . "💡")
	   ("SERVICE" . "✍")
	   ("Blog" . "✍")
	   ("music" . "♬")
	   )))
   (org-pretty-tags-global-mode))

#+end_src

**** Pour coder dans org (org-babel)
***** Les langages chargé par org-babel

Do not load all to booste the startup time 

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     ;; (ditaa      . t)
     (C          . t)
     ;; (dot        . t)
     (emacs-lisp . t)
     ;; (scheme     . t)
     ;; (gnuplot    . t)
     ;; (haskell    . t)
     (latex      . t)
     ;; (js         . t)
     ;; (ledger     . t)
     ;; (matlab     . t)
     ;; (ocaml      . t)
     ;; (octave     . t)
     ;; (plantuml   . t)
     (python     . t)
     ;; (R          . t)
     ;; (ruby       . t)
     ;; (screen     . nil)
     ;; (scheme     . t)
     (shell      . t)
     (sql        . t)
     (sqlite     . t)
     (java     . t)
     (js . t) ;;javascripts
     )
   )

(setq org-babel-python-command "python3")

#+end_src
***** Annulation de la demande de confirmation lors de la demande d'évaluation du code
#+begin_src emacs-lisp 
  (setq org-confirm-babel-evaluate nil)
#+end_src
***** Indente le code selon le language
Dans les blocs de code, on veut la mise en évidence de syntaxe, et l'on
utilise la touche TAB pour indenter (et non pour insérer une tabulation)

#+begin_src emacs-lisp 
  (setq org-src-tab-acts-natively t)
#+end_src

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

***** Permet de gérer l'erreur des parenthèse quand il y a un "<"

#+begin_src emacs-lisp
  
  (defun org-mode-<>-syntax-fix (start end)
    "Change syntax of characters ?< and ?> to symbol within source code blocks."
    (let ((case-fold-search t))
      (when (eq major-mode 'org-mode)
        (save-excursion
          (goto-char start)
          (while (re-search-forward "<\\|>" end t)
            (when (save-excursion
                    (and
                     (re-search-backward "[[:space:]]*#\\+\\(begin\\|end\\)_src\\_>" nil t)
                     (string-equal (downcase (match-string 1)) "begin")))
              ;; This is a < or > in an org-src block
              (put-text-property (point) (1- (point))
                                 'syntax-table (string-to-syntax "_"))))))))

  (defun org-setup-<>-syntax-fix ()
    "Setup for characters ?< and ?> in source code blocks.
  Add this function to `org-mode-hook'."
    (make-local-variable 'syntax-propertize-function)
    (setq syntax-propertize-function 'org-mode-<>-syntax-fix)
    (syntax-propertize (point-max)))

  (add-hook 'org-mode-hook #'org-setup-<>-syntax-fix)

#+end_src

***** edit emacs-lisp code block avec xah-elisp-mode

#+begin_src emacs-lisp

  (defun org-src-get-lang-mode (lang)
    "Return major mode that should be used for LANG.
      LANG is a string, and the returned major mode is a symbol."
    (when (string-equal lang "emacs-lisp")
      (setq lang "xah-elisp")
      )
    (intern
     (concat
      (let ((l (or (cdr (assoc lang org-src-lang-modes)) lang)))
        (if (symbolp l) (symbol-name l) l))
      "-mode")))

#+end_src

***** Nouvelle commande pratique pour éditer du code dans babel

#+begin_src emacs-lisp
  (defun cp/org-edit-special-src-dwim ()
    (interactive)
    (cond
     (org-src-mode
      (when (and (string-equal major-mode cp/emacs-lisp-mode) (yes-or-no-p "Évaluer le buffer avant de partir ?"))
        (eval-buffer))
      ;; indentation automatique
      (mark-whole-buffer)
      (indent-for-tab-command)
      (deactivate-mark)

      (org-edit-src-exit))
     ((org-in-src-block-p) (org-edit-special))
     ((derived-mode-p 'org-mode)
      (if (string-prefix-p config-directory (buffer-file-name))
          ;; si je suis dans ma config, alors ouvre directement du
          ;; emacs-lisp. sinon, propose le language
          (org-insert-structure-template "src emacs-lisp")
        (call-interactively #'org-insert-structure-template))
      (org-edit-special))))
#+end_src

***** Nouvelle commande pratique pour org-capture

#+begin_src emacs-lisp
  (defun cp/org-open-or-finish-capture ()
    (interactive)
    (message "%s" org-capture-mode)
    (if org-capture-mode
        (org-capture-finalize)
      (org-capture)))  
#+end_src


***** Nouveau raccourcis pour org-src-mode-map (plus besoin grâce à cp/org-edit-special-capture-src-dwim)

#+begin_src emacs-lisp

  (defvar org-src-mode-map
    (let ((map (make-sparse-keymap)))
      ;; (define-key map "\C-c'" 'org-edit-src-exit)
      (define-key map "\C-c\C-c" 'org-edit-src-exit) ;; changement ici
      (define-key map "\C-c\C-k" 'org-edit-src-abort)
      (define-key map "\C-x\C-s" 'org-edit-src-save)
      map))

#+end_src

**** Latex
***** TODO Yasnippets de Latex dans org, désactive org bullet, à faire après les yasnippets

#+begin_src emacs-lisp :tangle no

  (defun my-org-latex-yas ()
    (yas-minor-mode)
    (yas-activate-extra-mode 'latex-mode)
    )


  (add-hook 'org-mode-hook 'my-org-latex-yas)
  
#+end_src
***** Les nouvelles classes latex

#+begin_src emacs-lisp

  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes
                 '("org-plain-latex"
                   "\\documentclass{article}
                   [NO-DEFAULT-PACKAGES]
                   [PACKAGES]
                   [EXTRA]"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))

                 )

    )

#+end_src
**** Options sur les exports (sauf Latex) + Nouveaux exports org-modet
***** Options générales
****** Ignorer les headline avec le tag ignore:

#+begin_src emacs-lisp
  (with-eval-after-load 'org-contrib
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines))
    )
#+end_src
****** Ignorer les subtree avec le tag noexport
Rien besoin de faire, si ça change y mettre ici

***** Html
#+begin_src emacs-lisp 
  (use-package htmlize
    :config
    (setq org-html-doctype "html5")
    (setq org-html-indent nil) ;;indentation du code automatiquement si sur t, mais tue l'indentation des balise exemple, python etc
    )
#+end_src
***** Pour twitter (why not)
#+begin_src emacs-lisp
  (use-package ox-twbs)
#+end_src
***** Epub


#+begin_src emacs-lisp  
  (use-package ox-epub)
#+end_src




**** Notes collaboratives avec org-mode ([[https://floobits.com/help/plugins/emacs][ici]]) 



#+begin_src emacs-lisp :tangle no

(use-package floobits)

#+end_src


*** Choses dans le second cerveau

#+begin_src emacs-lisp
  (when braindump-exists
#+end_src

**** Gestion des liens

Deux stockage d'id : utilisé dans la db de org-roam, utiliser par org.
Quand on clique sur un lien, les deux marche.
Il faut dire à org où sont les fichiers avec les ids

***** Les id sont créés grâce à la date

#+begin_src emacs-lisp

  (setq org-id-method 'ts)
  (setq org-id-ts-format "%Y%m%d%H%M%S%6N") ;; le 6N est présent pour être sûr que se soit unique

#+end_src

(use-package org-id
  :straight nil
  :defer t
  :hook ((before-save . vulpea-id-auto-assign)
         (org-capture-prepare-finalize . org-id-get-create))
  :init
  (setq org-id-uuid-program
        "uuidgen | tr \"[:upper:]\" \"[:lower:]\"")
  :config
  (setq
   org-id-track-globally t
   org-id-extra-files
   (list (expand-file-name ".archive/archive" org-directory)
         (expand-file-name ".archive/archive.org" org-directory))
   org-id-link-to-org-use-id t
   org-id-locations-file (expand-file-name "org-id-locations"
                                           path-cache-dir)))

***** Ids chemin relatif

#+begin_src emacs-lisp
(setq org-id-locations-file-relative t)
#+end_src
***** Mise à jour des ids

#+begin_src emacs-lisp
  ;; (org-roam-update-org-id-locations) ;; =  org-directory and org-roam-directory

  ;; (org-id-update-id-locations) ;;plus besoin normalement

  ;; seul transclude en a besoin. Peut peut-être ralentir les choses

  (advice-add 'org-transclusion-add :before #'org-id-update-id-locations)

#+end_src
***** Les ids des fichiers

#+begin_src emacs-lisp
  ;; This implies that when that function is executed, the files whose
  ;; content is searched for IDs (i.e. they are scanned) are
  ;;
  ;; + The files mentioned in =org-agenda-files=.
  ;; + The archives associated to the files in =org-agenda-files=.
  ;; + The files mentioned in =org-id-locations=.
  ;; + The files provided as arguments to the =org-id-update-id-locations=.
  ;;
  ;; The following are not mentioned in the documentation of
  ;; =org-id-update-id-locations=, but when looking at the source code, you
  ;; can see that the value of the following variables is used
  ;;
  ;; + =org-id-extra-files=
  ;; + =org-id-files=
  ;;

  ;; (setq org-id-files (org-roam-list-files))

  ;;plus propre d'y mettre dans les extras
  (setq org-id-extra-files (append(directory-files-recursively config-directory "org$") (org-roam-list-files)))
#+end_src


***** Les nouveaux "types" de liens

****** Man

Déjà dans org-mode natif, juste à activer

#+begin_src emacs-lisp
  (require 'ol-man)
#+end_src

****** Test de nouveau liens


#+begin_src emacs-lisp :tangle no 

  (defun org-id-open (id _)
    "Go to the entry with id ID."
    (org-mark-ring-push)
    (let ((m (org-id-find id 'marker))
          cmd)
      (unless m
        (error "Cannot find entry with ID \"%s\"" id))
      ;; Use a buffer-switching command in analogy to finding files
      (setq cmd
            (or
             (cdr
              (assq
               (cdr (assq 'file org-link-frame-setup))
               '((find-file . switch-to-buffer)
                 (find-file-other-window . switch-to-buffer-other-window)
                 (find-file-other-frame . switch-to-buffer-other-frame))))
             'switch-to-buffer-other-window))
      (if (not (equal (current-buffer) (marker-buffer m)))
          (funcall cmd (marker-buffer m)))
      (goto-char m)
      (move-marker m nil)
      (org-fold-show-context)))

  (org-link-set-parameters "id" :follow #'org-id-open)
#+end_src

#+begin_src emacs-lisp :tangle no

  (defun org-test-store-link ()
    "Store a link to the current entry, using its ID.

  If before first heading store first title-keyword as description
  or filename if no title."
    (interactive)
    (when (and (buffer-file-name (buffer-base-buffer)) (derived-mode-p 'org-mode))
      (let* ((link (concat "test:" (org-id-get-create)))
             (case-fold-search nil)
             (desc (save-excursion
                     (org-back-to-heading-or-point-min t)
                     (cond ((org-before-first-heading-p)
                            (let ((keywords (org-collect-keywords '("TITLE"))))
                              (if keywords
                                  (cadr (assoc "TITLE" keywords))
                                (file-name-nondirectory
                                 (buffer-file-name (buffer-base-buffer))))))
                           ((looking-at org-complex-heading-regexp)
                            (if (match-end 4)
                                (match-string 4)
                              (match-string 0)))
                           (t link)))))
        (org-link-store-props :link link :description desc :type "test")
        link)))

  (defun org-id-open (id _)
    "Go to the entry with id ID."
    (org-mark-ring-push)
    (let ((m (org-id-find id 'marker))
          cmd)
      (unless m
        (error "Cannot find entry with ID \"%s\"" id))
      ;; Use a buffer-switching command in analogy to finding files
      (setq cmd
            (or
             (cdr
              (assq
               (cdr (assq 'file org-link-frame-setup))
               '((find-file . switch-to-buffer)
                 (find-file-other-window . switch-to-buffer-other-window)
                 (find-file-other-frame . switch-to-buffer-other-frame))))
             'switch-to-buffer-other-window))
      (if (not (equal (current-buffer) (marker-buffer m)))
          (funcall cmd (marker-buffer m)))
      (goto-char m)
      (move-marker m nil)
      (org-fold-show-context)))

  (org-link-set-parameters "id" :follow #'org-id-open)

#+end_src


***** TODO Pour mettre des les archives dans les id

#+begin_src emacs-lisp :tangle no
(use-package org-id
  :straight nil
  :defer t
  :hook ((before-save . vulpea-id-auto-assign)
         (org-capture-prepare-finalize . org-id-get-create))
  :init
  (setq org-id-uuid-program
        "uuidgen | tr \"[:upper:]\" \"[:lower:]\"")
  :config
  (setq
   org-id-track-globally t
   org-id-extra-files
   (list (expand-file-name ".archive/archive" org-directory)
         (expand-file-name ".archive/archive.org" org-directory))
   org-id-link-to-org-use-id t
   org-id-locations-file (expand-file-name "org-id-locations"
                                           path-cache-dir)))
#+end_src

***** Les id sans org-roam

C'est possible, mais pas de backlinks, pas stocké dans une base de donnée, etc. Pour la postérité cette config, ici ne sert plus à rien

****** Ce qu'il faut comprendre
Avant, les liens était stocké comme ceci : [[lien/vers/letruc][descriptioni] ]
Donc, si on change le nom de "letruc", ça ne marche plus, mais c'était pratique car c'était des liens relatif (et donc ça fonctionnait partout). 
Il faut donc trouver autre chose... les id sont parfait. Mais pas relatif... on l'active, et tout est ok !

Ce qu'il faut faire :
- Ajouter, quand on stocke un lien, un id au titre (logique)
- rendre tout ceci relatif (pour rendre cela accessible de partout)
- Faire un système de completion pour insérer un lien id (fait, c'est une variable exactement comme org-refile)
- rajouter différents dossier où je veux aussi créer des link. ces dossier doivent aussi être à la bonne place (fait, comme org-agenda-files. J'ai tout mis)

****** TODO Pour mettre des liens directement avec org-insert-link id

#+begin_src emacs-lisp :tangle no

  ;; pour que les liens soit relatif, et donc pour pouvoir l'installer sur n'importe qu'elle ordinateur ! Tjr utilisé, car pour faire la correspondance, j'utilise une table qui stocke où chaque id est
  (setq org-id-locations-file-relative t)

  ;;lieu du fichier des loccation :
  ;;voir no-littering

  ;;voir le manual pour plus d'information. Ne me créera pas d'id inutile
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

  ;; ;; Où chercher des fichiers en plus pour les ID.  Si la valeur de org-id-extra-files est nul, alors org-agenda-text-search-extra-files prendra le dessus, mais cela correspond aussi aux fichiers org-agenda ajouté. Il faut donc prendre d'autres fichiers. Là, j'ai vraiment tout mis.
  (setq org-id-extra-files
        (append
         mesdocuments-directory-all-org-files
         org-directory-all-org-files
         shared-directory-private-all-org-files
         my-user-emacs-configuration-list
         )
        )

  ;;ceci est la liste des fichiers (qui pernds des liste en paramètre) qui vont s'afficher quand on va faire un org-insert-link id. même syntaxe que les refile
  (setq org-try-targets
        '(
          ;;refile dans le buffer courant jusqu'au niveau 7
          (nil :maxlevel . 7)
          ;;refile dans tous les fichiers de l'agenda jusqu'au niveau 5
          (org-agenda-files :maxlevel . 5)
          ;;refile les documents
          (mesdocuments-directory-all-org-files :maxlevel . 1)
          ;;pour refile document_partage
          (shared-directory-private-all-org-files :maxlevel . 5)
          (my-user-emacs-configuration-list :maxlevel . 5)
          )
        )


  ;; pour la complétion lors de l'insertion d'un lien id avec org-insert-link id, la complétion est 
  ;;il faut personnaliser org-try-targets comme un org-refile-targets
  (defun org-id-complete-link (&optional arg)
    "Create an id: link using completion"
    (concat "id:"
            (org-id-get-with-outline-path-completion org-try-targets)
            ;; (org-id-get-with-outline-path-completion org-id-extra-files)            ;; là je prends vraiment tout
            ;; (org-id-get-with-outline-path-completion org-refile-targets) ;;pas mal pour les refiles
            ;; (org-id-get-with-outline-path-completion) ;; pour avoir d'autres completion par exemple
            )
    )
  ;;pour que ça marche après org 9.0
  (org-link-set-parameters "id" :complete 'org-id-complete-link)


#+end_src

****** Pour nettoyer les id inutilisé

#+begin_src emacs-lisp :tangle no
(use-package org-id-cleanup)
#+end_src

****** On update à la fin ?

#+begin_src emacs-lisp
  ;; Update ID file .org-id-locations on startup
  ;; (org-id-update-id-locations)
#+end_src


**** Gestion des métadata

***** Gestion de la dernière date de modification, enlever, gérer par git

Maj du package : j'enlève la création de ctime, car c'est donné par l'id ! et je remplace la fonction qui obtient le ctime par la partie de l'id qu'il faut (pour plus tard je pense)

#+begin_src emacs-lisp :tangle no

  
  (use-package org-roam-timestamps
    :after org-roam
    :config

    (defun org-roam-timestamps--on-save ()
      "Set the MTIME property of the current org-roam-node to the current time."
      (when (org-roam-buffer-p)
        (let* ((node (org-roam-node-at-point))
               (file (org-roam-node-file node))
               (pos (org-roam-node-point node))
               (level (org-roam-node-level node))
               (mtime (org-roam-timestamps--get-mtime node)))

          (org-roam-timestamps--add-mtime node mtime)
          (when (and org-roam-timestamps-timestamp-parent-file (not (eq level 0)))
            (let* ((pnode (org-roam-timestamps--get-parent-file-node file))
                   (pmtime (org-roam-timestamps--get-mtime pnode))
                   (ppos (buffer-end -1)))
              (org-roam-timestamps--add-mtime pnode pmtime)
              ))
          nil)))


    (defun org-roam-timestamps-all ()
      "Go through all nodes and add timestamps to them."
      (interactive)
      (when (yes-or-no-p "This will modify all your current notes by adding a ctime and mtime property
        to all property drawers. We will make a backup of your notes and db first.
        This might take a second. Are you sure you want to continue?")
        (let ((backup-dir (expand-file-name "org-roam-timestamp.bak"
                                            (file-name-directory (directory-file-name org-roam-directory))))
              (backup-db (expand-file-name "org-roam-db.bak" (file-name-directory org-roam-db-location))))
          (message "Backing up files to %s" backup-dir)
          (copy-directory org-roam-directory backup-dir)
          (message "Backing up db to %s" backup-db)
          (copy-file org-roam-db-location backup-db))
        (let ((nodes (org-roam-db-query [:select id :from nodes])))
          (dolist (node nodes)
            (let* ((n (org-roam-node-from-id (car node)))
                   (file (org-roam-node-file n))
                   (mtime (org-roam-timestamps-decode (org-roam-node-file-mtime n)))
                   (pos (org-roam-node-point n))
                   (props (org-roam-node-properties n)))
              (org-roam-with-file file nil
                (goto-char pos)
                (unless (assoc-default "MTIME" props)
                  (org-roam-property-add "mtime" mtime ))
                (save-buffer))))))
      (org-roam-db-sync))

    (defun org-roam-timestamps--get-ctime (pos)
      "Return the current ctime for the node at point POS."
      (substring (org-id-get) 0 14)
      ;; (org-with-wide-buffer
      ;; (org-entry-get pos "ctime"))
      )


    (defun org-roam-timestamps-clean-mtime ()
      "Truncate all timestamps to a single value.
  A modifier pour supprimer tous les mtime si jamais"
      (interactive)
      (org-roam-timestamps-mode -1)
      (let ((nodes (org-roam-db-query [:select id :from nodes])))
        (dolist (node nodes)
          (let* ((n (org-roam-node-from-id (car node)))
                 (file (org-roam-node-file n))
                 (pos (org-roam-node-point n)))
            (org-roam-with-file file nil
              (org-with-wide-buffer
               (if-let ((mtime (org-roam-timestamps--get-mtime n))
                        (split (split-string mtime)))
                   (org-entry-put pos "mtime"  (car split)) ;;cette ligne
                 (save-buffer)))))))
      (org-roam-timestamps-mode 1))

    (setq org-roam-timestamps-minimum-gap 3600)
    (org-roam-timestamps-mode)


    )

#+end_src

Ancienne méthode :

#+begin_src emacs-lisp :tangle no

  (use-package time-stamp
    :straight nil
    ;; :defer t
    :config
    ;; ne pas oublier de le mettre dans le capture
    ;; :head "#+TITLE: ${title}\n#+CREATED: %U\n#+LAST_MODIFIED: %U\n\n"
    (setq time-stamp-active t
          time-stamp-start "\\- Modifié :: [ \t]*"
          time-stamp-end "$"
          time-stamp-format "%Y%m%d%H%M%S"  ;; impossible de mettre des nano seconds, ça marchera très bien quand même
          time-stamp-line-limit 20)

    (add-hook 'before-save-hook 'time-stamp nil)
    ;; (remove-hook 'before-save-hook 'time-stamp nil)
    )


#+end_src




***** Fonctions pour "Fait", permet de mettre quand j'ai fait quelque chose

#+begin_src emacs-lisp

  (defun cp-vulpea-meta-fait-add ()
    (interactive)
    (let* (
           (id (save-excursion (goto-char (point-min)) (org-id-get)))
           (key "Fait")
           (timestamp (format-time-string "%Y%m%d%H%M%S"))
           (fait-p (vulpea-meta-get id key))
           )
      (if fait-p
          (vulpea-meta-set id key (concat (vulpea-meta-get id key) ", " timestamp) t)
        (vulpea-meta-set id key timestamp t))

      )
    )

  (defun cp-vulpea-meta-fait-remove ()
    (interactive)
    (let* (
           (id (save-excursion (goto-char (point-min)) (org-id-get)))
           (key "Fait")
           (timestamp (format-time-string "%Y%m%d%H%M%S"))
           (fait-p (vulpea-meta-get id key))
           )
      (when fait-p
        (vulpea-meta-remove id key)
        )
      )
    )

#+end_src

**** Gestion de capture de connaissances
***** Lieu de mon inbox

#+begin_src emacs-lisp
(setq capture-inbox-file
    (expand-file-name (format "inbox-%s.org" (system-name)) org-roam-directory)
    )
#+end_src

***** Moteur de Org-capture
:PROPERTIES:
:ID:       54e7121a-93ed-4fb8-96b7-83cba535c170
:END:

Si la touche à appuyer est en maj, ceci est fait pour org-protocol !

#+begin_src emacs-lisp :tangle no



  (setq theKey "4est")

  (setq x 116)



  

  (sequencep )


#+end_src

#+begin_src emacs-lisp

  (defun cp/return-key-for-capture (theKey)
    "theKey is a string"
    (let ((result nil))
      (if (fboundp 'xah-fly--key-char)
          (seq-mapcat (lambda (x) (xah-fly--key-char (char-to-string x)))
                      (string-to-list theKey)
                      'string)
        theKey)))

  (setq org-capture-templates
        `((,(cp/return-key-for-capture "h") "todo" plain (file capture-inbox-file)
           (file "../templatesOrgCapture/todo.org"))
          (,(cp/return-key-for-capture "u") "tickler" entry
           (function cp/vulpea-capture-tickler-target)
           (file "../templatesOrgCapture/tickler.org")
           :immediate-finish t
           )
          (,(cp/return-key-for-capture "n") "un rdv" entry
           (function cp/vulpea-capture-rdv-target)
           (file "../templatesOrgCapture/rdv.org")
           :immediate-finish t
           )

          ("T" "test" entry
           (function cp/vulpea-capture-tickler-target)
           "* TODO %^{Nom du tickler} :tickler:\nSCHEDULED: %^T\n%?"
           )

          ;; ("c" "nouvelle connaissance" entry
          ;; (file capture-inbox-file)
          ;; (file "../templatesOrgCapture/connaissances.org")
          ;; :immediate-finish t
          ;; )

          ))
#+end_src

Ancien : 

#+begin_src emacs-lisp :tangle no


  ;; quand on donne un truc relatif, alors le org-directory est bien appelé ! Si je mets des fonctions pour les templates à récupéré ça ne marche plus. Obligé de laisser les capture templates dans le dossier braindump et en dehors du dossier org-directory (sinon la bdd dit double id)



  ;;les raccourcis ici ne sont pas important, mais doivent faire le liens entre TODO

  ;; (setq org-capture-templates-models (expand-file-name "templatesOrgCapture/" user-emacs-directory))

  (setq org-capture-templates '
        (

         ("t" "Pour les timestamps")
         ("tt" "Tickler" entry
          (file (lambda() (concat orgzly-directory "AgendaTickler.org")))
          (file "templatesOrgCapture/tickler.org")
          :immediate-finish t
          )
         ("te" "Évènement sur plusieurs heures" entry
          (file (lambda() (concat orgzly-directory "AgendaTickler.org")))
          (file "templatesOrgCapture/evenement.org")
          :immediate-finish t
          )

         ("td" "Évènement sur plusieurs jours" entry
          (file (lambda() (concat orgzly-directory "AgendaTickler.org")))
          (file "templatesOrgCapture/evenementplusieursjours.org")
          :immediate-finish t
          )


         ("i" "Inbox (TODO)" entry
          (file (lambda() (concat orgzly-directory "Inbox.org")))
          (file "templatesOrgCapture/todo.org")
          :immediate-finish t
          )
         ("n" "Inbox (NEXT)" entry
          (file capture-inbox-file)
          (file "../templatesOrgCapture/next.org")
          :immediate-finish t
          )

         ("s" "Slipbox for org-roam" entry  (file "braindump/org/inbox.org")
          "* %?\n")

         ("d" "Journal de dissactifaction" entry (file  "org/journal_de_dissatisfaction.org")
          "* %<%Y-%m-%d> \n- %?")

         ("c" "Contacts" entry
          (file+headline (lambda() (concat orgzly-directory "Contacts.org" ))"Inbox")
          (file "templatesOrgCapture/contacts.org")
          ;; :immediate-finish t
          ;; :jump-to-captured t
          )

         ("a" "Image dans Artiste")

         ("at" "Image + artiste" entry (file  "org/artistes.org" )
          (file "templatesOrgCapture/artistes.org")
          :jump-to-captured 1
          )

         ("as" "Image" entry (file "org/artistes.org" )
          (file "templatesOrgCapture/image.org")
          ;; :jump-to-captured 1
          )

         ;; ici se trouve les choses utilisé pour org-protocol
         ;; pour mes raccourcis
         ("O" "Link capture" entry
          (file+headline "org/orgzly/Bookmarks.org" "INBOX")
          "* %a %U"
          :immediate-finish t)


         ;; ("P" "org-popup" entry (file+headline "braindump/org/inbox.org" "Titled Notes")
         ;; "%[~/.emacs.d/.org-popup]" :immediate-finish t :prepend t)
         )
        )


#+end_src

***** Ajouter des fonctions suites aux captures, comme pour mettre des dates ou créer un ID

#+begin_src emacs-lisp

  ;; pour rajouter un ID OU DES COMMANDES à la fin de la capture !
  (defun cp/org-capture-finalize ()
    "Comprend la valeur de la key de org capture et décide de faire qql après le capture ou pas"
    (let ((key  (plist-get org-capture-plist :key))
          (desc (plist-get org-capture-plist :description)))
      (if org-note-abort
          (message "Template with key %s and description “%s” aborted" key desc)
        (message "Template with key %s and description “%s” run successfully" key desc)
        )
      (when (string= key "A") 		;si jamais c'est A, alors faire la suite
        (org-capture-goto-last-stored)
        (org-id-get-create)	    
        )
      (when (string= key "t") 		;etc
        ;; (org-capture-goto-last-stored)
        ;; (org-schedule nil nil)
        ;; (winner-undo)
        )
      (when (string= key "e") 		;etc
        ;; (org-capture-goto-last-stored)
        ;; (org-schedule nil nil)
        ;; (winner-undo)
        )
      (when (string= key "as") 		;etc
        (org-capture-goto-last-stored)
        (newline)
        (newline)
        (org-download-clipboard)
        ;; (org-schedule nil nil)
        ;; (winner-undo)
        )
      )
    )

  ;; (add-hook 'org-capture-after-finalize-hook 'cp/org-capture-finalize)

#+end_src

***** Fonctions pour choisir dynamiquement les destinations

****** un tickler
#+begin_src emacs-lisp

  (defun cp/vulpea-capture-tickler-target ()
    "Return a target for a tickler capture."
    (let ((place (vulpea-select
                  "Où va le tickler selectionné ")))
      ;; unfortunately, I could not find a way to reuse
      ;; `org-capture-set-target-location'
      (if (vulpea-note-id place)
          (let ((path (vulpea-note-path place)))
            (set-buffer (org-capture-target-buffer path))
            ;; Org expects the target file to be in Org mode, otherwise
            ;; it throws an error. However, the default notes files
            ;; should work out of the box. In this case, we switch it to
            ;; Org mode.
            (unless (derived-mode-p 'org-mode)
              (org-display-warning
               (format
                "Capture requirement: switching buffer %S to Org mode"
                (current-buffer)))
              (org-mode))

            (goto-char (point-max))
            ;; (insert "je suis là")

            (org-capture-put-target-region-and-position)
            (widen))
        ;;cas si personne trouvé, alors ça va direct dans l'inbox
        (let ((path capture-inbox-file))
          (set-buffer (org-capture-target-buffer path))
          (org-capture-put-target-region-and-position)
          (widen)))))

  ;; plus besoin de cette fonction
  (defun cp/vulpea-capture-tickler-template ()
    "Return a template for a meeting capture."
    (let ((anote (vulpea-select
                  "Où va le tickler selectionné : ")))
      (org-capture-put :target-tickler anote)
      "* TODO %^{Nom du tickler} :tickler:\nSCHEDULED: %^T\n%?"))



#+end_src



****** un rdv
#+begin_src emacs-lisp

  (defun cp/vulpea-capture-rdv-target ()
    "Return a target for a tickler capture."
    (let ((person (vulpea-select
                   "Où va le rdv selectionné : ")))
      ;; unfortunately, I could not find a way to reuse
      ;; `org-capture-set-target-location'
      (if (vulpea-note-id person)
          (let ((path (vulpea-note-path person)))
            (set-buffer (org-capture-target-buffer path))
            ;; Org expects the target file to be in Org mode, otherwise
            ;; it throws an error. However, the default notes files
            ;; should work out of the box. In this case, we switch it to
            ;; Org mode.
            (unless (derived-mode-p 'org-mode)
              (org-display-warning
               (format
                "Capture requirement: switching buffer %S to Org mode"
                (current-buffer)))
              (org-mode))

            (goto-char (point-max))

            (org-capture-put-target-region-and-position)
            (widen)
            )
        ;;cas si personne trouvé, alors ça va direct dans l'inbox
        (let ((path capture-inbox-file))
          (set-buffer (org-capture-target-buffer path))
          (org-capture-put-target-region-and-position)
          (widen)))))

  ;; plus besoin de cette fonction
  (defun cp/vulpea-capture-rdv-template ()
    "Return a template for a meeting capture."
    (let ((anote (vulpea-select
                  "Où va le tickler selectionné : ")))
      (org-capture-put :target-tickler anote)
      "* TODO %^{Nom du tickler} :tickler:\nSCHEDULED: %^T\n%?"))



#+end_src


****** Meeting avec une personne

#+begin_src emacs-lisp

  (defun vulpea-capture-meeting-template ()
    "Return a template for a meeting capture."
    (let ((person (vulpea-select
                   "Person"
                   :filter-fn
                   (lambda (note)
                     (let ((tags (vulpea-note-tags note)))
                       (seq-contains-p tags "people"))))))
      (org-capture-put :meeting-person person)
      (if (vulpea-note-id person)
          "* MEETING [%<%Y-%m-%d %a>] :REFILE:MEETING:\n%U\n\n%?"
        (concat "* MEETING with "
                (vulpea-note-title person)
                " on [%<%Y-%m-%d %a>] :MEETING:\n%U\n\n%?"))))

  (defun vulpea-capture-meeting-target ()
    "Return a target for a meeting capture."
    (let ((person (org-capture-get :meeting-person)))
      ;; unfortunately, I could not find a way to reuse
      ;; `org-capture-set-target-location'
      (if (vulpea-note-id person)
          (let ((path (vulpea-note-path person))
                (headline "Meetings"))
            (set-buffer (org-capture-target-buffer path))
            ;; Org expects the target file to be in Org mode, otherwise
            ;; it throws an error. However, the default notes files
            ;; should work out of the box. In this case, we switch it to
            ;; Org mode.
            (unless (derived-mode-p 'org-mode)
              (org-display-warning
               (format
                "Capture requirement: switching buffer %S to Org mode"
                (current-buffer)))
              (org-mode))
            (org-capture-put-target-region-and-position)
            (widen)
            (goto-char (point-min))
            (if (re-search-forward
                 (format org-complex-heading-regexp-format
                         (regexp-quote headline))
                 nil t)
                (beginning-of-line)
              (goto-char (point-max))
              (unless (bolp) (insert "\n"))
              (insert "* " headline "\n")
              (beginning-of-line 0)))
        (let ((path vulpea-capture-inbox-file))
          (set-buffer (org-capture-target-buffer path))
          (org-capture-put-target-region-and-position)
          (widen)))))

#+end_src


**** Gestion changement rapide de place pour les noeuds
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-27 Wed 18:35]
:END:

Ne pas oublier la commande org-roam-refile.

#+begin_src emacs-lisp

  ;;pour voir le chemin lors du refile
  (setq org-outline-path-complete-in-steps nil)
  ;; permet de déplacer avec un niveau de titre 1 ! (dans tickler par exemple)
  (setq org-refile-use-outline-path (quote file))



  (setq org-refile-targets
        '(
          ;;refile dans le buffer courant jusqu'au niveau 7
          (nil :maxlevel . 7)
          ;;refile dans tous les fichiers de l'agenda jusqu'au niveau 5
          ;; (org-agenda-files :maxlevel . 5) ;;c'est déjà orgzly-directory-all-org-files
          ;;refile dans mes notes
          (org-roam-list-files :maxlevel . 1)
          )
        )
#+end_src

**** Gestion de l'agenda

***** Options de base


#+begin_src emacs-lisp

  ;; Nouvelle touche pour mieux naviguer avec xah
  (define-key org-agenda-mode-map [remap next-line] #'org-agenda-next-item)
  (define-key org-agenda-mode-map [remap previous-line] #'org-agenda-previous-item)
  ;;
  (define-key org-agenda-mode-map [remap ?\r] #'org-agenda-goto)

  ;;avoir "org", notamment org-schedule, en anglais, indispensable pour orgzly
  (eval-after-load 'org (setq system-time-locale "C"))

  ;;  pour que le curseur soit en haut de org agenda quand t on l'ouvre
  (add-hook 'org-agenda-finalize-hook (lambda () (goto-char (point-min))) 90)

  ;;ouvre l'agenda dans la window actuel
  (setq org-agenda-window-setup 'current-window)

  ;; quand commance l'agenda ?
  ;;pas le week
  (setq org-agenda-start-on-weekday nil)
  ;; mais X jour après aujourd'hui
  (setq org-agenda-start-day "+0d")

  ;;vue de l'agenda sur X jours
  (setq org-agenda-span 8)

#+end_src



***** Gestion des priorité

****** Permet de mettre les tâches sans priorité en priorité minimal - 1

#+begin_src emacs-lisp
  ;; permet de mettre  A B C nil priorité dans l'ordre
  ;; une tâche qui n'a pas de priorité "possède" donc une priorité négative
  (setq cp/org-default-priority (+ org-priority-lowest 1))
  (setq org-default-priority cp/org-default-priority)

  ;; on ne commence par par -1 pour mettre une priorité
  (setq org-priority-start-cycle-with-default nil)

#+end_src

****** Permet de savoir si un heading à une priorité

#+begin_src emacs-lisp

  (defun cp/org-get-priority-p(s)
    "Renvoie vrai si il y a un ancêtre qui à une priorité, peut être en récursive un jour"
    (interactive)
    (save-excursion
      (while (ignore-errors (outline-up-heading 1 t)))
      (let (($p1 (progn (beginning-of-line) (point)))
            ;; ($p2 (progn (cp/org-goto-end-of-heading) (point)))
            ($p2 (progn (end-of-line) (point)))
            result)
        (save-restriction
          (narrow-to-region $p1 $p2)
          (goto-char $p1)
          (when (re-search-forward ".*?\\(\\[#\\([A-Z0-9]+\\)\\] ?\\)" nil t)
            (setq result t))))))

#+end_src

ancien :
#+begin_src emacs-lisp :tangle no

  (defun cp/org-get-priority-p(s)
    (> (org-get-priority s) 0) ;; check si elle est négative
    )

#+end_src

****** Priorité héritée

Marche pas pour org-ql
Même si la priorité n'est pas marqué, la priorité des subheading est bien la même que leur ancêtre (ou du subheading le plus proche)

#+begin_src emacs-lisp
  ;; ne marche pas ? normal car je veux la priorité, pas les propriétés...
  ;; (setq org-use-property-inheritance t)
#+end_src

#+begin_src emacs-lisp 

  ;; marche, mais seulement pour les fonctionnalité qui appelle org-priority-get-priority-function (donc presque tout)
  (defun my/org-inherited-priority (s)
    (save-excursion
      (cond
       ;; Priority cookie in this heading
       ((string-match org-priority-regexp s)
        (* 1000 (- org-priority-lowest
                   (org-priority-to-value (match-string 2 s)))))
       ;; No priority cookie, but already at highest level
       ((not (org-up-heading-safe))
        (* 1000 (- org-priority-lowest org-priority-default)))
       ;; Look for the parent's priority
       (t
        (my/org-inherited-priority (org-get-heading))))))

  (setq org-priority-get-priority-function #'my/org-inherited-priority)

#+end_src

***** Export de l'agenda en icalendar


#+begin_src emacs-lisp

  ;;Lieu de l'export org-icalendar-combine-agenda-files
  (setq org-icalendar-combined-agenda-file (expand-file-name "agendapourgoogle.ics" braindump-directory))

  (setq org-icalendar-with-timestamps 'active) ;; seulement les timestamp active pour exporter les évèmenements.
  (setq org-icalendar-include-todo nil) ;; sinon ça clone les choses schedulded
  (setq org-icalendar-use-scheduled '(
                                      ;; event-if-not-todo ;;pour pas exporter mes tickler
                                      event-if-todo-not-done
                                      event-if-not-todo ;;  pour exporter mes rdv
                                      ))
  (setq org-icalendar-use-deadline '(event-if-not-todo
                                     event-if-todo-not-done
                                     ))


  ;; ne pas exporter les tickler
  (setq org-icalendar-exclude-tags '("tickler"))


  ;;fonction export en background + message pour vérif que ça marche
  (defun org-icalendar-combine-agenda-files-background()
    (interactive)
    (message "Lancement du icalendar combine file (pour org.ics)")
    (org-icalendar-combine-agenda-files t)
    )

  (defun org-icalendar-combine-agenda-files-foreground()
    (interactive)
    (org-icalendar-combine-agenda-files nil)
    (message "fini")
    )

  ;; quand je close emacs, lance le processus
  (add-hook 'kill-emacs-hook #'org-icalendar-combine-agenda-files-foreground)

  ;; dès que la data base se syncronise, je mets à jour mon calendrier

  ;; TODO

  ;; (advice-add 'org-roam-db-sync :after #'org-icalendar-combine-agenda-files-background)


  ;; (advice-remove 'org-roam-db-sync #'org-icalendar-combine-agenda-files-background)

#+end_src


***** Gestion de l'agenda (visuel) 


On peut utiliser la propriété "catégorie", mais c'est long, donc on fait plûtôt par rapport au nom du fichier. Mais par défaut, le nom à la date (ce qui est pratique), donc il faut enlever cette date.

Patch de org agenda pour que ça marche, avec sa bibliothèque vulpea

****** Le format des choses affiché
#+begin_src emacs-lisp

    (setq org-agenda-prefix-format
        '((agenda . " %i %(vulpea-agenda-category 12)%?-12t% s")
          ;; (agenda . " %i %(vulpea-agenda-category 12)%?-12t%-6e% s") ;; pour voir l'effort estimate
          (todo . " %i %(vulpea-agenda-category 12) ")
          (tags . " %i %(vulpea-agenda-category 12) ")
          (search . " %i %(vulpea-agenda-category 12) ")))

  ;; (todo . " %i %(vulpea-agenda-category 12) %(let ((scheduled (org-get-scheduled-time (point)))) (if scheduled (format-time-string \"Schedulded to <%Y-%m-%d-%H-%M %a>\" scheduled) \"\"))")

#+end_src

(setq org-agenda-prefix-format  '((agenda . " %i %-12:c%?-12t% s")
                                    (todo . " %i %-12:c")
                                    (tags . " %i %-12:c")
                                    (search . " %i %-12:c")))

****** Jolie affichage des catégories trop longue, et la catégorie égale le titre - la date

#+begin_src emacs-lisp
  (defun vulpea-agenda-category (&optional len)
    "Get category of item at point for agenda.

  Category is defined by one of the following items:

  - CATEGORY property
  - TITLE keyword
  - TITLE property
  - filename without directory and extension

  When LEN is a number, resulting string is padded right with
  spaces and then truncated with ... on the right if result is
  longer than LEN.

  Usage example:

    (setq org-agenda-prefix-format
          '((agenda . \" %(vulpea-agenda-category) %?-12t %12s\")))

  Refer to `org-agenda-prefix-format' for more information."
    (let* ((file-name (when buffer-file-name
                        (file-name-sans-extension
                         (file-name-nondirectory buffer-file-name))))
           (title (vulpea-buffer-prop-get "title"))
           (category (org-get-category))
           (result
            (or (if (and
                     title
                     (string-equal category file-name))
                    title
                  category)
                "")))
      (if (numberp len)
          (s-truncate len (s-pad-right len " " result))
        result)))

#+end_src




****** Voir plus de choses dans l'agenda 



Faire la touche "v" dans l'agenda ! A pour voir les task dans fichiers archivé. l pour log-mode (voir les différents states) ([[https://stackoverflow.com/questions/56228430/display-scheduled-routines-actual-done-time-in-agenda-view][vient d'ici]] pour log-mode correctement)

#+begin_src emacs-lisp

  ;; ajout des choses à voir avec org-agenda log mode (raccourcis "l" dans l'agenda).
  ;; permet de voir les différents states notamment
  (setq org-agenda-log-mode-items '(closed clock state))

  ;; si je veux que cela commence en mode log-mode. Pas sûr que ce soit CETTE variable
  ;; (setq org-agenda-start-with-log-mode '(closed clock state))

#+end_src
****** Nombre de jour de prévoyance pour la deadline (dans la vue agenda)

#+begin_src emacs-lisp
  (setq org-deadline-warning-days 5)
#+end_src


***** Gestion de l'agenda (commandes)
****** Construction dynamique de mon agenda

Principe : mettre aux notes qui ont un state todo un tag "project", puis parcourir les fichiers de la base de donnée, ajouter dans une liste les fichiers avec le tag "projet", et mettre cette liste comme variable : org-agenda-files. Facile

Ne rajoute pas le tag "projet" au headline dans un fichier qui a comme filetag "project" (logique, car sinon tous les noeuds en dessous ont le tag projet aussi. Seul les fichiers nous intéresse)

#+begin_src emacs-lisp

    (setq org-tags-exclude-from-inheritance '(
                                              "PROJET"
                                              "PERSONNE" ;;ça vraiment ?
                                              "crypt"
                                              )
          )

  
#+end_src

Pour ajouter des fichiers dans une liste:

(setq test "/home/utilisateur/sharedDirectoryPrivate/notes/org/orgzly/GTD.org")
(push test org-agenda-files)

******* Tag projet à la note si il y a un state TODO dedans

#+begin_src emacs-lisp

  ;; ne pas mettre, empêche le démarrage d'emacs. Pk ?
  (add-hook 'find-file-hook #'vulpea-project-update-tag)

  (add-hook 'before-save-hook #'vulpea-project-update-tag)

  (defun vulpea-project-update-tag ()
    "Update PROJET tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (vulpea-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (vulpea-buffer-tags-get))
               (original-tags tags))
          (if (vulpea-project-p)
              (setq tags (cons "PROJET" tags))
            (setq tags (remove "PROJET" tags)))

          ;; cleanup duplicates
          (setq tags (seq-uniq tags))

          ;; update tags if changed
          (when (or (seq-difference tags original-tags)
                    (seq-difference original-tags tags))
            (apply #'vulpea-buffer-tags-set tags))))))

  (defun vulpea-buffer-p ()
    "Return non-nil if the currently visited buffer is a note."
    (and buffer-file-name
         (string-prefix-p
          (expand-file-name (file-name-as-directory org-roam-directory))
          (file-name-directory buffer-file-name))))

  (defun vulpea-project-p ()
    "Return non-nil if current buffer has any todo entry.

      TODO entries marked as done are ignored, meaning the this
      function returns nil if current buffer contains only completed
      tasks."
    (org-element-map                          ; (2)
        (org-element-parse-buffer 'headline) ; (1)
        'headline
      (lambda (h)
        (eq (org-element-property :todo-type h)
            'todo))
      nil 'first-match))                     ; (3)

#+end_src

Test :

#+begin_src emacs-lisp :tangle no
  (defun vulpea-project-p ()
    "Return non-nil if current buffer has any todo entry or schedulded.

        TODO entries marked as done are ignored, meaning the this
        function returns nil if current buffer contains only completed
        tasks."
    (org-element-map                          ; (2)
        (org-element-parse-buffer 'headline) ; (1)
        'headline
      (lambda (h)
        (or
         (eq (org-element-property :todo-type h)
             'todo)
         (not (eq (org-element-property :scheduled h)
                  'nil))
         ))
      nil 'first-match))
#+end_src

******** Explication de la dernière fonction
This might look a little bit too much, so let me explain the code step by step.

We parse the buffer using org-element-parse-buffer. It returns an abstract syntax tree of the current Org buffer. But sine we care only about headings, we ask it to return only them by passing a GRANULARITY parameter - 'headline. This makes things faster.
Then we extract information about TODO keyword from headline AST, which contains a property we are interested in - :todo-type, which returns the type of TODO keyword according to org-todo-keywords - 'done, 'todo or nil (when keyword is not present).
Now all we have to do is to check if the buffer list contains at least one keyword with 'todo type. We could use seq=find on the result of org-element-map, but it turns out that it provides an optional first-match argument that can be used for our needs. Thanks Gustav for pointing that out.




******* Mise à jour de l'agenda juste avant son appel


#+begin_src emacs-lisp

  (defun vulpea-project-files ()
    "Return a list of note files containing 'PROJET' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
                :from tags
                :left-join nodes
                :on (= tags:node-id nodes:id)
                :where (like tag (quote "%\"PROJET\"%"))]))))

  (defun vulpea-agenda-files-update (&rest _)
    (interactive)
    "Update the value of `org-agenda-files'."
    (setq org-agenda-files (vulpea-project-files)))

  ;; on skip les fichiers qui ne sont pas accessible
  (setq org-agenda-skip-unavailable-files t)

  (add-hook 'emacs-startup-hook 'vulpea-agenda-files-update);; on l'update une fois au démarrage
  ;; (vulpea-agenda-files-update) 


  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
  (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)

  (advice-add 'org-roam-db-sync :after #'vulpea-agenda-files-update)

#+end_src


******* (migration) Mise à jour automatisé des tags projets dans les notes avec le projet, à automatiser à un endroit. Je sais même pas si j'en ai besoin, car ça update à chaque sauvegarde. Et je sauvegarde tout le temps. Bon exemple après pour le lisp



#+begin_src emacs-lisp :tangle no
(dolist (file (org-roam-list-files))
  (message "processing %s" file)
  (with-current-buffer (or (find-buffer-visiting file)
                           (find-file-noselect file))
    (vulpea-project-update-tag)
    (save-buffer)))
#+end_src


****** TODO org-super-agenda


#+begin_src emacs-lisp
    (use-package org-super-agenda
      :config
      (org-super-agenda-mode))
#+end_src

****** Agenda custom command

******* Agenda custom command
#+begin_src emacs-lisp

  (setq org-agenda-custom-commands
        '(
          (" " "Agenda"
           ((tags
             "REFILE"
             ((org-agenda-overriding-header "To refile")
              (org-tags-match-list-sublevels nil)))))

          ;;à supprimer ?
          ("d" "dashboard"
           (
            (todo "RAPPEL" ((org-agenda-overriding-header "Se souvenir de ceci")))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Actions")
                   (org-agenda-max-todos nil)))
            (todo "TODO"
                  ((org-agenda-overriding-header "Tout ce qui est dans Inbox(Unprocessed Inbox Tasks)")
                   (org-agenda-files capture-inbox-file))
                  (org-agenda-text-search-extra-files nil))
            (todo "WAIT"
                  ((org-agenda-overriding-header "Waiting items")
                   (org-agenda-max-todos nil)))
            ;;(stuck "") ;; review stuck projects as designated by org-stuck-projects
            ;; ...other commands here
            )
           )
          )
        )


  ;;(org-agenda-skip-if SUBTREE CONDITIONS)
  (setq org-agenda-custom-commands
        '(("t" "Dashboard"
           (
            (agenda)
            (todo "TODO"
                  ((org-agenda-overriding-header "Les deux  : first task et projet")
                   (org-agenda-skip-function 'cp/super-org-agenda-skip-function-first-task)
                   (org-agenda-todo-ignore-scheduled t)
                   ))
            (todo "TODO"
                  ((org-agenda-overriding-header "Tous mes projets en cours")
                   ;; (org-tags-match-list-sublevels nil) ;;skip les subtask
                   (org-agenda-skip-function 'cp/org-agenda-skip-function-for-project)
                   ))
            (todo "TODO"
                  ((org-agenda-overriding-header "Prochaines tâches pas dans les projets")
                   ;; (org-tags-match-list-sublevels nil) ;;skip les subtask
                   (org-agenda-skip-function 'cp/org-agenda-skip-function-next-task-not-project)
                   ))
            (todo "TODO"
                  ((org-agenda-overriding-header "Liste de mes prochaines tâche à faire pour un projet")
                   (org-agenda-skip-function 'cp/org-agenda-skip-function-first-task)
                   ))

            ))
          ("s" "Liste des projets à faire TODO"
           (
            ;; (agenda "")
            (stuck "")
            (org-ql-block '(and (tags "project")
                                (not (done))
                                (not (ancestors))
                                ;; (not (descendants (todo "TODO"))) TODO here : trouver la tâche suivante, et elle n'est n'y schedulded ni todo, 
                                )
                          ((org-ql-block-header "Stuck projet"))
                          )
            (todo "" ((org-super-agenda-groups
                       '((:name "Test"  ; Disable super group header
                                :children todo)
                         (:name "Priority >= C items underlined, on black background"
                                :not (:priority>= "C"))
                         (:priority<= "B"
                                      ;; Show this section after "Today" and "Important", because
                                      ;; their order is unspecified, defaulting to 0. Sections
                                      ;; are displayed lowest-number-first.
                                      :order 1)
                         (:discard (:anything t))))))

            ))

          ("A" "En fonction d'un tag"
           (
            ;; (agenda "")
            (tags-todo (cp/org-get-one-of-all-tags)
                       ((org-agenda-overriding-header "Les deux  : first task et projet")
                        (org-agenda-skip-function 'cp/super-org-agenda-skip-function-first-task)
                        ))
            ))

          ("o" "Agenda and Office-related tasks"
           ((agenda "")
            (tags-todo "work")
            (tags "home|office")
            (org-ql-block '(and (todo "TODO")
                                (tags "projet")
                                (not (ancestors))
                                )
                          ((org-ql-block-header "Liste des projets non fini")))
            (org-ql-block '(and (todo "TODO")
                                (tags "WORK")
                                )
                          ((org-ql-block-header "Liste des Révisions, à suppr car pas trié par org-ql. Faire une requête org-ql à la place ?")))


            ))))

#+end_src

******* Les fonctions pour skips
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 01:50]
- State "TODO"       from              [2022-07-23 Sat 01:03]
:END:

******** Trouve mes projets en cours

skip : les niveaux autres que 1, pas de todo, ceux qui n'ont pas de fils, pas de priorité (ou priorité minimal)

#+begin_src emacs-lisp

  (defun cp/org-agenda-skip-function-for-project ()
    "On skip dès qu'on peut avec \"cond\""
    (when
        (cp/org-agenda-skip-function-for-project-cond)
      (save-excursion (org-end-of-subtree t))
      )
    )

  (defun cp/org-agenda-skip-function-for-project-cond()
    (cond (
           ;;je ne veux voir le premier heading, car c'est mon projet
           (not (eq (org-current-level) 1)) t)      
          ;; si pas de priorité alors on skip, car pas besoin de les voir
          ((not (cp/org-get-priority-p (match-string 0))) t)       
          ;;si il n'a pas de fils, je le skip 
          ((not (save-excursion (org-goto-first-child))) t)              
          )
    )


#+end_src

Ancien : 
#+begin_src emacs-lisp :tangle no

  (defun cp/org-agenda-skip-function-not-level-one ()
    "Skip si n'est pas niveau 1 et si pas de fils"
    (let (should-skip-entry)
      ;;je ne veux voir le premier heading, car c'est mon projet
      (unless (eq (org-current-level) 1)
        (setq should-skip-entry t))
      ;; si priorité par défault, alors on skip, car pas besoin de les voir
      (when (eq (org-priority-to-value (org-entry-get (point) "PRIORITY"))  cp/org-default-priority)
        (setq should-skip-entry t))
      ;;si il n'a pas de fils, je le skip 
      (unless (save-excursion (org-goto-first-child))
        (setq should-skip-entry t)
        ) 
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

#+end_src
******** Première tâche à faire
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 14:25]
- State "TODO"       from              [2022-07-23 Sat 01:56]
:END:


#+begin_src emacs-lisp

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))

  (defun cp/org-agenda-skip-function-first-task ()
    "On skip dès qu'on peut avec \"cond\""
    (when
        (cp/org-agenda-skip-function-first-task-cond)
      ;; on va voir la prochaine entrée, ou bien bout du fichier si ya plus rien
      (or (outline-next-heading)
          (goto-char (point-max)))
      )
    )

  (defun cp/org-agenda-skip-function-first-task-cond()
    (cond
     ;; pas todo
     ((not (org-current-is-todo)) t)
     ;; si niveau 1 et qu'il n'a pas de fils
     ((and (eq (org-current-level) 1) (not (save-excursion (org-goto-first-child)))) t)

     ;; si pas dans un todo (ancêtre todo)
     ((progn (save-excursion (while (ignore-errors (outline-up-heading 1 t)))(ignore-errors (not (org-current-is-todo))))) t)

     ;; si il a des fils (pas sûr, cela me donner "les parents") dans mes commandes, mais lorsque je scheduldais, ça garder les parents. (Il faudrait faire un truc spécial "si pas de fils schedulded") Idem pour la priorité : si une tâche next avait une priorité différentes du projet... ça n'aller pas.
     ((save-excursion (org-goto-first-child)) t)

     ;; si pas de priorité
     ((not (cp/org-get-priority-p (match-string 0))) t)
     ;; si le frère précédent existe et est en todo
     ((let (should-skip-entry)
        (save-excursion
          ;; If previous sibling exists and is TODO,
          ;; skip this entry
          (while (and (not should-skip-entry) (org-goto-sibling t) (not (eq (org-current-level) 1)))
            (when (org-current-is-todo)
              (setq should-skip-entry t))))
        should-skip-entry
        )
      t)
     ;; si un ancêtre avec un todo existe ET que cette ancêtre possède sibling précédent avec un TODO, alors skip
     ((let (should-skip-entry
            (num-ancestors (org-current-level))
            (ancestor-level 1))
        (while (and (not should-skip-entry) (<= ancestor-level num-ancestors))
          (save-excursion
            ;; When ancestor (parent, grandparent, etc) exists
            (when (ignore-errors (outline-up-heading ancestor-level t))
              ;; j'ai rajouter ici que le heading doit être différent de 1, comme ça on ne skip pas les tâches qui ont un projet avec un todo... mais pourquoi ? c'est dans cette boucle while le pb
              ;;parce qu'on regarde les oncles jusqu'au niveau 1, et donc, quand ya un todo avant, on annule les suivant! Il faut donc arrerter de checker les oncle au plus haut niveau !
              (when (not (eq (org-current-level) 1))
                ;; Else if ancestor is TODO, check previous siblings of
                ;; ancestor ("uncles"); if any of them are TODO, skip
                (when (org-current-is-todo)
                  (while (and (not should-skip-entry) (org-goto-sibling t))
                    (when (org-current-is-todo)
                      (setq should-skip-entry t)))))
              ))
          (setq ancestor-level (1+ ancestor-level))
          )
        should-skip-entry)
      t)

     )

    )

#+end_src

ancien : 
#+begin_src emacs-lisp :tangle no

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))

  (defun cp/org-agenda-skip-function-first-task ()
    "On skip dès qu'on peut avec \"cond\""
    (when
        (cond
         ;; pas todo
         ((not (org-current-is-todo)) t)
         ;; si niveau 1
         ((eq (org-current-level) 1) t)
         ;; si pas de priorité
         ((not (cp/org-get-priority-p (match-string 0))) t)
         ;; si le frère précédent existe et est en todo
         ((let (should-skip-entry)
            (save-excursion
              ;; If previous sibling exists and is TODO,
              ;; skip this entry
              (while (and (not should-skip-entry) (org-goto-sibling t))
                (when (org-current-is-todo)
                  (setq should-skip-entry t))))
            should-skip-entry
            )
          t)
         ;; si un ancêtre avec un todo existe ET que cette ancêtre possède sibling précédent avec un TODO, alors skip
         ((let (should-skip-entry
                (num-ancestors (org-current-level))
                (ancestor-level 1))
            (while (and (not should-skip-entry) (<= ancestor-level num-ancestors))
              (save-excursion
                ;; When ancestor (parent, grandparent, etc) exists
                (when (ignore-errors (outline-up-heading ancestor-level t))
                  ;; j'ai rajouter ici que le heading doit être différent de 1, comme ça on ne skip pas les tâches qui ont un projet avec un todo... mais pourquoi ? c'est dans cette boucle while le pb
                  ;;parce qu'on regarde les oncles jusqu'au niveau 1, et donc, quand ya un todo avant, on annule les suivant! Il faut donc arrerter de checker les oncle au plus haut niveau !
                  (when (not (eq (org-current-level) 1))
                    ;; Else if ancestor is TODO, check previous siblings of
                    ;; ancestor ("uncles"); if any of them are TODO, skip
                    (when (org-current-is-todo)
                      (while (and (not should-skip-entry) (org-goto-sibling t))
                        (when (org-current-is-todo)
                          (setq should-skip-entry t)))))
                  ))
              (setq ancestor-level (1+ ancestor-level))
              )
            should-skip-entry)
          t)
         )
      ;; on va voir la prochaine entrée, ou bien bout du fichier si ya plus rien
      (or (outline-next-heading)
          (goto-char (point-max)))
      )
    )
#+end_src

******** Trouve les tâches de niveau 1, priorité non nul, sans enfants
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 22:29]
- State "TODO"       from              [2022-07-23 Sat 22:29]
- State "TODO"       from              [2022-07-23 Sat 14:52]
:END:

#+begin_src emacs-lisp
  (defun cp/org-agenda-skip-function-next-task-not-project ()
    "On skip dès qu'on peut avec \"cond\""
    (when
        (cp/org-agenda-skip-function-next-task-not-project-cond)
      (save-excursion (org-end-of-subtree t))
      )
    )


  (defun cp/org-agenda-skip-function-next-task-not-project-cond()
    (cond (;;je veux voir les premiers heading seulement
           (not (eq (org-current-level) 1)) t)      
          ;; si pas de priorité alors on skip, car pas besoin de les voir
          ((not (cp/org-get-priority-p (match-string 0))) t)
          ;;si il a un fils, je le skip 
          ((save-excursion (org-goto-first-child)) t)              
          )
    )




#+end_src

******** Rassembler les deux yes fait !
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 22:50]
- State "TODO"       from              [2022-07-23 Sat 22:50]
- State "TODO"       from              [2022-07-23 Sat 14:47]
:END:

Ne garde que les première conditions, pourquoi ?

#+begin_src emacs-lisp 
  (defun cp/super-org-agenda-skip-function-first-task ()
    "On skip dès qu'on peut avec \"cond\""
    (when (and
           (cp/org-agenda-skip-function-next-task-not-project-cond)
           (cp/org-agenda-skip-function-first-task-cond)
           )
      (or (outline-next-heading)
          (goto-char (point-max)))
      )
    )
#+end_src

******* Récupère un tag parmis tous

#+begin_src emacs-lisp

  (defun cp/org-get-one-of-all-tags()
    "Renvoie un strig d'un des tags de org-agenda-files"
    (let* (
           ;;vive cette variable
           (org-complete-tags-always-offer-all-agenda-tags t)

           (all-tags (org-get-tags))
           (table (setq org-last-tags-completion-table
                        (org--tag-add-to-alist
                         (and org-complete-tags-always-offer-all-agenda-tags
                              (org-global-tags-completion-table
                               (org-agenda-files)))
                         (or org-current-tag-alist (org-get-buffer-tags)))))
           (current-tags
            (cl-remove-if (lambda (tag) (get-text-property 0 'inherited tag))
                          all-tags))
           (inherited-tags
            (cl-remove-if-not (lambda (tag) (get-text-property 0 'inherited tag))
                              all-tags))
           (tags
            (replace-regexp-in-string
             ;; Ignore all forbidden characters in tags.
             "[^[:alnum:]_@#%]+" ":"
             (if (or (eq t org-use-fast-tag-selection)
                     (and org-use-fast-tag-selection
                          (delq nil (mapcar #'cdr table))))
                 (org-fast-tag-selection
                  current-tags
                  inherited-tags
                  table
                  (and org-fast-tag-selection-include-todo org-todo-key-alist))
               (let ((org-add-colon-after-tag-completion (< 1 (length table)))
                     (crm-separator "[ \t]*:[ \t]*"))
                 (mapconcat #'identity
                            (completing-read-multiple
                             "Tags: "
                             org-last-tags-completion-table
                             nil nil (org-make-tag-string current-tags)
                             'org-tags-history)
                            ":"))))))
      tags))


#+end_src

******* TODO Permet de monter le titre en haut de sa section
:LOGBOOK:
- State "TODO"       from              [2022-07-23 Sat 00:32]
:END:

#+begin_src emacs-lisp

(defun bjm/org-headline-to-top ()
  "Move the current org headline to the top of its section"
  (interactive)
  ;; check if we are at the top level
  (let ((lvl (org-current-level)))
    (cond
     ;; above all headlines so nothing to do
     ((not lvl)
      (message "No headline to move"))
     ((= lvl 1)
      ;; if at top level move current tree to go above first headline
      (org-cut-subtree)
      (beginning-of-buffer)
      ;; test if point is now at the first headline and if not then
      ;; move to the first headline
      (unless (looking-at-p "*")
        (org-next-visible-heading 1))
      (org-paste-subtree))
     ((> lvl 1)
      ;; if not at top level then get position of headline level above
      ;; current section and refile to that position. Inspired by
      ;; https://gist.github.com/alphapapa/2cd1f1fc6accff01fec06946844ef5a5
      (let* ((org-reverse-note-order t)
             (pos (save-excursion
                    (outline-up-heading 1)
                    (point)))
             (filename (buffer-file-name))
             (rfloc (list nil filename nil pos)))
        (org-refile nil nil rfloc))))))
#+end_src

****** Faire des requête avec des commandes

[[https://github.com/alphapapa/org-ql/blob/master/examples.org#stuck-projects-block-agenda][voir des exemples ici]]

#+begin_src emacs-lisp
  (use-package org-ql
    :config

    )
#+end_src


https://github.com/alphapapa/org-ql/pull/237
#+begin_src emacs-lisp :tangle no

  (setq org-ql-regexp-part-ts-time
        (rx " " (repeat 1 2 digit) ":" (repeat 2 digit)
            (optional "-" (repeat 1 2 digit) ":" (repeat 2 digit))))

  (org-ql-select '("/home/utilisateur/braindump/org/pages/20220718223109-test_de_todo_org_ql.org")
    '(and
      (not (done))
      (ts-active :to today)
      )
    )

#+end_src


Tests :

#+begin_src emacs-lisp :tangle no

  (defun my-org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-todo)
        (setq should-skip-entry t))
      ;;je ne veux pas voir le premier heading, car c'est ma liste de tâche à faire pour un noeud X, qui représente la catégorie
      ;; (when (eq (org-current-level) 1)
      ;; (setq should-skip-entry t))

      (save-excursion
        ;; If previous sibling exists and is TODO,
        ;; skip this entry
        (while (and (not should-skip-entry) (org-goto-sibling t))

          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (let ((num-ancestors (org-current-level))
            (ancestor-level 1))
        (while (and (not should-skip-entry) (<= ancestor-level num-ancestors))
          (save-excursion
            ;; When ancestor (parent, grandparent, etc) exists
            (when (ignore-errors (outline-up-heading ancestor-level t))
              ;; If ancestor is WAITING, skip entry
              (if (string= "WAITING" (org-get-todo-state))
                  (setq should-skip-entry t)
                ;; Else if ancestor is TODO, check previous siblings of
                ;; ancestor ("uncles"); if any of them are TODO, skip
                (when (org-current-is-todo)
                  (while (and (not should-skip-entry) (org-goto-sibling t))
                    (when (org-current-is-todo)
                      (setq should-skip-entry t)))))))
          (setq ancestor-level (1+ ancestor-level))
          ))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

#+end_src

******* DONE trouver mes projet
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-07-23 Sat 01:46]
- State "TODO"       from              [2022-07-23 Sat 01:46]
:END:

J'utilise org-mode

#+begin_src emacs-lisp :tangle no

  (defun cp/mes-projets ()
    (interactive)
    (org-ql-search (org-agenda-files)
      '(and (not (done))
            (not (ancestors))
            (children)
            )
      :sort '(priority)
      :super-groups '(
                      (:name "Mes projets en cours"
                             :priority>= "C" :order 1)
                      ))
    )

#+end_src

****** TODO Stuck projet

À rajouter avec org agenda custo command ?
Se baser sur org-ql

Ce sont les projets qui n'ont 1 ni priorité 2 ni deadline

#+begin_src emacs-lisp
(add-to-list 'org-agenda-custom-commands
      '("b" "Stuck Projects"
         ((org-ql-block '(and (tags "@project")
                              (not (done))
                              (not (descendants (todo "NEXT")))
                              (not (descendants (scheduled))))
                        ((org-ql-block-header "Stuck Projects"))))))
#+end_src

[[https://orgmode.org/manual/Stuck-projects.html][ici]] pour le mode d'emploi version org-mode
ne sert à rien, à part les afficher à un moment, remplacable par org-ql je pense

#+begin_src emacs-lisp
  ;; (setq org-stuck-projects
        ;; '("+PROJECT/-MAYBE-DONE" ("NEXT" "TODO") ("@shop")
          ;; "\\<IGNORE\\>"))
#+end_src


****** Fonctions pour faire des choses global sur l'agenda après avoir marqué (m) faire B

#+begin_src emacs-lisp

  (setq org-agenda-bulk-custom-functions '(
                                           (?D (lambda nil (org-agenda-priority 65)))
                                           (?L (lambda nil (org-agenda-priority 66)))
                                           (?\? (lambda nil (org-agenda-priority 67)))
                                           (?Q (lambda nil (org-agenda-priority 68)))
                                           ))

  
#+end_src


****** Refresh l'agenda après voir un item en done

#+begin_src emacs-lisp
(advice-add 'org-agenda-todo :after #'org-agenda-redo-all)
#+end_src

****** TODO Save les buffers org-mode après le refresh de l'agenda. À faire un jour peut-être
:LOGBOOK:
- State "TODO"       from              [2022-10-08 Sat 18:06]
:END:

#+begin_src emacs-lisp :tangle no
    (advice-add 'org-agenda-redo-all :after #'org-save-all-org-buffers)
    (advice-remove 'org-agenda-redo-all #'org-save-all-org-buffers)
    (add-hook 'org-agenda-mode-hook
              (lambda ()
                (add-hook 'auto-save-hook 'org-save-all-org-buffers nil t)))

  (add-hook 'auto-save-hook 'org-save-all-org-buffers)

  ;; xah-save-all-unsaved ?

#+end_src

***** Gestion de l'agenda (téléphone)

****** TODO Avoir les notifications
:LOGBOOK:
- State "TODO"       from              [2022-10-16 Sun 21:35]
:END:

Voir les commentaires !

#+begin_src emacs-lisp
    (use-package org-yaap
    :straight (org-yaap :type git :host gitlab :repo "tygrdev/org-yaap")
    :config

    (setq
     org-yaap-overdue-alerts '(5 30 180 1440)
     org-yaap-alert-before '(30 0) ;; prévenir 30mins avant et à 0 (voir issue github)
     org-yaap-todo-only t ;; pour pas avoir les non todo (les rendez-vous simple par exemple).
     ;; org-yaap-include-tags '(test)
     )

    (org-yaap-mode 1))
#+end_src

pour tester : 
(org-yaap--check-heading (org-element-at-point)) (org-yaap--get-alerts (org-element-at-point))

**** Gestion des tâches

***** Les keywords

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(!)" "|" "DONE(!)" )))
#+end_src


***** Tracer les états / states des todo dans des tiroirs 

Il faut rajouter "!" dans les org-todo-keywords.

#+begin_src emacs-lisp

  ;; (setq org-log-done 'time) ;; rajoute "CLOSED:" quand on termine une tâche. Pas besoin grâce à la variables org-log-into-drawer
  (setq org-log-into-drawer t);; le mets dans un propreties

#+end_src


***** Gestion des projets
****** Empêche les parent d'être coché si les fils ne le sont pas

#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src

****** TODO Permet de rajouter les statistics cookies automatiquement
:LOGBOOK:
- State "TODO"       from              [2022-07-23 Sat 16:07]
:END:

******* Ajouter

#+begin_src emacs-lisp :tangle no

  (defun cp/org-goto-end-of-heading ()
    "Move cursor à la fin du titre, en ne prenant pas en compte les tags et les cookies"
    (interactive)
    (save-restriction
      (org-narrow-to-subtree)
      (goto-char (point-min))
      (setq heading-with-cookies (org-get-heading t t t t))
      (setq heading-without-cookies (substring heading-with-cookies 0 (string-match "\\(\\(\\[[0-9]*%\\]\\)\\|\\(\\[[0-9]*/[0-9]*\\]\\)\\)" heading-with-cookies)))
      (re-search-forward (string-trim heading-without-cookies) nil t)
      )
    )  


  (defun cp/org-insert-statistics-cookies()
    "TODO"
    (interactive)
    (let
        ((cookie-re "\\(\\(\\[[0-9]*%\\]\\)\\|\\(\\[[0-9]*/[0-9]*\\]\\)\\)"))
      (save-excursion
        (when (> (org-outline-level) 1)
          (outline-up-heading 1)
          (when (org-entry-is-todo-p)
            (save-restriction
              (org-narrow-to-subtree)
              (unless (re-search-forward cookie-re nil t)
                ;; on s'avance jusqu'à la fin de la ligne, 
                (cp/org-goto-end-of-heading)
                ;; cas sans le tag et après le tag
                (insert " [/]")
                (org-update-statistics-cookies nil)
                )))))))


  (add-hook 'org-insert-heading-hook #'cp/org-insert-statistics-cookies)
  ;; (add-hook 'org-after-todo-state-change-hook 'cp/org-insert-statistics-cookies)

#+end_src

ancien : 
(defun cp/org-goto-end-of-heading ()
    "Move cursor à la fin du titre, en ne prenant pas en compte les tags et les cookies"
    (interactive)
    (save-restriction
      (org-narrow-to-subtree)
      (goto-char (point-min))
      ;; on s'avance jusqu'à la fin de la ligne, 
      (if (re-search-forward org-tag-line-re nil t)
          (progn
            (while (search-backward ":" nil t))
            )
        (end-of-line))
      (skip-chars-backward " ")
      (when (re-search-backward "\\(\\(\\[[0-9]*%\\]\\)\\|\\(\\[[0-9]*/[0-9]*\\]\\)\\)" nil t)
        (skip-chars-backward " ")  
        )
      ;; cas sans le tag et après le tag
      )
    )

******* TODO Supprimer
:LOGBOOK:
- State "TODO"       from              [2022-07-23 Sat 13:58]
:END:

#+begin_src emacs-lisp :tangle no
  (defun org-delete-statistics-cookies()
    "Peut pas marcher, car pas de hook"
    (interactive)
    (let
        (
         (cookie-re "\\(\\(\\[[0-9]*%\\]\\)\\|\\(\\[[0-9]*/[0-9]*\\]\\)\\)")
         )
      (save-excursion
        (unless (org-goto-first-child)
          (outline-up-heading 0)
          (save-restriction
            (org-narrow-to-subtree)
            (unless (re-search-forward cookie-re nil t)
              (end-of-line)
              (insert "[/]")
              (org-update-statistics-cookies nil)
              ))))
      )

    )
  ;; (add-hook 'org-insert-heading-hook #'org-delete-statistics-cookies)

#+end_src

****** Rajoute le tag projet automatiquement

#+begin_src emacs-lisp :tangle no
  
  (defun cp/org-toggle-tag-projet()
    (org-toggle-tag "projet" 'on)
    )

  (defun cp/org-toggle-tag-projet-level-one()
    (save-excursion
      (when (> (org-outline-level) 1)
        (while (ignore-errors (outline-up-heading 1 t)))
        (when (org-entry-is-todo-p)
          (cp/org-toggle-tag-projet)
          ))))

    (add-hook 'org-insert-heading-hook #'cp/org-toggle-tag-projet-level-one)

#+end_src

***** Gestions des habitues

#+begin_src emacs-lisp
(require 'org-habit)
#+end_src

**** Gestion des tags (sauf tag PROJET, PERSONNE et LIEU), voir l'agenda
***** Les différents tags

#+begin_src emacs-lisp

(setq org-tag-alist '((:startgrouptag)
                      ("GTD")
                      (:grouptags)
                      ("Control")
                      ("Persp")
                      (:endgrouptag)
                      (:startgrouptag)
                      ("Control")
                      (:grouptags)
                      ("Context")
                      ("Task")
                      (:endgrouptag)))
  
#+end_src

#+begin_src emacs-lisp :tangle no

  ;; faire une hiérarchie. un tag peut apartenir à plusieurs hiérarchie. il faut donc qu'il soit unique pour mes cours (S4SVT par exemple)
  (setq org-tag-alist '(:startgrouptag
                        ("GTD")
                        :grouptags
                        ("Control")
                        ("Persp")
                        :endgrouptag
                        :startgrouptag
                        ("Control")
                        :grouptags
                        ("Context")
                        ("Task")
                        :endgrouptag
                        ))

  (setq org-tag-alist '((Test) (GTD) 
                        ))

#+end_src

***** Tag qui sont pas à 2 km, mais juste après le titre

#+begin_src emacs-lisp
  (setq org-tags-column 0)
#+end_src

***** Nouvelle fonction pour ajout de tag

Fait appel à la fonction pour ajouter un tag à la personne 

#+begin_src emacs-lisp
  (defun vulpea-tags-add ()
    "Add a tag to current note."
    (interactive)
    ;; since https://github.com/org-roam/org-roam/pull/1515
    ;; `org-roam-tag-add' returns added tag, we could avoid reading tags
    ;; in `vulpea-ensure-filetag', but this way it can be used in
    ;; different contexts while having simple implementation.
    (when (call-interactively #'org-roam-tag-add)
      (vulpea-ensure-filetag)))

#+end_src
***** Fonction permettant d'enlever le tag BROUILLON

#+begin_src emacs-lisp

  (defun cp-vulpea-buffer-tags-remove-BROUILLON ()
    "Use all files for org-agenda."
    (interactive)
    (vulpea-buffer-tags-remove "BROUILLON"))
  
#+end_src
***** Permet de rechercher avec une hiérarchie !

  (cp/vulpea-select-from-tags-with-children '("Persp"))

#+begin_src emacs-lisp

  (defun cp/org-get-tags-with-children(tags)
    "Take a list of tag, and return this list of tag WITH the sub-tags (define in org-tag-alist) of each tag in entry"
    (interactive)
    (let (tags-result)
      (dolist (tag tags)
        (dolist (tag-to-add (org-tags-expand tag t))
          (push tag-to-add tags-result)))
      (delete-dups tags-result)
      )
    )

  (defun cp/vulpea-select-from-tags-with-children (tags)
    "Takes a list of tags, and allows the user to choose a note that has one of these tags OR has a child tag from the list given in parameter"
    (let ((links (vulpea-db-query-by-tags-some (cp/org-get-tags-with-children tags))))
      (unless links
        (user-error "There are note with the current tag (or children)"))
      (vulpea-find
       :candidates-fn (lambda (_) links)
       :require-match t))
    )


#+end_src

***** Tag évènement

****** Définition du tag
#+begin_src emacs-lisp

  (setq cp/tag-for-event "évènement")

#+end_src

****** Trouver la dernière note avec le tag évènement créer yeah

Se base sur les ids pour la date ctime

#+begin_src emacs-lisp

  (defun cp/find-last-note-with-tag-event ()
    "DOCSTRING"
    (interactive)
    (find-file
     (caar
      (org-roam-db-query
       [:select [nodes:file]
                :from tags
                :left-join nodes
                :on (= tags:node-id nodes:id)
                :where (like tag  $r1)
                :order-by [(desc node-id)]
                :limit 1
                ]
       (concat "%\""(format "%s" cp/tag-for-event) "\"%")))))

#+end_src


**** TODO Fonctions gérant l'insertions des métadatas automatiquement avec les tags 
:LOGBOOK:
- State "TODO"       from              [2022-08-05 Fri 23:03]
:END:
***** Les fonctions
****** Fonction permettant d'avoir la liste des métadata d'une note

#+begin_src emacs-lisp

  (defun cp/vulpea-note-meta-get-list-of-name (note)
    "Get a list of all metadata from NOTE"
    (mapcar 'car (vulpea-note-meta note)))

#+end_src
****** Fonction pour parser liste de liste ne hash

#+begin_src emacs-lisp 

  (defun cp/xah-list-to-hash (list)
    "Return a list that represent the HASHTABLE
              Each element is a proper list: '(key value).
              URL `http://xahlee.info/emacs/emacs/elisp_hash_table.html'
              Version 2019-06-11 2022-05-28"
    (let ((myHash (make-hash-table :test 'equal)))
      (mapcar
       (lambda (x)
         (let ((k (car x))
               (v (car(last x)))
               )
           (message "v =%s" v)
           (puthash k v myHash)
           )
         )
       list)
      myHash))

  ;; (setq var '(
  ;; ("salut" ("val" "vul"))
  ;; ("key" ("val" "vul"))
  ;; ))
  ;; (setq test (cp/xah-list-to-hash var))
  ;; (gethash "salut" test)


#+end_src
****** Permet d'avoir les tags d'une note

#+begin_src emacs-lisp
(defun cp/vulpea-buffer-tags-get (note)
    "Return filetags value for a note."
    (save-window-excursion
      (find-file (vulpea-db-get-file-by-id (vulpea-note-id note)))
      (vulpea-buffer-prop-get-list "filetags" "[ :]")))
#+end_src

***** Variable définissant ma hérirachie

#+begin_src emacs-lisp

  ;; tags à ignorer
  (setq ignore-meta '("Origine" "Lieu" "Fait" "" cp/vulpea-date))

  ;; mes tags avec leurs propriétés
  (setq tags-for-meta-list '(
                             ("RECETTE" ("temps" "autre"))
                             ("INSTALLATION" ("val" "vul" "vol"))
                             ("Blog" ("Publish Date" "Pulbished Where" "Published Link"))
                             ("nateun" ("val"))
                             ))
  (setq tags-for-meta (cp/xah-list-to-hash tags-for-meta-list))

  ;; (gethash "salut" tags-for-meta)

  (defun all-meta-list()
    "Renvoie la liste de toutes mes métadata présente dans ma hiérarchie"
    (delq nil (delete-dups (let (result)
                             (dolist (value (hash-table-values tags-for-meta))
                               (setq result (append result value)))
                             result))))



#+end_src

***** Base (à renommer)
#+begin_src emacs-lisp :tangle no

  ;; une fonction qui update. appele
  ;; une fonction qui récupère les tags
  ;; une fonction qui traduit les tags en métadata et qui les ajoute si besoin
  ;; pour mettre à jour mes tags, pour la fonction du mec de vulpea

  (defun cp/vulpea-buffer-update-meta ()
    (interactive)
    (when-let ((note (vulpea-db-get-by-id (save-excursion
                                            (goto-char (point-min))
                                            (org-id-get)))))
      (cp/vulpea-buffer-update-meta-add note)
      (cp/vulpea-buffer-update-meta-remove note))
    )

  (defun cp/vulpea-buffer-update-meta-add(note)
    "Update la note en fonction de ses tags grâce à une variable globa"
    (let ((tags (cp/vulpea-buffer-tags-get note)))
      (dolist (tag tags)
        (when-let ((list-of-meta (gethash tag tags-for-meta)))
          (dolist (meta list-of-meta)
            (unless (vulpea-meta-get note meta))
            (when-let ((prop meta)
                       (value-type (completing-read
                                    (format "Valeur pour la métadata \"%s\" dans la note \"%s\" : " meta (vulpea-note-title note))
                                    '(string number link note)
                                    nil 'require-match))
                       (value (vulpea-meta--read-value value-type)))
              (vulpea-meta-set note prop value 'append)))))
      ;; cas de zotero ici ?

      ))

  (defun cp/vulpea-buffer-update-meta-remove(note)
    "Idem que l'autre, mais les supprime si elles font pas parti de la liste"
    (when-let ((metas (cp/vulpea-note-meta-get-list-of-name note))
               (tags (cp/vulpea-buffer-tags-get note))
               (all-meta (all-meta-list))
               )
      (dolist (meta metas)
        (let ((delete nil))
          (when (not (member meta ignore-meta)) ;; ici, mettre si appartient pas à zotero
            (unless (member meta all-meta) 
              (setq delete t))) 
          (when delete
            (message "La métadata \"%s\" dans la note \"%s\" a été supprimé "meta (vulpea-note-title note))
            (vulpea-meta-remove note meta))))))



  ;; pour mettre à jour lors ce que je modifie ma liste de tags ! à appeler pour faire une "mise à jour" lors du changement de la variable définissant ma hiérarchie
  (defun cp/vulpea-update-all-metadata-tag
      (interactive)
    (dolist (file (org-roam-list-files))
      (message "processing %s" file)
      (with-current-buffer (or (find-buffer-visiting file)
                               (find-file-noselect file))
        (cp/vulpea-buffer-update-meta)
        )))

  (add-hook 'before-save-hook #'cp/vulpea-buffer-update-meta)

#+end_src


**** Gestion des polysèmes

***** Fonction permettant de faire la pages de polysémes : 

gestion des homonymes : une page homonyme généré automatiquement. Fonction : scan les notes et dès que trouve "logique (blabla)" et "logique (blublu)", soit créer la page logique homonyme et insère une liste de liens dedans, soit la page est déjà créer et met à jour la liste. Fonction différentes pour mettre à jour (rajoute à la fin quoi)



Principe de base :
=simplifier les choses en stockant directements les notes au lieu des id ?=
Deux dico : un dico A et un dico B
Dico A regroupe toutes mes notes, structure : 
titleDeLaNoteSansLesParenthèses : listeDesIdPossédantsCeTitre
Dico B regroupe seulements mes notes avec polysèmes (je garde seulements les notes du dico A qui ont listeDesIdPossédantsCeTitre de taille supérieur ou égale à 2). structure :
titleDeLaNoteSansLesParenthèsesSupérieurÀ2 : listeDesIdPossédantsCeTitre

Test de performances OK :

#+begin_src emacs-lisp :tangle no
  (setq x 0)
  (while (< x 100000)
    ;; (print (format "number is %d" x))
    (setq x (1+ x)))
  
  (defun silly-loop (n)
    "Return the time, in seconds, to run N iterations of a loop."
    (let ((t1 (float-time)))
      (while (> (setq n (1- n)) 0))
      (- (float-time) t1)))


  (silly-loop 10000000)
#+end_src


1. création du dico A en partant de rien comparer chaque title de note à toutes les autres sans les parenthèses
   #+begin_src emacs-lisp :tangle no

        (defun title-without-parens-and-space (name)
          (string-trim (substring name 0
                                  (if (string-match "\\(\(\\)" name)
                                      (string-match "\\(\(\\)" name) 
                                    (length name)))))

        (defun cp-hash-for-polyseme ()
          "Renvoie un dico, avec clé les titre des notes en double moins les parenthèse, en en valeur une liste d'id qui sont les notes en doubles"
          (let ((nodes (org-roam-db-query [:select [title id] :from notes]))
                (hash (make-hash-table :test 'equal)))
            (dolist (node nodes)
              (let* (
                     (nameComplete (car node))
                     ;; on récupère le nom sans les parenthèses !
                     (name (title-without-parens-and-space nameComplete))
                     (id (last node))
                     )
                (if (gethash name hash)
                    (puthash name  (push id (gethash name hash)) hash) ;; si ça existe, il faut ajouter à la liste l'id
                  (puthash name (list id) hash) ;; si ça n'existe pas, il faut ajouter le hash avec une liste du un élément avec l'id
                  )))
            ;; on return le hash
            hash
            )
          )

        ;; (xah-print-hash (cp-hash-for-polyseme))

      #+end_src

2. Je créer le dico raccourci B

   #+begin_src emacs-lisp :tangle no
     
     (defun cp-dico-B (hash)
       "on scan le dico, et si la liste fait deux ou plus, on créer la page"
       (maphash
        (lambda (k v)
          (when (< (length v) 2)
            (remhash k hash)))
        hash)
       hash ;; on renvoie hash
       )

   #+end_src

3. Faut que je stocke les dicos à un endroit. En effet, je ne veux pas à avoir à les refaire à chaque lancement d'emacs. Les stock avec le kill d'emacs je pense
   Deux solutions possibles (prendre la première et modifier le nom des fonctions):

      #+begin_src emacs-lisp :tangle no


     (defun dap--read-from-file (file)
       "Read a lisp expression from FILE."
       (with-temp-buffer
         (insert-file-contents file)
         (cl-first (read-from-string
                    (buffer-substring-no-properties (point-min) (point-max))))))

     (defun dap--persist (file to-persist)
       "Serialize TO-PERSIST to FILE."
       (with-demoted-errors
           "Failed to persist file: %S"
         (make-directory (file-name-directory file) t)
         (with-temp-file file
           (erase-buffer)
           (insert (prin1-to-string to-persist)))))

     (dap--persist "/home/utilisateur/Testdedossier/test.txt" "salu")
     (setq test (dap--read-from-file "/home/utilisateur/Testdedossier/test.txt"))


   #+end_src


  ou alors :

   #+begin_src emacs-lisp :tangle no

     (unless (file-directory-p (expand-file-name "braindump/" no-littering-var-directory))
       (mkdir (expand-file-name "braindump/" no-littering-var-directory))
       )
     (setq braindump-configuration-directory (expand-file-name "braindump/" no-littering-var-directory))

     (unless (file-exists-p (expand-file-name "hash-for-polyseme.el" braindump-configuration-directory))
       (with-temp-file (expand-file-name "hash-for-polyseme.el" braindump-configuration-directory)
         (insert ""))
       )
     (setq braindump-configuration-directory-hash (expand-file-name "hash-for-polyseme.el" braindump-configuration-directory))



     (defun print-to-file (filename data)
       (with-temp-file filename
         (prin1 data (current-buffer))))

     (defun read-from-file (filename)
       (with-temp-buffer
         (insert-file-contents filename)
         (cl-assert (eq (point) (point-min)))
         (read (current-buffer))))

     (setq malist '(1 2 4))

     ;; Usage:


     (setq monHash (read-from-file braindump-configuration-directory-hash))
           (if
               (cp-hash-for-polyseme)

               )

           )

     (print-to-file braindump-configuration-directory-hash monHash)
     ;; (1 2 "foo" (quote bar))
     (read-from-file braindump-configuration-directory-hash)
     ;; (1 2 "foo" (quote bar))

     ;;pour quand les stocker
     ;; (add-hook 'kill-emacs-hook #'org-icalendar-combine-agenda-files-foreground)

  #+end_src


  
4. TODO Fonction de mise à jour de mon dico A. Elle consiste à : 
   Prendre mon dico A, et appliquer la condition de la fonction de création du dico
5. Recréation du dico B, si la variable B est modifié, alors je dois recréer mes pages
   #+begin_src emacs-lisp :tangle no

     ;;ceci marche dés que je touche à la variable, pas seulement si je la modifie.
     ;; (defun my-watch (symbol newval op where)
     ;; (message "SYM: %S, VAL: %S, OP: %S, WHERE: %S" symbol newval op where))
     ;; (add-variable-watcher 'teste #'my-watch)

     ;;ceci fonctionne :

     (setq dico-B-ancien dico-B)
    (setq dico-B new-dico-from-maj)
     ;;puis on compare si dico dico-B = dico-B-ancien en les transformant en liste et avec la condition d'après


     (setq myHash
           #s(hash-table
              size 30
              test equal
              data (
                    "joe" 3
                    "jane" 9
                    "liz" 5 )))

     (setq myHash2
           #s(hash-table
              size 30
              test equal
              data (
                    "joe" 3
                    "jane" 9
                    "liz" 5 )))


     (defun xah-hash-to-list (hash-table)
       "Return a list that represent the HASH-TABLE
          Each element is a list: (list key value).
          See also, emacs 24.4's new functions.
           (require 'subr-x)
           `hash-table-keys'
           `hash-table-values'
          http://ergoemacs.org/emacs/elisp_hash_table.html
          Version 2015-04-25"
       (let (result)
         (maphash
          (lambda (k v)
            (push (list k v) result))
          hash-table)
         result))

     (if (equal (xah-hash-to-list myHash) (xah-hash-to-list myHash2))
         (message "vrai")
       (message "faux")
       )





   #+end_src

6. pour recréer ou créer une page de polysème :
   Pour créer la note : 
   #+begin_src emacs-lisp :tangle no
     (vulpea-create
      "Rich note"
      "pages/%<%Y%m%d%H%M%S>-${slug}.org"
      :properties '(("COUNTER" . "1")
                    ("STATUS" . "ignore")
                    ("ROAM_ALIASES" . "\"Very rich note with an alias\""))
      :tags '("documentation" "showcase")
      :head "#+author: unknown\n#+date: today"
      :body "It was a very %?nice day.\n\nBut I didn't feel that."
      ;; :immediate-finish t
      )
   #+end_src
   1. voir si la page existe, créer si elle existe pas (dans le dossier polysème)
   2. Si elle existe pas, mettre un truc de ce style : 
      #+begin_example
   PROPRIÉTÉ
   Title : Mercure
   (Description du terme)
   blabla
   Mercure vient du latin blabla.



   * "Le concept X peut posséder ces différentes significations selon le contexte : "
   Ce qu'i' y a au dessus de cette ligne sera modifié par moi
    Ce qui y a en dessous de cette ligen sera généré automatiquement

      #+end_example
   3. mettre en heading quelque chose comme :
      "Le concept X peut posséder ces différentes significations selon le contexte : "
      Puis, clean la suite de ce titre
   4. revenir sur le titre
   5. insérer en dessous du heading, pour chaque valeur de la liste, un lien vers les pages :

      #+begin_example
      * "Le concept X peut posséder ces différentes significations selon le contexte : "
   - liste
   - de
   - là où la chaîne de caractère "mercure" est présente
   - d'abord ceux en premier
   - Mercure (dieu)
   - Mercure (planète)
      #+end_example

7. insérer dans les notes relié la métadada "polysème :: page vers Mercure"
   Je prends mon dico B, et pour chaque note clé, j'ajoute à la note avec id une métadata

   #+begin_src emacs-lisp :tangle no
     ;; un truc de ce style :
     ;; transformer le dico en liste je pense, cera plus simple
     (dolist (node nodes)
       (vulpea-meta-set (last notes) "Polysème"
                        ;;insérer le lien vers la page
                        )
       )


   #+end_src
8. maj : 
   1. comparer la nouvelle notes à toutes les autres
   2. cas nouveau polysème
   3. cas ancien polysème
9. 





***** Fonction permettant de supprimer les parenthèses lors de l'insertion de polysèmes 

Pratique pour pas lire à chaque fois "Mercure (dieu)" alors que je sais très bien qu'avec le contexte c'est le dieu.

#+begin_src emacs-lisp

  (defun delete-parens-note-after-insertion(_)
    "Permet de supprimer les parenthèse. Attention, ne marche qu'après l'insertion !"
    (interactive)
    (save-excursion
      (let
          (($p2 (point))
           ($p1 (search-backward "[")))
        (save-restriction
          (narrow-to-region $p1 $p2)
          (when (search-forward "(" nil t) ;;cas où je trouve la parenthèse
            (unless (boundp 'delete-parens-for-node) ;; si pas de variable local activé
              (defvar-local delete-parens-for-node nil)
              )
            (when (and (not delete-parens-for-node) (y-or-n-p "Insertion d'une note avec des parenthèses, voulez vous les supprimer ? Si oui, vous n'aurez plus cette demande dans le buffer actuel la prochaine fois"))
              (setq-local delete-parens-for-node t)
              )
            (when delete-parens-for-node
              (xah-delete-backward-char-or-bracket-text)
              (xah-fly-delete-spaces)
              )))))
    )

  ;;on le "hook"
  ;; (advice-add 'vulpea-insert :after #'delete-parens-note-after-insertion)
  ;; (advice-remove 'vulpea-insert  #'delete-parens-note-after-insertion)

  (add-hook 'vulpea-insert-handle-functions #'delete-parens-note-after-insertion)
  ;; (remove-hook 'vulpea-insert-handle-functions #'delete-parens-note-after-insertion)

#+end_src



**** Gestion des personnes et des lieux

***** Personne et lieu

Cela permet de faire des projets également pour des personnes (Nell hehe)
Si je connais la personne, alors je la tag avec people. Si j'ai des choses en rapport à faire avec elle, alors je lui mets un tag "@NomDeLaPersonne"

Je peux chercher les tag dans l'agenda

Chaque personne à son fichier org roam.

Pour appeler une fonction qui ajoute les tags, et si jamais le tag people est mis, alors ajoute automatiquement le tag de la personne au fichier !!!  Pratique


Même raisonnement pour les lieux

****** Créer automatiquement le tag "NomPersonne" si la personne à le tag people

Appeler dans vulpea-tags-add

#+begin_src emacs-lisp
  (defun vulpea-ensure-filetag ()
    "Add respective file tag if it's missing in the current note."
    (let ((tags (vulpea-buffer-tags-get))
          (tag (vulpea--title-as-tag)))
      (when (and (seq-contains-p tags "PERSONNE")
                 (not (seq-contains-p tags tag)))
        (vulpea-buffer-tags-add tag))

      (when (and (seq-contains-p tags "LIEU")
                 (not (seq-contains-p tags tag)))
        (vulpea-buffer-tags-add tag))
      ))

  (defun vulpea--title-as-tag ()
    "Return title of the current note as tag."
    (vulpea--title-to-tag (vulpea-buffer-title-get)))

  (defun vulpea--title-to-tag (title)
    "Convert TITLE to tag."
    (concat "@" (s-replace " " "" title)))

#+end_src

****** Automatisation insertion tag de la personne qd on la cite ailleurs ! 

Qd on insère avec la fonction vulpea-insert une personne ailleurs dans un todo, insère le tag automatiquement
#+begin_src emacs-lisp

  (defun my-vulpea-insert-handle (note)
    "Hook to be called on NOTE after `vulpea-insert'."
    (when-let* ((title (vulpea-note-title note))
                (tags (vulpea-note-tags note)))
      (when (seq-contains-p tags "PERSONNE")
        (save-excursion
          (ignore-errors
            (org-back-to-heading)
            (when (eq 'todo (org-element-property
                             :todo-type
                             (org-element-at-point)))
              (org-set-tags
               (seq-uniq
                (cons
                 (vulpea--title-to-tag title)
                 (org-get-tags nil t))))))))


      (when (seq-contains-p tags "LIEU")
        (save-excursion
          (ignore-errors
            (org-back-to-heading)
            (when (eq 'todo (org-element-property
                             :todo-type
                             (org-element-at-point)))
              (org-set-tags
               (seq-uniq
                (cons
                 (vulpea--title-to-tag title)
                 (org-get-tags nil t))))))))


      ))

  (defun vulpea--title-to-tag (title)
    "Convert TITLE to tag."
    (concat "@" (s-replace " " "" title)))

  (add-hook 'vulpea-insert-handle-functions
            #'my-vulpea-insert-handle)

#+end_src

****** Fonction qui demande TOUTES les tâches associé à une personne

#+begin_src emacs-lisp
  (defun vulpea-agenda-personne ()
    "Show main `org-agenda' view."
    (interactive)
    (let* ((person (vulpea-select
                    "Person"
                    :filter-fn
                    (lambda (note)
                      (seq-contains-p (vulpea-note-tags note)
                                      "PERSONNE"))))
           (node (org-roam-node-from-id (vulpea-note-id person)))
           (names (cons (org-roam-node-title node)
                        (org-roam-node-aliases node)))
           (tags (seq-map #'vulpea--title-to-tag names))
           (query (string-join tags "|")))
      (dlet ((org-agenda-overriding-arguments (list t query)))
        (org-agenda nil "M"))))


  (defun vulpea-agenda-lieu ()
    "Show main `org-agenda' view."
    (interactive)
    (let* ((person (vulpea-select
                    "Person"
                    :filter-fn
                    (lambda (note)
                      (seq-contains-p (vulpea-note-tags note)
                                      "LIEU"))))
           (node (org-roam-node-from-id (vulpea-note-id person)))
           (names (cons (org-roam-node-title node)
                        (org-roam-node-aliases node)))
           (tags (seq-map #'vulpea--title-to-tag names))
           (query (string-join tags "|")))
      (dlet ((org-agenda-overriding-arguments (list t query)))
        (org-agenda nil "M"))))

#+end_src



****** Fonction appelé lors de la création de la capture pour permettre de créer un lieu ou d'un contact/personne

#+begin_src emacs-lisp

  (defun cp/org-roam-property-file-add (prop val)
    "Add VAL value to PROP property for the node at point.
          Both, VAL and PROP are strings."
    (let* ((p (org-entry-get (point-min) prop))
           (lst (when p (split-string-and-unquote p)))
           (lst (if (memq val lst) lst (cons val lst)))
           (lst (seq-uniq lst)))
      (save-excursion
        (goto-char (point-min))
        (org-set-property prop (combine-and-quote-strings lst))
        val
        )
      ))

  ;;  TODO : (read-string "Enter name:") renvoie un string
  (defun cp/add-other-auto-props-to-org-roam-properties ()
    ;; if the file already exists, don't do anything, otherwise...
    ;; if there's also a CREATION_TIME property, don't modify it
    (when (member "PERSONNE" (vulpea-buffer-tags-get))
      (cp/org-roam-property-file-add "VERSION" "3.0")
      (cp/org-roam-property-file-add "EMAIL" "")
      (cp/org-roam-property-file-add "EMAIL_HOME" "")
      (cp/org-roam-property-file-add "EMAIL_WORK" "")
      (cp/org-roam-property-file-add "PHONE" "")
      (cp/org-roam-property-file-add "CELL" "")
      (cp/org-roam-property-file-add "LANDLINE_HOME" "")
      (cp/org-roam-property-file-add "LANDLINE_WORK" "")
      (cp/org-roam-property-file-add "TITLE" "")
      (cp/org-roam-property-file-add "ORG" "")
      (cp/org-roam-property-file-add "ADDRESS_HOME" "")
      (cp/org-roam-property-file-add "ADDRESS_WORK" "")
      (cp/org-roam-property-file-add "BIRTHDAY" "")
      (cp/org-roam-property-file-add "URL" "")
      (cp/org-roam-property-file-add "NOTE" "")
      (cp/org-roam-property-file-add "CATEGORIES" "")
      (let
          ((note (vulpea-db-get-by-id (vulpea-db-get-id-by-file (buffer-file-name))))
           )
        (add-contact-to-file-of-contact note)
        )

      ;;on met à jour les tags après l'insertion des options
      (vulpea-ensure-filetag)

      )
    (when (member "LIEU" (vulpea-buffer-tags-get))


      ;;on met à jour les tags après l'insertion des options
      ;; (vulpea-ensure-filetag)
      )

    )

  ;;on hook après la capture
  (add-hook 'org-capture-after-finalize-hook #'cp/add-other-auto-props-to-org-roam-properties)

  ;; (remove-hook 'org-roam-capture-new-node-hook #'cp/add-other-auto-props-to-org-roam-properties)

#+end_src



****** On ajoute les personnes au fichiers pour pouvoir exporter en vcard dans le fichier


1. aller dans inbox
2. créer un sous titre
3. ajouter la ligne avec le bon lien !
   #+transclude: [[id:20220621120442360949][test contac]] :lines 0-20
4. il faut le hook avec l'autre fonction, voir même la lancer en même temps dans "when personne" !

#+begin_src emacs-lisp

  (setq file-of-contact (expand-file-name (concat org-roam-directory "pages/20220621120424-liste_de_mes_contacts_pour_org_contact.org")))
  (defun add-contact-to-file-of-contact (note)
      (save-window-excursion
        (find-file file-of-contact)
        (search-forward "Inbox" nil t)
        (org-insert-heading-after-current)
        ;; (org-metaright)
        (insert (vulpea-note-title note))
        (newline)
        ;;on insère le lien, je pourrais concat mais flemme
        (insert ":PROPERTIES:")
        (newline)
        (insert "#+transclude:")
        ;;pour insérer la note (prendre fonction vulpea-utils-link-make-string un jour)
        (progn
          (insert (org-link-make-string
                   (concat " id:" (vulpea-note-id note))
                   (vulpea-note-title note)))
          (run-hook-with-args
           'vulpea-insert-handle-functions
           note))
        (insert " :lines 3-18")
        (newline)
        (insert ":END:")
        )
    )

#+end_src


****** Fonction pour exporter mes contacts
#+begin_src emacs-lisp

  (use-package org-vcard
    :init
    ;;la version utilisée (pour pouvoir y envoyer sur google)
    (setq org-vcard-default-version "3.0")
    :config
    (setq org-vcard-default-export-file (concat org-roam-directory "Contacts.vcf"))
    )


  (fset 'cp/export-org-contact-macro
        (kmacro-lambda-form [?a ?o ?r ?g ?- ?v ?c ?a ?r ?d ?- ?e ?x ?p ?o ?r ?t return ?b ?u return ?f ?i ?l return home ?b ?p ?n ?u ?C ?o ?n ?t ?a ?c ?t ?s ?. ?v ?c ?f return] 0 "%d"))


  (defun cp/function-to-export-org-contact ()
    (interactive)
    (save-window-excursion
      (find-file file-of-contact)
      (cp/export-org-contact-macro)
      )
    )


#+end_src

**** TODO maj Insérer du texte dans un note en fonction d'une autre 

Dépendant des ids dans id-locations.el

#+begin_src emacs-lisp
  (use-package org-transclusion
    :config
    ;;pour exporter les propriétés
    (setq org-transclusion-exclude-elements '(property-drawer
                                              ;; center-block
                                              keyword ;; pour pas exporter les truc avec #+ (comme les titres)
                                              )))
#+end_src

**** Gestion des fichiers et des dossiers en pièce jointe 

***** Quand on rajoute un fichier en attachment, on store le link pour l'insertion

#+begin_src emacs-lisp
  (setq org-attach-store-link-p 'file)
  ;; pour que le lien soit relatif au dossier data, modifier cette fonction
  ;; org attach attach
#+end_src



***** On créer les dossier par années/mois/jour/lerest par rapport à la date de la création du noeud pour les rangements

#+begin_src emacs-lisp

  ;;The first function in this list defines the preferred function which will be used when creating new attachment folders.
  (setq org-attach-id-to-path-function-list
        '(org-attach-id-ts-folder-format
          org-attach-id-uuid-folder-format))


  (defun org-attach-id-ts-folder-format (id)
    "Translate an ID based on a timestamp to a folder-path.
    Useful way of translation if ID is generated based on ISO8601
    timestamp.  Splits the attachment folder hierarchy into
    year-month, the rest."
    (format "%s" id)
    )



#+end_src

ancien : 
#+begin_src emacs-lisp :tangle no
(defun org-attach-id-ts-folder-format (id)
    "Translate an ID based on a timestamp to a folder-path.
  Useful way of translation if ID is generated based on ISO8601
  timestamp.  Splits the attachment folder hierarchy into
  year-month, the rest."
    (format "%s/%s/%s/%s"
            (substring id 0 4)
            (substring id 4 6)
            (substring id 6 8)
            (substring id 9)
            )
    )
#+end_src





***** Dired attachment

2 windows : une avec fichiers dired, l'autre avec le curseur sur le subtree ou attacher les fichiers
marquer les fichiers sur dired, appeler la fonction org-attach-dired-to-subtree, et voilà !


#+begin_src emacs-lisp
(add-hook 'dired-mode-hook
          (lambda ()
            (define-key dired-mode-map
              (kbd "C-c C-x a")
              #'org-attach-dired-to-subtree)))
#+end_src

              

***** Chemin de org attach

#+begin_src emacs-lisp
    ;; (setq org-attach-id-dir (expand-file-name ".data/" vulpea-directory))

  (setq org-attach-id-dir (expand-file-name ".data/" org-roam-directory))

#+end_src

***** Pour pouvoir attacher des dossiers

Patch de la fonction pour pouvoir attach des dossiers

#+begin_src emacs-lisp

  ;; (advice-remove 'org-attach-attach 'my-new-org-attach-attach)

  (defun org-attach-attach (file &optional visit-dir method)
    "Move/copy/link FILE into the attachment directory of the current outline node.
  If VISIT-DIR is non-nil, visit the directory with `dired'.
  METHOD may be `cp', `mv', `ln', `lns' or `url' default taken from
  `org-attach-method'."
    (interactive
     (list
      (read-file-name "File to keep as an attachment: "
                      (or (progn
                            (require 'dired-aux)
                            (dired-dwim-target-directory))
                          default-directory))
      current-prefix-arg
      nil))
    (setq method (or method org-attach-method))
    (when (file-directory-p file)
      (setq file (directory-file-name file)))
    (let ((basename (file-name-nondirectory file)))
      (let* ((attach-dir (org-attach-dir 'get-create))
             (attach-file (expand-file-name basename attach-dir)))
        (cond
         ((eq method 'mv) (rename-file file attach-file))
         ((eq method 'cp)
          (if (file-directory-p file)
              (copy-directory file attach-file nil nil t)
            (copy-file file attach-file)))
         ((eq method 'ln) (add-name-to-file file attach-file))
         ((eq method 'lns) (make-symbolic-link file attach-file))
         ((eq method 'url) (url-copy-file file attach-file)))
        (run-hook-with-args 'org-attach-after-change-hook attach-dir)
        (org-attach-tag)
        (cond ((eq org-attach-store-link-p 'attached)
               (push (list (concat "attachment:" (file-name-nondirectory attach-file))
                           (file-name-nondirectory attach-file))
                     org-stored-links))
              ((eq org-attach-store-link-p t)
               (push (list (concat "file:" file)
                           (file-name-nondirectory file))
                     org-stored-links))
              ((eq org-attach-store-link-p 'file)
               (push (list (concat "file:" attach-file)
                           (file-name-nondirectory attach-file))
                     org-stored-links)))
        (if visit-dir
            (dired attach-dir)
          (message "File %S is now an attachment" basename)))))

#+end_src


(defun my-new-org-attach-attach (file &optional visit-dir method)
    "Move/copy/link FILE into the attachment directory of the current outline node.
        If VISIT-DIR is non-nil, visit the directory with `dired'.
        METHOD may be `cp', `mv', `ln', `lns' or `url' default taken from
        `org-attach-method'."
    (interactive
     (list
      (read-file-name "File to keep as an attachment: "
                      (or (progn
                            (require 'dired-aux)
                            (dired-dwim-target-directory))
                          default-directory))
      current-prefix-arg
      nil))
    (setq method (or method org-attach-method))
    (let ((basename (file-name-nondirectory file)))
      (let* ((attach-dir (org-attach-dir 'get-create))
             (attach-file (expand-file-name basename attach-dir)))
        (cond
         ((eq method 'mv) (rename-file file attach-file))
         ((eq method 'cp) (if (file-directory-p file)
                              (copy-directory file
                                              (concat attach-file
                                                      (concat "/" (file-name-nondirectory
                                                                   (directory-file-name
                                                                    (file-name-directory file))))))
                            (copy-file file attach-file)
                            ))
         ((eq method 'ln) (add-name-to-file file attach-file))
         ((eq method 'lns) (make-symbolic-link file attach-file))
         ((eq method 'url) (url-copy-file file attach-file)))
        (run-hook-with-args 'org-attach-after-change-hook attach-dir)
        (org-attach-tag)
        (cond ((eq org-attach-store-link-p 'attached)
               (push (list (concat "attachment:" (file-name-nondirectory attach-file))
                           (file-name-nondirectory attach-file))
                     org-stored-links))
              ((eq org-attach-store-link-p t)
               (push (list (concat "file:" file)
                           (file-name-nondirectory file))
                     org-stored-links))
              ((eq org-attach-store-link-p 'file)
               (push (list (concat "file:" attach-file)
                           (file-name-nondirectory attach-file))
                     org-stored-links)))
        (if visit-dir
            (dired attach-dir)
          (if (string-equal basename "")

              (message "File %S is now an attachment" (file-name-nondirectory
                                                                   (directory-file-name
                                                                    (file-name-directory file))))
              (message "File %S is now an attachment" basename)
              )
          ))))

          




***** Pour prendre des notes sur des fichiers

#+begin_src emacs-lisp
  ;; (use-package org-noter) ;; outdated ?


  ;; marche pas
  ;; (use-package org-noter
    ;; :straight (org-noter-plus-djvu
               ;; :type git
               ;; :host github
               ;; :repo "c1-g/org-noter-plus-djvu")
    ;; )


  (use-package org-remark)
  (require 'org-remark-global-tracking)
  (org-remark-global-tracking-mode +1)

  ;; Key-bind `org-remark-mark' to global-map so that you can call it
  ;; globally before the library is loaded.

  (define-key global-map (kbd "C-c n m") #'org-remark-mark)

  ;; The rest of keybidings are done only on loading `org-remark'
  (with-eval-after-load 'org-remark
    (define-key org-remark-mode-map (kbd "C-c n o") #'org-remark-open)
    (define-key org-remark-mode-map (kbd "C-c n ]") #'org-remark-view-next)
    (define-key org-remark-mode-map (kbd "C-c n [") #'org-remark-view-prev)
    (define-key org-remark-mode-map (kbd "C-c n r") #'org-remark-remove))


  ;; (use-package org-noter
  ;;   :after (:any org pdf-view)
  ;;   :config
  ;;   (setq
  ;;    ;; The WM can handle splits
  ;;    org-noter-notes-window-location 'other-frame
  ;;    ;; Please stop opening frames
  ;;    org-noter-always-create-frame nil
  ;;    ;; I want to see the whole file
  ;;    org-noter-hide-other nil
  ;;    ;; Everything is relative to the main notes file
  ;;    org-noter-notes-search-path (list org_notes)
  ;;    )
  ;;   )

#+end_src
          
**** Gestion des archives

***** Base
#+begin_src emacs-lisp


  (use-package org-archive
    :straight nil
    :defer t

    :init
    (setq-default
     org-archive-file-header-format "" ;;ce qui est affiché au début du fichier
     org-archive-location
     (concat braindump-directory "org/.archive/%s_archive" "::")
     ;; (concat braindump-directory "org/.archive/%s_archive" "::" "* Tâches archivées") pléonasme
     ;; (concat braindump-directory "org/.archive/%s_archive" "::" "datetree/")
     ;; (concat braindump-directory "org/.archive/datetree.org::datetree/")
     org-archive-save-context-info
     '(time file ltags itags todo category olpath))

    :config
    ;; (setq org-attach-archive-delete t) ;; permet, si jamais ya des pièces jointe avec un subtree qui est archivé, de les supprimer
    )

  ;; (setq org-archive-location "%s_archive::* ArchivedTasksfrom%s")
#+end_src

***** auto-archiver
****** Lors du changement d'une tâche simple

#+begin_src emacs-lisp

  (defun cp/org-archive-done-tasks ()
    (interactive)
    (when (org-roam-buffer-p)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward
                (concat "\\* " (regexp-opt org-done-keywords) " ") nil t)
          ;; (goto-char (line-beginning-position))
          (when (= (org-outline-level) 1)
            ;; (when (y-or-n-p  (format "voulez vous archiver %S ?" (org-entry-get nil "ITEM")))
            (org-archive-subtree)
            ;; )
            )))))

  ;; (add-hook 'org-trigger-hook 'save-buffer)
  ;; (remove-hook 'org-trigger-hook 'save-buffer)

  (add-hook 'before-save-hook 'cp/org-archive-done-tasks)
  ;; (remove-hook 'before-save-hook 'cp/org-archive-done-tasks)

#+end_src

#+begin_src emacs-lisp :tangle no

  ;; auto-archiver
  (defun cp/auto-org-archive-subtree()
    (when (and (org-entry-is-done-p) (eq (org-current-level) 1))
      (when (y-or-n-p  (format "voulez vous archiver %S ?" (org-entry-get nil "ITEM")))
        (org-archive-subtree))))

  ;; (add-hook 'org-after-todo-state-change-hook 'cp/auto-org-archive-subtree)
  ;; (remove-hook 'org-after-todo-state-change-hook 'cp/auto-org-archive-subtree)


#+end_src

****** Les rdv passés en done automatiquement, et donc provoque l'archivage

Au final, je fais les actions, puis à la sauvegarde, j'archive.


#+begin_src emacs-lisp
  ;; commande pour trouver et mettre en done les évènement passée
  (defun cp/org-ql-search-for-past-timestamps()
    (org-ql-select (org-agenda-files)
      '(and
        (not (scheduled))
        (not (deadline))
        (not (done))
        (ts-active :to today)
        )
      :action '(org-todo "DONE")
      )
    )

  ;; on clean quand on kill emacs
  (add-hook 'kill-emacs-hook #'cp/org-ql-search-for-past-timestamps)
#+end_src


Attendre réponse mec org-ql. Juste faire la commande suivante, tout sélectionner et mettre en done (B puis t puis done)

Nombreux bugs, notamment au niveau de l'archivage. Il semblerait que le curseur se déplace ailleurs avant de demander pour l'archivage, ce qui veut dire qu'il archive le mauvais lol.

Au final, deux cas : 
1. Niveau 1 : certains heading ne sont pas archivé, on fait donc une boucle tant qu'il en reste
2. pas niveau 1, sinon ça break tout. On mets juste la tâche en done. Auto-archivage ne fonctionne pas encore bien non plus. 


#+begin_src emacs-lisp :tangle no
  
    (defun test()
      (interactive)
      (save-excursion
        (org-archive-subtree)))

  (org-ql-select (org-agenda-files)
        '(and
          (not (scheduled))
          (not (deadline))
          (not (done))
          (ts-active :to today)
          )
        :action '(org-archive-subtree)
        )



    ;; archiver les choses qui ne doivent pas avoir une action et qui sont juste timestamp (exemple : un rdv)
    ;; pas besoin de while normalement, juste là ça bug. Tant qu'il en reste, refaire la commande


    ;; seulement pour les niveaux 1
    (defun cp/auto-org-done-task-past-timestamp-and-not-todo-level-one()
      (while (org-ql-select (org-agenda-files)
               '(and
                 (not (scheduled))
                 (ts-active :to today)
                 (level 1)
                 )
               )
        (org-ql-select (org-agenda-files)
          '(and
            (not (scheduled))
            (ts-active :to today)
            (level 1)
            )
          :action '(org-todo "DONE")
          )
        )
      )

    ;; (cp/auto-org-done-task-past-timestamp-and-not-todo-level-one)

    (defun cp/auto-org-done-task-past-timestamp-and-not-todo-not-level-one()
      (while (org-ql-select (org-agenda-files)
               '(and
                 (not (scheduled))
                 (not (todo "DONE"))
                 (ts-active :to today)
                 (level '> 1)
                 )
               )
        (org-ql-select (org-agenda-files)
          '(and
            (not (scheduled))
            (not (todo "DONE"))
            (ts-active :to today)
            (level '> 1)
            )
          :action '(org-todo "DONE")
          )))
    ;; (cp/auto-org-done-task-past-timestamp-and-not-todo-not-level-one)

#+end_src



(org-ql-select (org-agenda-files)
        '(and
          (rifle "le focus")
          (scheduled :to today)
          (ts-active :to today))
        ;; :action '(org-toggle-tag "Emacs" 'on) ;; mettre la bonne action ici
        ;; :action '(org-todo "DONE")
        :action #'org-archive-subtree)

**** Gestion de l'intéraction avec le pc

#+begin_src emacs-lisp
  (require 'org-protocol)
#+end_src

**** Gestion du cryptage

Pour crypter automatiquement : epa + tag "crypt" sur des arbres org-mode

***** TODO EPA

Edit .gnupg/gpg-agent.conf (create it if necessary) by adding the following:
allow-emacs-pinentry

#+begin_src emacs-lisp 

  (use-package epa-file
    :straight nil ;; included with Emacs
    :config
    (epa-file-enable)
    ;; (setq epa-file-encrypt-to '("my@email.address.org"))
    (setq epa-file-select-keys nil)
    (when termux-p
      (setq epa-pinentry-mode 'loopback) ;;demande le mdp dans le mini-buffer
      (setq epg-gpg-program "/data/data/com.termux/files/usr/bin/gpg")
      )
    )

#+end_src

***** Org


#+begin_src emacs-lisp :tangle no
  (load "~/.emacs.d/config/lisp/sensitive-minor-mode.el")
  (require 'sensitive-minor-mode)
#+end_src

#+begin_src emacs-lisp



  (use-package org-crypt
    :straight nil  ;; included with org-mode
    :after org
    :custom
    ;; (org-crypt-key "my@email.address.org")
    (org-crypt-key nil)
    :config
    (org-crypt-use-before-save-magic)
    ;; org-tags-exclude-from-inheritance '("crypt")
    ;; (require 'org-crypt)
    )


#+end_src

**** Télécharger les infobox de Wikipédia rapidement (sympas)

#+begin_src emacs-lisp

  (use-package wikinforg
    :config
    (setq wikinforg-wikipedia-edition-code "fr")
    )

#+end_src

**** Gestion des dates


***** Gestion de la fonction d'annotation
#+begin_src emacs-lisp
  ;; modification de ma fonction d'annotation
  (setq vulpea-select-annotate-fn #'cp/vulpea-select-annotate)

  ;; variable de la date
  (setq cp/vulpea-date "date")

  ;; ajout de la date dans les annotations
  (defun cp/vulpea-select-annotate (note)
    "Annotate a NOTE for completion."
    (let* ((alias-str
            (if (vulpea-note-primary-title note)
                (concat "("
                        (vulpea-note-primary-title note)
                        ")")
              ""))
           (tags-str (mapconcat
                      (lambda (x) (concat "#" x))
                      (vulpea-note-tags note)
                      " "))
           (date-str (if (vulpea-meta-get note cp/vulpea-date)
                         (vulpea-meta-get note cp/vulpea-date)
                       ;; (make-string 8 (string-to-char " "))
                       ""
                       ))
           (sections (seq-remove #'string-empty-p
                                 (list
                                  date-str
                                  alias-str
                                  tags-str
                                  ))))
      (if (null sections)
          ""
        (concat " " (string-join sections " ")))))
#+end_src

***** Gestion de la durée des tâches 

****** Gestion de l'effort estimate

Je peux juste afficher les tâche sup inf ou égale à quelque chose avec org-agenda-filter-by-effort

****** Gestion de (org-clock)
******* TODO Package pratique pour nouvelle fonction directement dans l'agenda
:LOGBOOK:
- State "TODO"       from              [2022-11-03 Thu 21:33]
:END:
  https://github.com/dfeich/org-clock-convenience

******* Autre


R dans org-agenda pour tout voir



**** TODO Publier son site un jour
**** Fin du when
#+begin_src emacs-lisp
)
#+end_src



** Org-roam, seulement si ya mon braindump (logique)

#+begin_src emacs-lisp

  (use-package org-roam
    :if braindump-exists

#+end_src


*** Org-roam pur

**** Init

#+begin_src emacs-lisp
  :init
  ;;éviter d'avoir la nottif de version 1 à 2 
  (setq org-roam-v2-ack t)
#+end_src

**** Config

#+begin_src emacs-lisp
  :config
#+end_src

***** Mise à jour de la org-roam-db sur mes appareil si il y a un changement

#+begin_src emacs-lisp

  (defun org-roam-db-sync-when-change (event)
    (message "Mise à jour de la base de donnée d'org-roam")
    (org-roam-db-sync)  
    )

  (require 'filenotify)
  (file-notify-add-watch (concat braindump-directory "org/pages")
                         '(attribute-change) 'org-roam-db-sync-when-change)



#+end_src


***** Amélioration mineur et completion

  ;;pour mes fichiers agenda prennent en compte les hook, il suffit de faire un revert

#+begin_src emacs-lisp


  ;; complétion et proprosition
  (setq org-roam-completion-everywhere t) ;; pour avoir la complétion partout avec company
  (setq completion-ignore-case t) ;; ne dépend pas de la case pour la complétion
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-capf) ;;completion avec org-roam
    )


  (with-eval-after-load 'company-box

    (add-hook 'org-mode-hook 'company-mode)
    (add-hook 'org-mode-hook (lambda () (company-box-mode 0)))

    )
  
  ;; syncro automatique avec les fichiers
  (org-roam-db-autosync-mode)

  ;; pour améliorer les perf
  (setq org-roam-db-gc-threshold most-positive-fixnum)

  ;; On prend pas les fichiers org dans org-attach
  (setq org-roam-file-exclude-regexp ".data/")


#+end_src


***** TODO Quelles sont les liens que je veux ignorer (ou pas lol) ?
:LOGBOOK:
- State "TODO"       from              [2022-10-31 Mon 23:50]
:END:

Par exemple, si je veux que mes transclude soit considérer comme des backlinks, il faudra que je touche cette variable

#+begin_src emacs-lisp
  
  (setq org-roam-db-extra-links-exclude-keys '((node-property . ("ROAM_REFS"))
                                               (keyword . ("transclude"))))

  ;; org-roam-db-extra-links-elements
#+end_src


***** Org-roam capture

#+begin_src emacs-lisp

  ;;ajout du tag BROUILLON tant que c'est pas fini
  (defun jethro/tag-new-node-as-draft ()
    (when
        ;; (not (member (buffer-file-name) (org-roam-dailies--list-files)))
        (string-equal (expand-file-name default-directory)
                      (concat org-roam-directory org-roam-dailies-directory))
      (org-roam-tag-add '("BROUILLON"))
      )
    ;; (org-roam-tag-add '("BROUILLON"))
    )
  (add-hook 'org-roam-capture-new-node-hook #'jethro/tag-new-node-as-draft)


  (setq org-roam-capture-templates
        '(
          ("d" "default" plain "%?"
           :target (file+head "pages/%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}\n")
           :unnarrowed t)
          ("p" "connaissances multiples à trier ds 2jours" plain (file "../templatesOrgCapture/connaissance.org")
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t)

          ("l" "lien simple" plain (file "../templatesOrgCapture/lien.org")
           :target (file+head "liens/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t
           :immediate-finish t)
          ("s" "simple/basique" plain (file "../templatesOrgCapture/simple.org")
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t
           :immediate-finish t)
          ("c" "contact" plain (file "../templatesOrgCapture/contact.org")
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t)

          ("C" "Crypter" plain "%?"
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org.gpg"
                              "#+title: ${title}\n")
           :unnarrowed t)


          ("T" "Test de nouveau nom" plain "%?"
           :target (file+head "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
                              "#+title: ${title}\n")
           :unnarrowed t)

          ("r" "bibliography reference" plain
           (file "../templatesOrgCapture/key.org")
           :if-new 
           (file+head "reference/${citekey}.org" "#+title: ${title}\n")
           :unnarrowed t
           :jump-to-captured t)


          ("r" "bibliography reference" plain
           (file "../templatesOrgCapture/key.org")
           :target
           (file+head "reference/${citekey}.org" "#+title: ${title}\n")
           :unnarrowed t)
        
          )
        )

#+end_src

***** Journal

#+begin_src emacs-lisp
  ;;défini la capture de mon journal
  (setq org-roam-dailies-directory "journals/")

  (setq org-roam-dailies-capture-templates  '(
                                              ("d" "default" entry "* %<%H:%M> %?" :target
                                               (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))
                                              ))
#+end_src

***** Buffer des backlinks

#+begin_src emacs-lisp

  ;;ce qu'il y a dans le buffer de backlinks
  (setq org-roam-mode-sections
        (list #'org-roam-backlinks-section
              #'org-roam-reflinks-section
              #'org-roam-unlinked-references-section
              ))

  ;; on peut mettre des options !
  ;; (org-roam-mode-sections
  ;; '((org-roam-backlinks-section :unique t)
  ;; org-roam-reflinks-section))
#+end_src

***** TODO Lors de la recherche d'un noeud, info sup

****** TODO Voir le nombre de backlinks d'une note + Utiliser la souris sur le buffer backlinks

#+begin_src emacs-lisp

  (with-eval-after-load 'org-roam
    (define-key org-roam-mode-map [mouse-1] #'org-roam-visit-thing)
    ;; for org-roam-buffer-toggle
    ;; Recommendation in the official manual
    (add-to-list 'display-buffer-alist
                 '("\\*org-roam\\*"
                   (display-buffer-in-direction)
                   (direction . right)
                   (window-width . 0.33)
                   (window-height . fit-window-to-buffer)))
    ;;pour avoir le nombre de backlinks lorsque que l'on cherche un node
    (cl-defmethod org-roam-node-directories ((node org-roam-node))
      (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
          (format "%s" (car (f-split dirs)))
        ""))
    (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
      (let* ((count (caar (org-roam-db-query
                           [:select (funcall count source)
                                    :from links
                                    :where (= dest $s1)
                                    :and (= type "id")]
                           (org-roam-node-id node)))))
        (format "%d" count)))
    )


#+end_src

****** TODO hiérarchie quand on cherche/insert une note

#+begin_src emacs-lisp


  (with-eval-after-load 'org-roam


    ;; pour avoir la hiérarchie lorsque c'est une sous note 
    (cl-defmethod org-roam-node-filetitle ((node org-roam-node))
    "Return the file TITLE for the node."
    (org-roam-get-keyword "TITLE" (org-roam-node-file node)))


    (cl-defmethod org-roam-node-hierarchy ((node org-roam-node))
    "Return the hierarchy for the node."
    (let ((title (org-roam-node-title node))
    (olp (org-roam-node-olp node))
    (level (org-roam-node-level node))
    (filetitle (org-roam-node-filetitle node)))
    (concat
    (if (> level 0) (concat filetitle " -> "))
    (if (> level 1) (concat (string-join olp " -> ") " -> "))
    title))) ;; soit disant une erreur ici, mais tout va bien

    )


    ;; (setq org-roam-node-display-template "${directories:15} ${tags:40} ${backlinkscount:1}")
    ;; (setq org-roam-node-display-template "${directories:10} ${tags:10} ${title:100} ${backlinkscount:6}")

#+end_src

****** Qu'est ce qu'on met lorsque l'on recherche un node (nombre = nombre de caractère)

#+begin_src emacs-lisp
  (with-eval-after-load 'org-roam
    ;; (setq org-roam-node-display-template "${directories:15} ${hierarchy:105} ${tags:40} ${backlinkscount:1}") ;;plus besion des fichiers


    (cl-defmethod org-roam-node-type ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (file-name-nondirectory
           (directory-file-name
            (file-name-directory
             (file-relative-name (org-roam-node-file node) org-roam-directory))))
        (error "")))

    (setq org-roam-node-display-template "${type:15} ${hierarchy:130} ${tags:40} ${backlinkscount:2}")

    )
#+end_src



**** Fin de use-package org-roam
#+begin_src emacs-lisp
)
#+end_src


*** Fonctionnalité en plus grâce à l'utilisation d' org-roam

***** TODO Bibliothèque pour gérer certaines choses utiles

#+begin_src emacs-lisp
  (straight-use-package '(nursery
                          :host github
                          :repo "chrisbarrett/nursery"))



  ;; deps
  (use-package org-drill)
  (use-package org-roam-review
    :straight nil ;; c'est dans nursery, c'est donc déjà chargé
    ;; :load-path "config/lisp/nursery/lisp/" 
    ;; :load-path "straight/build/nursery"
    :commands (org-roam-review
               org-roam-review-list-by-maturity
               org-roam-review-list-recently-added)

    ;; ;; Optional - tag all newly-created notes as seedlings.
    ;; :hook (org-roam-capture-new-node . org-roam-review-set-seedling)

    ;; ;; Optional - keybindings for applying Evergreen note properties.
    ;; :general
    ;; (:keymaps 'org-mode-map
    ;; "C-c r r" '(org-roam-review-accept :wk "accept")
    ;; "C-c r u" '(org-roam-review-bury :wk "bury")
    ;; "C-c r x" '(org-roam-review-set-excluded :wk "set excluded")
    ;; "C-c r b" '(org-roam-review-set-budding :wk "set budding")
    ;; "C-c r s" '(org-roam-review-set-seedling :wk "set seedling")
    ;; "C-c r e" '(org-roam-review-set-evergreen :wk "set evergreen"))

    ;; ;; Optional - bindings for evil-mode compatability.
    ;; :general
    ;; (:states '(normal) :keymaps 'org-roam-review-mode-map
    ;; "TAB" 'magit-section-cycle
    ;; "g r" 'org-roam-review-refresh)
    )


  (use-package org-roam-search
    :straight nil ;; c'est dans nursery, c'est donc déjà chargé
    :commands (org-roam-search))

  (use-package org-roam-dblocks
    :straight nil ;; c'est dans nursery, c'est donc déjà chargé
    :hook (org-mode . org-roam-dblocks-autoupdate-mode))

  (use-package org-roam-consult
    :straight nil ;; c'est dans nursery, c'est donc déjà chargé
    :commands (org-roam-consult))

  ;; (use-package org-roam-gc
  ;; :commands (org-roam-consult))



#+end_src

***** Gestion des noeuds

****** CANCELLED Quand on-change le titre, ça change le nom du fichier

#+begin_src emacs-lisp :tangle no

  (defun org-roam-rename-file-with-new-title ()
    (when-let*
        ((is-roam-file (org-roam-file-p old-file))
         (is-not-a-key ())
         (old-file (buffer-file-name))

         (file-node (save-excursion
                      (goto-char 1)
                      (org-roam-node-at-point)))
         (date (substring (number-to-string  (read
                                              (split-string
                                               (org-roam-node-id
                                                (save-excursion
                                                  (goto-char 1)
                                                  (org-roam-node-at-point))) "-"))) 0 14))
         (slug (org-roam-node-slug file-node))
         (new-file (expand-file-name (concat date "-" slug ".org")))
         (different-name? (not (string-equal old-file new-file))))
      (when (not (member old-file (org-roam-dailies--list-files)))

        ;; ;; on le fait que si c'est pas dans le journal ou si c'est pas une clé!
        (rename-buffer new-file)
        (rename-file old-file new-file)
        (set-visited-file-name new-file)
        (set-buffer-modified-p nil)
        )
      ))

  ;; (add-hook 'before-save-hook 'org-roam-rename-file-with-new-title)
  ;; (remove-hook 'before-save-hook 'org-roam-rename-file-with-new-title)

#+end_src


****** Lors de l'ajout d'un noeud, permet de remplacer dans les org-files les unlinked references par le titre



#+begin_src emacs-lisp

  (defun cp/org-roam-unlinked-references-find-and-replace ()
    (message "Check unlinked references")
    (save-window-excursion
      (if-let* ((note (vulpea-db-get-by-id (org-id-get)))
                (id (vulpea-note-id note))
                (title (vulpea-note-title note))
                (FROM-STRING title) 
                (TO-STRING (concat "[[id:" id "][" title "]]")))
          (progn


            (dolist (file (org-roam-list-files))
              ;; on check pas les fichiers cryptés !
              (unless (string-equal (file-name-extension file) "gpg")
                (find-file file)
                (unless (string-equal id (vulpea-db-get-id-by-file (buffer-file-name))) ;;faut pas que ce soit le fichier de base
                  (save-excursion
                    (goto-char (point-min))
                    (while (re-search-forward
                            (concat "\\([ ]\\|^\\)" title "\\([ ]\\|$\\)")
                            nil t)
                      (goto-char (match-beginning 0))
                      (skip-chars-forward " ")
                      (search-forward FROM-STRING)

                      (when (y-or-n-p "Remplacé le texte par un lien vers le nouveau titre ?")

                        ;; obligé de faire ça à cause du y-or-n-p qui me brise mon match. Je pourrais juste mettre (search-forward FROM-STRING) ici, mais si je remplace pas le texte, boucle infini
                        (search-backward FROM-STRING)
                        (goto-char (match-end 0))

                        (replace-match TO-STRING)
                        (message "Texte remplacé")
                        )))
                  ;; ancien ;;(query-replace FROM-STRING TO-STRING nil (point-min) (point-max)) ;; pour pas prendre en compte quand c'est dans une chaîne 3 argument t
                  (save-buffer)
                  )))
            (message "Fin check unlinked references")
            )        ;; fin du si oui

        (progn (message "Pas besoin de check les références"))
        )))

  ;;(add-hook 'org-capture-after-finalize-hook #'(lambda () (when (member (buffer-file-name) (org-roam-list-files)) (cp/org-roam-unlinked-references-find-and-replace))))


  (add-hook 'org-capture-after-finalize-hook
            #'(lambda ()
                (save-window-excursion
                  (org-capture-goto-last-stored)
                  (when (member (buffer-file-name) (org-roam-list-files)) (cp/org-roam-unlinked-references-find-and-replace)))))


#+end_src
****** Permet de rename un noeud partout ! Pas sûr que cela marche
******* Avec Nursery

#+begin_src emacs-lisp

  (use-package org-roam-rewrite
    :straight nil ;; c'est dans nursery, c'est donc déjà chargé
    :commands (org-roam-rewrite-rename
               org-roam-rewrite-remove
               org-roam-rewrite-inline
               org-roam-rewrite-extract))

#+end_src
******* Ma version
#+begin_src emacs-lisp :tangle no

    ;; todo : utiliser ceci
    ;; (title-without-parens-and-space "testetau   ()")


  (defun cp/org-roam-rename-and-replace ()
    (interactive)
    (save-window-excursion
      (let* ((note (vulpea-select-from "la note à changer de nom" (vulpea-db-query)))
             (id (vulpea-note-id note))
             (title (vulpea-note-title note))
             (new-title (read-string "nouveau nom "))
             (FROM-STRING (concat "[[id:" id "][" title "]]")) 
             (TO-STRING (concat "[[id:" id "][" new-title "]]")))
        ;; on rename dans le fichier de base
        (find-file (vulpea-db-get-file-by-id id))
        (vulpea-buffer-title-set new-title)
        ;; pour les autres fichiers
        (dolist (file (org-roam-list-files))
          (find-file file)
          (unless (string-equal id (vulpea-db-get-id-by-file (buffer-file-name))) ;;faut pas que ce soit le fichier de base
            (query-replace FROM-STRING TO-STRING nil (point-min) (point-max)) ;; pour pas prendre en compte quand c'est dans une chaîne 3 argument t
            (save-buffer)
            )))))
  


#+end_src



****** Voir l'historique d'un fichier (avec magit)

#+begin_src emacs-lisp

  (defun cp/history-of-a-node (&optional file)
      (interactive (list (vulpea-db-get-file-by-id (vulpea-note-id (vulpea-select-from "historique de cette note : " (vulpea-db-query))))))
      (find-file file)
      (magit-log-buffer-file)
      (delete-other-windows)
      )

#+end_src



****** Fonction pour naviguer rapidement au niveau des noeuds (ou bien utiliser org-roam-ui !!!!)

Deux fonctions : une qui ajoute "Backlinks :" au debut des titres et l’autre "Links :". prend en paramétre une liste de note vulpea (gérer le cas vide). et retourne une nouvelle liste modifié.
Pas possible, car impossible de modifié une note-vulpea dans une liste. Rip. Faire autrement (un jour)

Voir après pour un mini test de ces deux fonctions

#+begin_src emacs-lisp

  (defun cp/vulpea-get-id-at-point()
    "renvoie l'id du noeud au point actuel"
    (let ((id (org-id-get)))
      ;; tant que actuelle pas d'id, alors on monte,
      (save-excursion
        (while (and (ignore-errors (outline-up-heading 1 t)) (not id))
          (when (org-id-get)
            (setq id (org-id-get)))
          )
        ;; sinon on prend l'id du buffer
        (unless id
          (save-excursion
            (goto-char (point-min))
            (setq id (org-id-get)))
          ))
      id
      ))

  (defun cp/vulpea-links-to()
    "Renvoie une liste de note présent dans le noeud"
    (let (end)
      (dolist (id (remove nil
                          (mapcar
                           (lambda (x)
                             (when (string-equal (car x) "id")
                               (cdr x))
                             )
                           (vulpea-note-links (vulpea-db-get-by-id
                                               (cp/vulpea-get-id-at-point)
                                               ))
                           )))
        ;; (message "test %S"(vulpea-db-get-by-id id))
        (push (vulpea-db-get-by-id id) end)
        )
      end
      )
    )


  (defun cp/vulpea-find-backlink-and-links ()
    "Select and find a note linked to current note."
    (interactive)
    (let* ((node (org-roam-node-at-point 'assert))
           (backlinks (vulpea-db-query-by-links-some
                       (list (cons "id"
                                   (org-roam-node-id node)))))
           (links-to (cp/vulpea-links-to))
           )
      (unless (or backlinks links-to)
        (user-error "Pas de lien vers ni de backlinks"))
      ;; (message "les deux %S" (append test backlinks))
      ;; (message "back %S" backlinks)
      (vulpea-find
       :candidates-fn (lambda (_) (append
                                   backlinks
                                   ;; '(#s(vulpea-note "20220728120707052420" "/home/utilisateur/braindump/org/pages/20220728120707-test_nom_simpl.org" 0 "Liens vers :" nil nil nil (("id" . "20220617105540968308") ("id" . "20220617115633324937") ("id" . "20220623142208004885") ("id" . "20220616193340664791")) (("CATEGORY" . "20220728120707-test_nom_simpl") ("ID" . "20220728120707052420") ("BLOCKED" . "") ("FILE" . "/home/utilisateur/braindump/org/pages/20220728120707-test_nom_simpl.org") ("PRIORITY" . "D")) (("linkInTitle" "[[id:20220617105540968308][Git]]" "[[id:20220617115633324937][Page de Test]]" "[[id:20220623142208004885][Histoire de la chine]]" "[[id:20220616193340664791][Comment faire un second cerveau]]"))))
                                   links-to))
       :require-match t)))

  (defun cp/vulpea-navigate-with-backlink-and-links ()
    (interactive)
    (if (member (buffer-file-name) (org-roam-list-files))
        (while t
          (cp/vulpea-find-backlink-and-links)
          )
      (message "il faut être dans un buffer org-mode")
      )
    )

#+end_src

Autre version, peut-être à choisir (mais break la sémantique de vulpea-find) :

#+begin_src emacs-lisp :tangle no

  (cl-defun vulpea-find-no-create (&key other-window
                                        filter-fn
                                        candidates-fn
                                        require-match)
    "As vulpea-find, but if the note does not exist, then return t instead of creating it"
    (interactive)
    (let* ((region-text
            (when (region-active-p)
              (org-link-display-format
               (buffer-substring-no-properties
                (set-marker
                 (make-marker) (region-beginning))
                (set-marker
                 (make-marker) (region-end))))))
           (note (vulpea-select-from
                  "Note"
                  (funcall
                   (or
                    candidates-fn
                    vulpea-find-default-candidates-source)
                   (or
                    filter-fn
                    vulpea-find-default-filter))
                  :require-match require-match
                  :initial-prompt region-text)))
      (if (vulpea-note-id note)
          (org-roam-node-visit
           (org-roam-node-from-id (vulpea-note-id note))
           (or current-prefix-arg
               other-window))
        (when (not require-match)
          t))))



  (defun cp/vulpea-find-backlink-and-links ()
    "Select and find a note linked to current note."
    (interactive)
    (let* ((node (org-roam-node-at-point 'assert))
           (backlinks (vulpea-db-query-by-links-some
                       (list (cons "id"
                                   (org-roam-node-id node)))))
           (links-to (cp/vulpea-links-to))
           )
      (unless (or backlinks links-to)
        (user-error "Pas de lien vers ni de backlinks"))
      ;; (message "les deux %S" (append test backlinks))
      ;; (message "back %S" backlinks)
      (vulpea-find-no-create
       :candidates-fn (lambda (_) (append
                                   backlinks
                                   links-to))
       ;; :require-match t
       )
      ))

  (defun cp/vulpea-navigate-with-backlink-and-links ()
    (interactive)
    (if (member (buffer-file-name) (org-roam-list-files))
        (while (not (cp/vulpea-find-backlink-and-links)))
      (message "You must be in a file of org-roam")
      )
    )

#+end_src

****** TODO Fonctions pour faire des recherches

#+begin_src emacs-lisp :tangle no




  (vulpea-select-from "texet" (vulpea-db-query
                               (lambda (note)
                                 (and
                                  ;; (string-equal (vulpea-meta-get note "utilisateur") "email")
                                  ;; (= (vulpea-note-level note) 0)
                                  (< (vulpea-note-meta-get note "numbers" 'number) 100)
                                  )
                                 )))


  (setq note (vulpea-db-get-by-id (org-id-get)))


  (vulpea-select-from "Choses à voir"
                      (vulpea-db-query
                       (lambda (note)
                         ;; (and
                         ;; (seq-contains-p (vulpea-note-links note) (cons "id" "8f62b3bd-2a36-4227-a0d3-4107cd8dac19"))
                         (or
                          ;; (seq-contains-p (vulpea-meta-get note "utilisateur") "testee")
                          (string-equal (vulpea-meta-get note "utilisateur") "email")
                          (seq-contains-p (vulpea-note-tags note) "utilisateur")
                          ;; )
                          )))
                      )

  (vulpea-select-from "texte" (vulpea-db-query
                       (lambda (note)
                         (< (vulpea-note-meta-get note "numbers" 'number) 100))))


#+end_src


****** Fonction pour savoir où je parle de X chose. Super 


#+begin_src emacs-lisp

  (defun cp/vulpea-find-backlinks-every ()
    "Find the notes that contain links to X other notes"
    (interactive)
    (let* (
           (notes (vulpea-utils-collect-while
                   #'vulpea-select
                   nil
                   "Note" :require-match t))
           (list-of-cons (seq-map
                          #'(lambda (note) (cons "id" (vulpea-note-id note)))
                          notes
                          ))
           (links (vulpea-db-query-by-links-every list-of-cons))     
           )
      (unless links
        (user-error "There are no notes with the links you demand"))
      (vulpea-find
       :candidates-fn (lambda (_) links)
       :require-match t)
      )
    )


#+end_src

****** Naviguer avec un menu sur le coté (backlinks and normal)

https://github.com/chrisbarrett/nursery

#+begin_src emacs-lisp :tangle no


(use-package org-roam-links
    :straight nil ;; c'est dans nursery, c'est donc déjà chargé
    :commands (org-roam-links))

#+end_src

****** TODO Fonction permettant de corriger les titres et de mettre des métadata titre après la capture (ne pas faire comme ça)
:LOGBOOK:
- State "TODO"       from              [2022-08-06 Sat 00:20]
:END:

#+begin_src emacs-lisp :tangle no

  (defun test ()
    (interactive)
    (goto-char (point-min))
    (message "salut, le point est là : %s" (point))
    (message "salut, le point est là :")
    )

  (add-hook
   'org-capture-after-finalize-hook
   #'(lambda () (message "dedans hook : %s" (buffer-file-name))
       (when
           (member (buffer-file-name) (org-roam-list-files))
         (test)
         (message "dedans whe")
         )))

  (add-hook 'org-capture-after-finalize-hook
            #'(lambda ()
                (save-window-excursion
                  (org-capture-goto-last-stored)
                  (when (member (buffer-file-name) (org-roam-list-files)) (test)))))


  (remove-hook 'org-capture-after-finalize-hook #'(lambda () (when (member (buffer-file-name) (org-roam-list-files)) (test))))

#+end_src



****** Transforme un heading en note

#+begin_src emacs-lisp

  ;; l'améliorer en prenant les choses différents et avec tout dans un let
  (defun cp/vulpea-heading-to-note()
    (interactive)
    (when-let* ((note (vulpea-db-get-by-id (cp/vulpea-get-id-at-point)))
                (heading (org-entry-get nil "ITEM"))
                (title (progn (while (setq name (vulpea-note-id (setq notetest (vulpea-select "Veuillez choisir un nom qui n'existe pas :" :initial-prompt heading))))
                                )
                              (vulpea-note-title notetest))
                       )

                (source (vulpea-meta-get note "Source"))
                (lieu (vulpea-meta-get note "Lieu"))
                )
      (save-excursion
        (ignore-errors (outline-up-heading 0))
        (save-restriction
          (org-narrow-to-subtree)
          ;; on coupe le titre
          (delete-region (line-beginning-position) (line-beginning-position 2))
          ;;
          (setq contenu (buffer-substring-no-properties (point-min) (point-max)))
          (delete-region (point-min) (point-max))
          (vulpea-create
           title
           "pages/%(substring (shell-command-to-string \"uuidgen\")0 -1).org"
           ;; :properties '(("COUNTER" . "1")
           ;; ("STATUS" . "ignore")
           ;; ("ROAM_ALIASES" . "\"Very rich note with an alias\""))
           ;; :tags '("documentation" "showcase")
           ;; :head "#+author: unknown\n#+date: today"
           :body (concat
                  "- Source :: " source "\n"
                  "- Lieu :: " lieu "\n"
                  contenu
                  )
           ;; :immediate-finish t
           )))))

#+end_src


***** Référence key

****** On n'ajoute pas une citation déjà mise ailleurs

#+begin_src emacs-lisp

  (defun cp/org-roam-ref-add-check (keys-entries)
    (interactive (list (citar-select-ref :multiple nil :rebuild-cache t)))
    (let ((title (citar--format-entry-no-widths (cdr keys-entries)
                                                "${author editor} :: ${title}"))

          (citation-key (car keys-entries))
          )
      (when (member `(,citation-key) ;; ` = liste, mais permet d'évaluer la variable juste aprèsle,
                    (org-roam-db-query
                     [:select ref
                              :from refs
                              :left-join nodes
                              :on (= refs:node-id nodes:id)]))
        (org-roam-ref-remove (citar-org-return-citation-string (citar--extract-keys (list citation-key))))
        (user-error "La référence est déjà mise dans un autre noeud pour la ROAM_REFS"))
      ))

  ;; (advice-add 'cp/org-roam-ref-add :before #'cp/org-roam-ref-add-check)
  ;; (advice-remove 'cp/org-roam-ref-add #'cp/org-roam-ref-add-check)

  ;; (advice-add 'org-roam-ref-add :before #'cp/org-roam-ref-add-check)
  ;; (advice-remove 'org-roam-ref-add #'cp/org-roam-ref-add-check)


#+end_src


****** Quand on ajoute un ref, proprose directement si citar configuré

#+begin_src emacs-lisp

  (defun citar-org-return-citation-string (keys &optional style)
    "Inspiré de citar-org-insert-citation. Au lieu d'insérer, renvoie"
    (let ((context (org-element-context)))
      (when style
        (let ((raw-style
               (citar-org-select-style)))
          (setq style
                (if (string-equal raw-style "") raw-style
                  (concat "/" raw-style)))))
      (if-let ((citation (citar-org--citation-at-point context)))
          (when-let ((keys (seq-difference keys (org-cite-get-references citation t)))
                     (keystring (mapconcat (lambda (key) (concat "@" key)) keys "; "))
                     (begin (org-element-property :contents-begin citation)))
            (if (<= (point) begin)
                (org-with-point-at begin
                  (insert keystring ";"))
              (let ((refatpt (citar-org--reference-at-point)))
                (org-with-point-at (or (and refatpt (org-element-property :end refatpt))
                                       (org-element-property :contents-end citation))
                  (if (char-equal ?\; (char-before))
                      (insert-before-markers keystring ";")
                    (insert-before-markers ";" keystring))))))
        (format "[cite%s:%s]" (or style "")
                (mapconcat (lambda (key) (concat "@" key)) keys "; "))
        )))

  (defun cp/org-roam-ref-add (keys-entries)
    "Add REF to the node at point."
    (interactive (list (citar-select-ref :multiple nil :rebuild-cache t)))
    (cp/org-roam-ref-add-check keys-entries) ;;check si la ref est déja mise
    (let ((node (org-roam-node-at-point 'assert))
          (ref-key (citar-org-return-citation-string (citar--extract-keys (list keys-entries)))))
      (save-excursion
        (goto-char (org-roam-node-point node))
        (org-roam-property-add "ROAM_REFS" ref-key))))

#+end_src


***** Ouvrir une url en roam

#+begin_src emacs-lisp

  (defun cp-open-node-roam-ref-url (&optional id)
    "Open the URL in this node's ROAM_REFS property, if one exists"
    (interactive)
    (when-let*
        ((roam_refs
          (progn
            (save-window-excursion
              (when (not (null id))
                (find-file (vulpea-db-get-file-by-id id)))
              (ignore-errors(split-string (org-entry-get-with-inheritance "ROAM_REFS"))))))
         (url-re
          ;; "\\b\\(\\(www\\.\\|\\(s?https?\\|ftp\\|file\\|gopher\\|nntp\\|news\\|telnet\\|wais\\|mailto\\|info\\):\\)\\(//[-a-z0-9_.]+:[0-9]*\\)?\\(?:[-a-z0-9_=#$@~%&*+\\/[:word:]!?:;.,]+([-a-z0-9_=#$@~%&*+\\/[:word:]!?:;.,]+)\\(?:[-a-z0-9_=#$@~%&*+\\/[:word:]!?:;.,]+[-a-z0-9_=#$@~%&*+\\/[:word:]]\\)?\\|[-a-z0-9_=#$@~%&*+\\/[:word:]!?:;.,]+[-a-z0-9_=#$@~%&*+\\/[:word:]]\\)\\)"
          url-handler-regexp
          )
         ref-url 
         )
      (dolist (ref roam_refs)
        (when (string-match url-re ref)
          (setq ref-url ref)))
      (browse-url ref-url)))


#+end_src




***** Deft, pour chercher dans toutes les notes d'org-roam, remplacé par consult org-roam

#+begin_src emacs-lisp :tangle no
  (use-package deft
    :after org-roam
    :config
    (setq deft-extensions '("org")
          deft-directory org-roam-directory
          deft-recursive t
          deft-strip-summary-regexp ":PROPERTIES:\n\\(.+\n\\)+:END:\n"
          deft-use-filename-as-title t)
    )
#+end_src

***** Consult org-roam

#+begin_src emacs-lisp 
  (use-package consult-org-roam
     :config
     ;; Activate the minor-mode
     (consult-org-roam-mode 1)
     (setq consult-org-roam-grep-func #'consult-ripgrep))
#+end_src


***** Convertir les fichiers org en markdown hugo

#+begin_src emacs-lisp
  (use-package ox-hugo
    :after org org-roam
    ;; :custom
    ;;à modifier
    ;; (org-hugo-base-dir "/home/msi/Documents/Projet/SitesWeb/braindump")
    )
#+end_src


***** Org roam ui (org roam server pour org roam v2)


La vue en bulle, comme Obsidian
Il faut que le serveur soit démarré
Se trouve à cette adresse http://127.0.0.1:35901/ 

#+begin_src emacs-lisp

  (when termux-p
    ;; This makes Emacs in Termux use your Android browser for opening urls
    (setq browse-url-browser-function 'browse-url-xdg-open)
    )

  (use-package org-roam-ui
    :after org-roam
    :straight
    (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    ;; :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start nil)
    )

#+end_src

** Gestion des références/bibliographie


#+begin_src emacs-lisp
  (setq bibtex-dialect 'biblatex)

  (setq bibtex-completion-bibliography bibliography-file-list)
  (setq bibtex-completion-library-path bibliography-library-paths)
  (setq bibtex-completion-pdf-field "File") ;; pour trouver les pdf

#+end_src


*** Gestion des insertions et de l'export
**** Ce qu'il reste à fairepour org-cite (un jour)
:PROPERTIES:
:ID:       8aac069c-ecda-4a5f-82df-add2a7ddfdcb
:END:
   
1. trouver pour tout le temps print la bibliographie sans mettre print_bibliographie à la fin

2. 

3.
**** Comment ça marche avec org-cite ?
***** Pour l'installation de zotero + extension betterbitex
:PROPERTIES:
:ID:       e254ed4d-d47b-4b9d-9155-108772b8b2c7
:END:
Cela permet d'auto exporter la bibliothèque.

[[https://blog.tecosaur.com/tmio/2021-07-31-citations.html#using-csl][Bon site pour comprendre comment ça marche]]
Pour la gestion des références : installation de Zotero + [[https://github.com/retorquere/zotero-better-bibtex/releases/tag/v6.2.5][extension betterbibtex]] qui est sur github (voir un tuto pour l'installer)


1. In the main menu go to Tools > Add-ons
2. Select ‘Extensions’
3. Click on the gear in the top-right corner and choose ‘Install Add-on From File…’
4. Choose .xpi that you’ve just downloaded, click ‘Install’
5. Restart Zotero


puis on automatise l'exportation avec l'extension !
(Fichier->exporter bibliothèque, sélectionner Better BibLatex et cocher : exporter les notes et garder à jour ! )

([[https://retorque.re/zotero-better-bibtex/exporting/auto/][ici]])

***** Pour citar et citeproc
On utilise les package citar et citeproc. Le premier pour insérer les citations , le deuxième pour exporter
Il faut configurer la variable de la/les bibliothèques.

Pour résumé, il faut juste :
# #+bibliography: references.bib ;;pas besoins car remplacer par la variable juste en dessous
# [cite:@key]
# #+print_bibliography:

Pour exporter :
# #+cite_export: csl
ou bien juste :

(Pour la conversion de org-ref à org-cite, il suffit juste d'enlever une paire de crochet au références de org-ref, puis de remplacer le "&" par "@", et de moddifier le print_biblio en 
[[bibliography:../biblio.bib] ] , logique quoi et assez simple à faire je pense)

**** Citar, les propositions avec citar-insert-citation

#+begin_src emacs-lisp

  (use-package citar
    ;; :after all-the-icons ;; besoin des icones pour charger les propositions
    ;; :after oc-csl all-the-icons
    :custom
    ;;lieu de ma bibliographie
    (citar-bibliography bibliography-file-list)
    ;; lieu de mes fichiers pour citar
    (citar-library-paths bibliography-library-paths)
    :config
    ;; pour complété avec consult yeah, pas besoin
    ;; (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

    ;; comment on gère l'affichage des propositions en dur
    (setq citar-templates
          '((main . "${author editor:30}     ${date year issued:4}     ${title:48}")
            (suffix . "          ${=key= id:15}    ${=type=:12}    ${tags keywords:*}")
            (preview . "${author editor} (${year issued date}) ${title}, ${journal journaltitle publisher container-title collection-title}.\n")
            (note . "Notes on ${author editor}, ${title}")))
    ;;le séparateur
    (setq citar-symbol-separator "  ")

    ;; et affichage des icônes à gauche
    (setq citar-symbols
          `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
            (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
            (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " ")))

    ;; automatiquement refresh lorque l'on modifie la bibliographie
    (citar-filenotify-setup '(LaTeX-mode-hook org-mode-hook))

    ;;ancien et test    
    ;; (require 'filenotify)
    ;; (file-notify-add-watch "/home/utilisateur/biblio.bib"
    ;; '(attribute-change) 'citar-refresh)

    ;; (dolist (bibliography-file bibliography-file-list)
    ;; (file-notify-add-watch bibliography-file
    ;; '(attribute-change) 'citar-refresh)
    ;; )

    ;; (require 'filenotify)
    ;; (setq citar-filenotify-callback 'refresh-cache)
    ;; (citar-filenotify-setup '(LaTeX-mode-hook org-mode-hook))
    ;; (defun gen-bib-cache-idle ()
    ;; "Generate bib item caches with idle timer"
    ;; (run-with-idle-timer 0.5 nil #'citar-refresh))
    ;; (add-hook 'LaTeX-mode-hook #'gen-bib-cache-idle)
    ;; (add-hook 'org-mode-hook #'gen-bib-cache-idle)


    ;;patch pour ajouter des citations dans le mini-buffer avec le style POUR ORG-MODE SEULEMENT 
    (defcustom citar-major-mode-functions
      '(((org-mode) .
         ((local-bib-files . citar-org-local-bib-files)
          (insert-citation . citar-org-insert-citation)
          (insert-edit . citar-org-insert-edit)
          (key-at-point . citar-org-key-at-point)
          (citation-at-point . citar-org-citation-at-point)
          (list-keys . citar-org-list-keys)))
        ((latex-mode) .
         ((local-bib-files . citar-latex-local-bib-files)
          (insert-citation . citar-latex-insert-citation)
          (insert-edit . citar-latex-insert-edit)
          (key-at-point . citar-latex-key-at-point)
          (citation-at-point . citar-latex-citation-at-point)
          (list-keys . reftex-all-used-citation-keys)))
        ((markdown-mode) .
         ((insert-keys . citar-markdown-insert-keys)
          (insert-citation . citar-markdown-insert-citation)
          (insert-edit . citar-markdown-insert-edit)
          (key-at-point . citar-markdown-key-at-point)
          (citation-at-point . citar-markdown-citation-at-point)
          (list-keys . citar-markdown-list-keys)))

        ;;patch début ici
        ((minibuffer-mode) .
         ( (insert-citation . citar-org-insert-citation)
           ))
        ;;patch fin ici

        (t .
           ((insert-keys . citar--insert-keys-comma-separated))))
      "The variable determining the major mode specific functionality.

                  It is alist with keys being a list of major modes.

                  The value is an alist with values being functions to be used for
                  these modes while the keys are symbols used to lookup them up.
                  The keys are:

                  local-bib-files: the corresponding functions should return the list of
                  local bibliography files.

                  insert-keys: the corresponding function should insert the list of keys given
                  to as the argument at point in the buffer.

                  insert-citation: the corresponding function should insert a
                  complete citation from a list of keys at point.  If the point is
                  in a citation, new keys should be added to the citation.

                  insert-edit: the corresponding function should accept an optional
                  prefix argument and interactively edit the citation or key at
                  point.

                  key-at-point: the corresponding function should return the
                  citation key at point or nil if there is none.  The return value
                  should be (KEY . BOUNDS), where KEY is a string and BOUNDS is a
                  pair of buffer positions indicating the start and end of the key.

                  citation-at-point: the corresponding function should return the
                  keys of the citation at point, or nil if there is none.  The
                  return value should be (KEYS . BOUNDS), where KEYS is a list of
                  strings and BOUNDS is pair of buffer positions indicating the
                  start and end of the citation.

                  list-keys: the corresponding function should return the keys
                  of all citations in the current buffer."
      :group 'citar
      :type 'alist)
    )

#+end_src

**** Pour les exports
:PROPERTIES:
:ID:       7ebb8fdb-0d07-4b8d-b86a-9d8cf2109848
:END:

#+begin_src emacs-lisp

  (use-package citeproc
    :straight (:host github :repo "andras-simonyi/citeproc-el")
    :after citar

    :init
    ;; nom du titre exporté pour la bibliographie
    (with-eval-after-load 'ox-hugo
      (plist-put org-hugo-citations-plist :bibliography-section-heading "References"))

    :config
    
    (setq org-cite-global-bibliography bibliography-file-list) ;; pour que org-cite sache où est ma biblio


    (require 'oc-csl)
    (setq org-cite-export-processors '((t csl)));; exporter tout le temps avec la méthode csl

    ;; les fichiers de configuration. Impossible de les configurer "normalement" (voir en dessous), j'utilise donc les fichiers "fallback" qui sont ceux par défaut
    ;; (setq org-cite-csl--fallback-style-file "/home/msi/documents/notes/braindump/org/chicago-author-date-16th-edition.csl") ;;

    (setq org-cite-csl--fallback-locales-dir bibliography-directory)
    (setq org-cite-csl--fallback-style-file (concat bibliography-directory "vancouver-brackets.csl"));; pour changer le style. Vancouver = numéro

    )

  ;;le bordel ici, mais pas utilisé
  ;; pas utilisé, mais voir aussi les variable de jethro
  ;; (setq
  ;; org-cite-global-bibliography my-bibliography-list ;; pour que org-cite sache où est ma biblio
  ;; citar-format-reference-function 'citar-citeproc-format-reference
  ;; org-cite-csl-styles-dir "~/Zotero/styles/"
  ;; citar-citeproc-csl-styles-dir org-cite-csl-styles-dir
  ;; citar-citeproc-csl-locales-dir "~/Zotero/locales/"

  ;; doute sur lui, voir le dot de jethro
  ;; citar-citeproc-csl-style (concat (expand-file-name org-cite-csl-styles-dir
  ;; )"apa.csl")

  ;;pour que ça marche, il faut régler ces deux variables
  ;; après avoir exécuté ceci, les export marches TODO
  ;; org-cite-csl--fallback-style-file "/home/msi/documents/notes/braindump/org/reference/chicago-author-date-16th-edition.csl"
  ;; org-cite-csl--fallback-locales-dir "/home/msi/documents/notes/braindump/org/reference"
  ;; )

  ;; (setq org-cite-csl-styles-dir "~/Zotero/styles/")
  ;; (setq org-cite-csl-locales-dir "/home/msi/documents/notes/braindump/org/reference/")

#+end_src

*** Modifications des références
**** Pour générer des clées proprements

#+begin_src emacs-lisp
  (setq bibtex-autokey-year-length 4
        bibtex-autokey-name-year-separator "-"
        bibtex-autokey-year-title-separator "-"
        bibtex-autokey-titleword-separator "-"
        bibtex-autokey-titlewords 2
        bibtex-autokey-titlewords-stretch 1
        bibtex-autokey-titleword-length 5)
#+end_src

**** Pour avoir une interface clean de modification 
#+begin_src emacs-lisp
  (use-package ebib
    :config
    (setq ebib-bibtex-dialect 'biblatex
          ebib-preload-bib-files bibliography-file-list

          ebib-link-file-path-type 'adaptive

          ebib-truncate-file-names t ;; pour pas couper le nom des fichiers
          ebib-default-directory "/home/utilisateur/.emacs.d/config/dossierCitation/"
          ebib-file-search-dirs bibliography-library-paths

          ebib-file-associations nil ;; pour ouvrir pdf ou autre. Si rien, alors fait juste un "find-file", donc parfait

          )

    (define-key ebib-index-mode-map [remap next-line] #'ebib-next-entry)
    (define-key ebib-index-mode-map [remap previous-line] #'ebib-prev-entry)

    (define-key ebib-entry-mode-map [remap next-line] #'ebib-next-field)
    (define-key ebib-entry-mode-map [remap previous-line] #'ebib-prev-field)

    )

  (use-package parsebib
    :straight (parsebib
               :type git
               :host github
               :repo "joostkremers/parsebib")
    )
#+end_src
**** Pour permettre de clean proprement une entry

Télécharge le pdf et autre choses



#+begin_src emacs-lisp

  ;; juste pour la fonction org-ref-clean-bibtex-entry
  (use-package org-ref
    :config
    (setq org-ref-bibtex-pdf-download-dir (car bibliography-library-paths))

    (setq org-ref-clean-bibtex-entry-hook
          '(org-ref-bibtex-format-url-if-doi
            orcb-key-comma
            ;; org-ref-replace-nonascii ;; pour que les accents ne reste pas
            orcb-&
            orcb-%
            org-ref-title-case-article
            orcb-clean-year
            orcb-key
            orcb-clean-doi
            orcb-clean-pages
            orcb-check-journal
            org-ref-sort-bibtex-entry
            orcb-fix-spacing
            orcb-download-pdf
            org-ref-stringify-journal-name
            ))


    (setq org-ref-bibtex-sort-order
          '(("article"  . ("author" "title" "journal" "volume" "number" "pages" "year" "doi" "url"))
            ("inproceedings" . ("author" "title" "booktitle" "year" "volume" "number" "pages" "doi" "url"))
            ("book" . ("author" "title" "year" "publisher" "url"))
            ("online" . ("author" "title" "booktitle" "year" "volume" "number" "pages" "doi" "url"))
            ))

    ;;dépendence non chargé

    (use-package async)

    ;; corrections

    (defun orcb-check-journal ()
      "Check entry at point to see if journal exists in `org-ref-bibtex-journal-abbreviations'.
              If not, issue a warning."
      (interactive)
      (bibtex-beginning-of-entry) ;;moddif ici
      (when
          (string= "article"
                   (downcase
                    (cdr (assoc "=type=" (bibtex-parse-entry)))))
        (save-excursion
          (bibtex-beginning-of-entry)
          (let* ((entry (bibtex-parse-entry t))
                 (journal (or (cdr (assoc "journal" entry)) (cdr (assoc "journaltitle" entry)))))  ;;moddif ici condition
            (when (null journal)
              (warn "Unable to get journal for this entry."))
            (unless (member journal (-flatten org-ref-bibtex-journal-abbreviations))
              (message "Journal \"%s\" not found in org-ref-bibtex-journal-abbreviations." journal))))))

    ;;   ;;check tjr les clées
    ;;   (defun orcb-key (&optional allow-duplicate-keys)
    ;;     "Replace the key in the entry.
    ;; Prompts for replacement if the new key duplicates one already in
    ;; the file, unless ALLOW-DUPLICATE-KEYS is non-nil."
    ;;     (let ((key (funcall org-ref-clean-bibtex-key-function
    ;;                         (bibtex-generate-autokey))))
    ;;       ;; remove any \\ in the key
    ;;       (setq key (replace-regexp-in-string "\\\\" "" key))
    ;;       ;; first we delete the existing key
    ;;       (bibtex-beginning-of-entry)
    ;;       (re-search-forward bibtex-entry-maybe-empty-head)
    ;;       (if (match-beginning bibtex-key-in-head)
    ;;           (delete-region (match-beginning bibtex-key-in-head)
    ;;                          (match-end bibtex-key-in-head)))
    ;;       ;; check if the key is in the buffer


    ;;       (message "salut %s %s %s" (not allow-duplicate-keys) key
    ;;                    (bibtex-search-entry key nil nil))

    ;;       (when (and (not allow-duplicate-keys)
    ;;                  (save-excursion

    ;;                    (bibtex-search-entry key)))

    ;;         (save-excursion
    ;;           (bibtex-search-entry key)
    ;;           (bibtex-copy-entry-as-kill)
    ;;           (switch-to-buffer-other-window "*duplicate entry*")
    ;;           (bibtex-yank))
    ;;         (setq key (bibtex-read-key "Duplicate Key found, edit: " key)))

    ;;       (insert key)
    ;;       (kill-new key)))

(defun bibtex-autokey-get-year ()
  "Return year field contents as a string obeying `bibtex-autokey-year-length'."
  (let* ((str (bibtex-autokey-get-field '("date" "year"))) ; possibly ""
         (year (or (and (iso8601-valid-p str)
                        (let ((year (decoded-time-year (iso8601-parse str))))
                          (and year (number-to-string year))))
                   ;; BibTeX permits a year field "(about 1984)", where only
                   ;; the last four nonpunctuation characters must be numerals.
                   (and (string-match "\\([0-9][0-9][0-9][0-9]\\)[^[:alnum:]]*\\'" str)
                        (match-string 1 str))
                   (user-error "Year or date field `%s' invalid" str))))
    (substring year (max 0 (- (length year) bibtex-autokey-year-length)))))
    
    )



#+end_src

*** Connection entre org-roam et citar et biblatex

orb-note-actions orb-edit-citation-note

#+begin_src emacs-lisp

  (use-package org-roam-bibtex
    :config 

    (setq citar-open-note-functions '(orb-citar-edit-note))
    ;; (setq citar-notes-paths nil) ;; si jamais je ne configure pas citar-open-note-functions
    (setq orb-citekey-format 'org-cite) ;; pour @key

    (setq orb-preformat-keywords
          '("citekey" "title" "url" "author-or-editor" "keywords" "file")
          orb-process-file-keyword t
          orb-attached-file-extensions '("pdf"))

    )

#+end_src

*** Méthode pour ajouter des références aux bibfiles
**** Via quelque chose qui permet de l'identifier

#+begin_src emacs-lisp
  (use-package biblio
    :config
    (setq biblio-download-directory (car bibliography-library-paths))
    )

#+end_src
**** Traducteur zotero

Pour faire ceci :

#+begin_src sh

  # installation de node js
  curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
  sudo apt-get install -y nodejs

  # installation du traducteur
  git clone --recurse-submodules https://github.com/zotero/translation-server
  cd translation-server
  npm install

  # lancer le serveur de traducteur (à chaque fois)(doit etre dans le dossier github téléchargé précédemment)
  npm start

#+end_src


#+begin_src emacs-lisp

  (defun lancer-serveur-zotra()
    (interactive)
    (async-shell-command
     (concat
      "cd && cd .emacs.d/config/dossierCitation/translation-server/"
      " && npm start"
      ))
    )

  (unless termux-p (lancer-serveur-zotra))

  (use-package zotra
    :straight (zotra
               :type git
               :host github
               :repo "mpedramfar/zotra")
    :config

    (add-hook 'zotra-after-add-entry-hook 'org-ref-clean-bibtex-entry)

    (setq zotra-default-entry-format "biblatex")
    (setq zotra-default-bibliography (car bibliography-file-list))
    (setq zotra-url-retrieve-timeout 5) ;; plus de temps pour les demandes
    )

#+end_src
*** TODO Drag and drop des pdf

[[https://github.com/rougier/pdf-drop-mode][ici]]

** Présentation avec org-mode

#+begin_src emacs-lisp

  (use-package visual-fill-column)

  (use-package org-present
    :config

    (defun my/org-present-prepare-slide (buffer-name heading)
      ;; Show only top-level headlines
      (org-overview)

      ;; Unfold the current entry
      (org-show-entry)

      ;; Show only direct subheadings of the slide but don't expand them
      (org-show-children))

    (defun my/org-present-start ()
      ;; Tweak font sizes
      (setq-local face-remapping-alist '(
                                         ;; (default (:height 1.5) variable-pitch)
                                         ;; ;;provoque très sur les images
                                         (header-line (:height 4.0) variable-pitch)
                                         (org-document-title (:height 1.75) org-document-title)
                                         (org-code (:height 1.55) org-code)
                                         (org-verbatim (:height 1.55) org-verbatim)
                                         (org-block (:height 1.25) org-block)
                                         (org-block-begin-line (:height 0.7)
                                                               org-block)))

      ;; (setq-local org-image-actual-width 1500) ;; réglé directement au niveau des images

      ;; Set a blank header line string to create blank space at the top
      (setq header-line-format " ")
      ;; (setq org-ellipsis "")

      ;;joli écri
      (variable-pitch-mode 1)

      ;; Display inline images automatically
      (org-display-inline-images)

      (hide-mode-line-mode)
      (toggle-frame-fullscreen)
      (set-frame-parameter (selected-frame) 'alpha '(90 . 100))

      ;; Center the presentation and wrap lines
      (setq visual-fill-column-width 150)
      (setq visual-fill-column-center-text t)
      (visual-fill-column-mode 1)
      (visual-line-mode 1))

    (defun my/org-present-end ()
      ;; Reset font customizations
      (setq-local face-remapping-alist '((default variable-pitch default)))

      ;; Clear the header line string so that it isn't displayed
      (setq header-line-format nil)

      (variable-pitch-mode -1)

      ;; Stop displaying inline images
      (org-remove-inline-images)

      (hide-mode-line-mode -1)
      (set-frame-parameter (selected-frame) 'alpha '(100 . 100))
      (toggle-frame-fullscreen)
      ;; Stop centering the document
      (setq visual-fill-column-width nil)
      (setq visual-fill-column-center-text nil)
      (visual-fill-column-mode 0)
      (visual-line-mode 0))

    ;; Turn on variable pitch fonts in Org Mode buffers
    ;; (add-hook 'org-mode-hook 'variable-pitch-mode)

    ;; Register hooks with org-present
    (add-hook 'org-present-mode-hook 'my/org-present-start)
    (add-hook 'org-present-mode-quit-hook 'my/org-present-end)
    (add-hook 'org-present-after-navigate-functions 'my/org-present-prepare-slide)
    ;; (remove-hook 'org-present-after-navigate-functions 'my/org-present-prepare-slide)

    ;; null. fonction à faire :
    (defun cp/org-present-next-heading ()
      "Jump to next top-level heading."
      (interactive)

      ;; (widen)
      (if (org-current-level)	      ;; inside heading
          (if (= (org-current-level) 1) ;;inside heading 1
              (progn
                (outline-next-heading)
                (recenter)
                (org-show-subtree))
    ;if that was last, go back to top before narrow
            ;; else go to children
            (if (org-get-next-sibling)
                (progn
                  (recenter)
                  (outline-show-children)
                  (outline-show-entry))
              (progn
                (widen)
                (outline-next-heading)
                (org-present-narrow)
                (org-present-run-after-navigate-functions))))
        (org-present-next)))

    ;; désactiver le hook de system crafter pour faire la fonction. il faut donc : si titre 0, alors go titre 1. Si titre 1, alors allez au prochain
    ;; titre 2 et le déplier. doit être en haut. puis, deux choix : soit pas de
    ;; fils. donc, on passe au prochain titre 2. soit, il a un fils. donc, on
    ;; plie les précédents et on affiche titre 3. puis deux solution, soit etc.

    )
#+end_src

** Gestion de mon CV avec org-mode

#+begin_src emacs-lisp

  ;; deleted unwanted file extensions after latex export
  (setq
   org-latex-remove-logfiles t
   org-latex-logfiles-extensions
   (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "xmpi" "run.xml" "bcf" "acn" "acr" "alg" "glg" "gls" "ist")))


  (setq org-latex-packages-alist 'nil)
  ;; (setq org-latex-default-packages-alist
  ;; '(("rm" "roboto"  t)
  ;; ("defaultsans" "lato" t)
  ;; ("" "paracol" t)))
  ;; mettre ceci dans le document plutot :
  ;;#+LATEX_HEADER: \usepackage{paracol}
  ;;#+LATEX_HEADER: \usepackage{lato}
  ;;#+LATEX_HEADER: \usepackage{roboto}

  (use-package org-contrib
    :config
    (require 'ox-extra)
    (use-package ox-extra
      :config
      (ox-extras-activate '(latex-header-blocks ignore-headlines))))


  (add-to-list 'org-latex-classes
               '("altacv" "\\documentclass[10pt,a4paper,ragged2e,withhyper]{altacv}

            % Change the page layout if you need to
            \\geometry{left=1.25cm,right=1.25cm,top=1.5cm,bottom=1.5cm,columnsep=1.2cm}

            % Use roboto and lato for fonts
            \\renewcommand{\\familydefault}{\\sfdefault}

            % Change the colours if you want to
            \\definecolor{SlateGrey}{HTML}{2E2E2E}
            \\definecolor{LightGrey}{HTML}{666666}
            \\definecolor{DarkPastelRed}{HTML}{450808}
            \\definecolor{PastelRed}{HTML}{8F0D0D}
            \\definecolor{GoldenEarth}{HTML}{E7D192}
            \\colorlet{name}{black}
            \\colorlet{tagline}{PastelRed}
            \\colorlet{heading}{DarkPastelRed}
            \\colorlet{headingrule}{GoldenEarth}
            \\colorlet{subheading}{PastelRed}
            \\colorlet{accent}{PastelRed}
            \\colorlet{emphasis}{SlateGrey}
            \\colorlet{body}{LightGrey}

            % Change some fonts, if necessary
            \\renewcommand{\\namefont}{\\Huge\\rmfamily\\bfseries}
            \\renewcommand{\\personalinfofont}{\\footnotesize}
            \\renewcommand{\\cvsectionfont}{\\LARGE\\rmfamily\\bfseries}
            \\renewcommand{\\cvsubsectionfont}{\\large\\bfseries}

            % Change the bullets for itemize and rating marker
            % for \cvskill if you want to
            \\renewcommand{\\itemmarker}{{\\small\\textbullet}}
            \\renewcommand{\\ratingmarker}{\\faCircle}
            "

                 ("\\cvsection{%s}" . "\\cvsection*{%s}")))


#+end_src

** Gestion de ma lettre de motivation avec org-mode


#+begin_src emacs-lisp :tangle no
  (eval-after-load 'ox '(require 'ox-koma-letter))
  (eval-after-load 'ox-koma-letter
    '(progn
       (add-to-list 'org-latex-classes
                    '("my-letter"
                      "\\documentclass\{scrlttr2\}
       \\usepackage[english]{babel}
       \\setkomavar{frombank}{(1234)\\,567\\,890}
       \[DEFAULT-PACKAGES]
       \[PACKAGES]
       \[EXTRA]"))

       (setq org-koma-letter-default-class "my-letter")))

  (eval-after-load 'ox-latex
    '(add-to-list 'org-latex-packages-alist '("AUTO" "babel" t) t))

  (setq org-latex-packages-alist '(("AUTO" "babel" t)))

#+end_src


** Gestion des flashcards


*** brutes
#+begin_src emacs-lisp

  (use-package anki-editor
    :straight (anki-editor
               :type git
               :host github
               :repo "louietan/anki-editor"))

  (use-package org-anki)

#+end_src

*** dans le texte directement

#+begin_src emacs-lisp
  
  ;; (use-package org-mode-incremental-reading
  ;;   :straight (incremental-reading
  ;;             :type git
  ;;             :host github
  ;;             :repo "vascoferreira25/org-mode-incremental-reading"))

  (straight-use-package '(org-mode-incremental-reading
                          :host github
                          :repo "vascoferreira25/org-mode-incremental-reading"))
#+end_src
